<hr>
<p>title: GateWay网关<br>date: 2020-12-21 12:53:51<br>categories: [“SpringCloud”]</p>
<hr>
<h3 id="GateWay网关"><a href="#GateWay网关" class="headerlink" title="GateWay网关"></a>GateWay网关</h3><p>核心逻辑：路由转发+执行过滤器链</p>
<p>三大核心概念：路由、断言、过滤</p>
<p>1.引入POM依赖</p>
<p>GateWay不需要引入web、actuator这两个依赖，本身自己带有</p>
<pre><code class="java">&lt;!--gateway--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--eureka-client--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>2.建立YML文件</p>
<pre><code class="yml"><span class="attr">cloud:</span>
    <span class="attr">gateway:</span>
      <span class="attr">discovery:</span>
        <span class="attr">locator:</span>
          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能，利用微服务名进行路由</span>
      <span class="attr">routes:</span>
        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span>
          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span>
          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span>
          <span class="attr">predicates:</span>
            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span>

        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span>
          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span>
          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span>
          <span class="attr">predicates:</span>
            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span>
            <span class="comment">#- After=2020-02-21T15:51:37.485+08:00[Asia/Shanghai]</span>
            <span class="comment">#- Cookie=username,zzyy</span>
            <span class="comment">#- Header=X-Request-Id, \d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式</span></code></pre>
<p>运行过程：寻找路由里uri提供的服务地址，然后前往predicates断言下的服务地址路径，相匹配的则需要通过访问9527网关端口才可访问服务。同时可添加许多断言规则，具体搜官网</p>
<p><img src="F:%5CBlog%5CMyBlog%5Csource_posts%5CGateWay%E7%BD%91%E5%85%B3%5C1600058451076.png" alt="01"></p>
<p><img src="F:%5CBlog%5CMyBlog%5Csource_posts%5CGateWay%E7%BD%91%E5%85%B3%5C1600058405289.png" alt="1600058405289"></p>
<p>同时还可通过编码方式进行配置路由映射</p>
<pre><code class="java"><span class="meta">@Configuration</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GateWayConfig</span></span>
<span class="class"></span>{
    <span class="meta">@Bean</span>
    <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder routeLocatorBuilder)</span></span>
<span class="function">    </span>{
        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();

        routes.route(<span class="string">"path_route_xzs"</span>,
                r -&gt; r.path(<span class="string">"/guonei"</span>)
                        .uri(<span class="string">"http://news.baidu.com/guonei"</span>));

        <span class="keyword">return</span> routes.build();
    }
}</code></pre>
<p>以上为配置了一个叫path_route_xzs的路由，当访问localhost:9527/guonei，则跳转到<a href="http://news.baidu.com/guonei" target="_blank" rel="noopener">http://news.baidu.com/guonei</a></p>
<p>3.路由过滤</p>
<pre><code class="java"><span class="meta">@Component</span>
<span class="meta">@Slf</span>4j
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogGateWayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>,<span class="title">Ordered</span></span>
<span class="class"></span>{

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span>
<span class="function">    </span>{
        log.info(<span class="string">"***********come in MyLogGateWayFilter:  "</span>+<span class="keyword">new</span> Date());

        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">"uname"</span>);

        <span class="keyword">if</span>(uname == <span class="keyword">null</span>)
        {
            log.info(<span class="string">"*******用户名为null，非法用户，o(╥﹏╥)o"</span>);
            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);
            <span class="keyword">return</span> exchange.getResponse().setComplete();
        }

        <span class="keyword">return</span> chain.filter(exchange);
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span></span>
<span class="function">    </span>{
        <span class="keyword">return</span> <span class="number">0</span>;
    }
}</code></pre>
<p>即实现两个接口GlobalFilter,Ordered，直接进行过滤规则编写。以上为访问时需带上一个uname值才可访问</p>
