<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SpringCloud五大神兽</title>
    <url>/2020/05/12/SpringCloud%E4%BA%94%E5%A4%A7%E7%A5%9E%E5%85%BD/</url>
    <content><![CDATA[<h4 id="Eureka注册中心："><a href="#Eureka注册中心：" class="headerlink" title="Eureka注册中心："></a>Eureka注册中心：</h4><p> 注册中心：itcast-eureka(1.引入启动器  2.配置spring.application.name=itcast-eureka  3.在引导类上加注解@EnableEurekaServer)<br>        客户端： itcast-service-provider   itcast-service-consumer<br>         ( 1.引入启动器  </p>
<p>   2.配置spring.application.name  eureka.client.service-url.defaultZone=<a href="http://localhost:10086/eureka" target="_blank" rel="noopener">http://localhost:10086/eureka</a> (下载APP)<br>              3. @EnableDiscoveryClient(启用eureka客户端))</p>
<p>服务名称修改：instance.instance-id=”xxx”  主机IP信息显示:  instance.prefer-ip-address: true  显示服务信息info: <a id="more"></a></p>
<h4 id="Ribbon负载均衡："><a href="#Ribbon负载均衡：" class="headerlink" title="Ribbon负载均衡："></a>Ribbon负载均衡：</h4><p>1.不需要添加启动器 Eureka里面自带了</p>
<p>2.不需要覆盖默认配置就能使用了</p>
<p>3.在RestTemplate上启用 @LoadBalanced 开启负载均衡</p>
<p>4.使用：通过服务名service-provider修改getForObject(“xxx”)里的参数</p>
<p>​               this.restTemplate.getForObject(“<a href="http://service-provider/user&quot;+id,User.class" target="_blank" rel="noopener">http://service-provider/user&quot;+id,User.class</a>);</p>
<h4 id="Hystrix容错组件："><a href="#Hystrix容错组件：" class="headerlink" title="Hystrix容错组件："></a>Hystrix容错组件：</h4><p>降级：检查每次请求，是否请求超时；或者连接池已满<br>                   1.pom.xml加启动器<br>                   2.不需要覆盖默认配置 因为默认设置超时时间为一秒钟 开发过程中够用，但如果需要改就去copy笔记放入service-consumer的application.yml中配置<br>                   3.开启@EnableCircuitBreaker熔断器注解<br>                   4.写一个熔断方法fallbackMethod()，返回类似”服务器正忙，请稍后再试！”  同时在原方法上加个注解@HystrixCommand(fallbackMethod=”fallbackMethod”) 使该方法调用失败时则会调用熔断方法 返回值和参数列表都一致<br>                   5.或给类统一设定一个熔断方法：@DefaultProperties(defaultFallback=”fallbackMethod”)，防止方法太多一直写上面那个注解，如果方法有自己设置@HystrixCommand熔断方法，则使用他自己设置的熔断方法  且全局熔断方法的返回值和被熔断方法一致，但参数列表为空<br>       熔断：不在发送请求  三种状态<br>                   1.close：闭合状态，所有请求正常访问<br>                   2.open：打开状态，所有请求都无法访问。如果在一定时间内容，失败的比例不小于50%或者次数不少于20次<br>                   3.half open： 半开状态，打开状态默认5s休眠期，在休眠期所有请求无法正常访问。过了休眠期就会进入半开状态，放部分请求通过                          @SpringCloudApplication=@SpringbootApplication+@EnableDiscoveryClient+@EnableCircuitBreaker</p>
<h4 id="Feign远程调用组件："><a href="#Feign远程调用组件：" class="headerlink" title="Feign远程调用组件："></a>Feign远程调用组件：</h4><p>1.service-consume的pox.xml加openFeign启动器<br>        2.在引导类上加注解@EnableFeignClients  就不需要用restTemplate了<br>        3.使用Feign就是创建一个接口 接口上加@FeignClient(value=”service-provider”//服务提供者名字)<br>        4.不能使用@RequestMapping写主路径  只能在接口方法上面的@GetMapping()里把路径全写出来（现在好像修复了？）<br>        5.feign.hystrix.enabled: true 开启Hystrix熔断  默认不开启要开启一下<br>        6.写一个类UserClientFallback实现接口  实现方法就是熔断方法  ，并且在接口原先注解 @FeignClient(value=”service-provider” fallback=UserClientFallback.class//实现类.class)<br>然后在熔断类上加@Component  添加入组件</p>
<h4 id="Zuul网关："><a href="#Zuul网关：" class="headerlink" title="Zuul网关："></a>Zuul网关：</h4><p>1.建立独立的模块  引入Cloud Routing-&gt;Zuul 依赖<br>        2.配置port和spring.application.name<br>        3.导入类上加注解@EnableZuulProxy<br>        4.配置路由(分发服务)： zuul：(第三种配置)<br>                                                 routes：<br>                                                 service-provider：/service-provider/**   #这个服务前缀路径路由到这个服务id  #路由名称，随便写，习惯写上服务名<br>                                                 service-consumer(路由名称)：/consumer/**<br>                                                 #path：/service-provider/**<br>                                                 #url： http：//localhost：8082  #service-provider的路径<br>                                                 #serviceId：service-provider<br>                                                 prefix：/api    #zuul网关的前缀  判断有没有通过网关访问服务<br>                                                  eureka：<br>                                                       client：<br>                                                          service-url：<br>                                                             defaultZone：http：//localhost：10086/eureka<br>        5.过滤器  继承ZuulFilter 重写四个方法<br>                                                                  filterType: pre route post error<br>                                                                  filterOrder: 返回值越小优先级越高<br>                                                                  shouldFilter: 是否执行run方法。true执行<br>                                                                  run: 具体的拦截逻辑</p>
<h4 id="SpringCloud-Config分布式配置中心："><a href="#SpringCloud-Config分布式配置中心：" class="headerlink" title="SpringCloud Config分布式配置中心："></a>SpringCloud Config分布式配置中心：</h4><p>每个微服务都有个application.yml，要是成百上千个，这么多yml难以管理，所以SpringCloud推出了该配置中心来管理这些yml<br>       运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息<br>       当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置，将配置信息以REST接口的形式暴露<br>          服务端配置（与GitHub连通）：<br>                1.GitHub建一个仓库 拿到config项目的SSH协议的git地址<br>                2.本地磁盘上新建个git仓库  并右键Git Bash Here输入git clone config项目的SSH协议的git地址<br>                3.在仓库的config项目文件夹里面新建application.yml文件，记住保存编码为UTF-8<br>                4.通过git指令(add commit push)将yml文件上传到GitHub仓库<br>                5.在config模块中导入pom依赖<br>                6.覆盖yml配置文件：cloud.config.server.git.url: GitHub上面的仓库名字  保持一致<br>                7.引导类上加@EnableConfigServer注解<br>          客户端配置：<br>                1.保存好客户端要用的yml文件，并传输到GitHub上<br>                2.创建客户端模块，添加pom依赖<br>                3.添加bootstrap.yml文件（优先级高）   127.0.0.1-&gt;config-3344.com 域名映射<br>               spring:<br>                  cloud:<br>                     config:<br>                       name: microservicecloud-config-client #需要从github上读取的资源名称，注意没有yml后缀名<br>                       profile: dev   #本次访问的配置项<br>                       label: master<br>                       uri: <a href="http://config-3344.com:3344" target="_blank" rel="noopener">http://config-3344.com:3344</a>  #本微服务启动后先去找3344号服务端，通过SpringCloudConfig获取GitHub的服务地址<br>               4.添加application.yml，放个名字就好<br>                   spring:<br>                        application:<br>                             name: microservicecloud-config-client<br>               5.添加带有@RestController注解的类  进行获取配置文件信息<br>               6.启动引导类</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2020/05/12/Vue/</url>
    <content><![CDATA[<h3 id="Vue整体概括"><a href="#Vue整体概括" class="headerlink" title="Vue整体概括"></a>Vue整体概括</h3><p>main.js主文件  进行App.vue这个根文件  进行渲染，同时可设置路由router</p>
<p>App.vue主界面入口  导入一些自己写的组件 同时可用router-view进行路由渲染 从而不在这里面放入太多的组件</p>
<p>index.js 路由文件  导入VueRouter 并Vue.use(VueRouter)使用  同时写上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"> 	routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>并在上面定义一个routes路由数组 在数组里配置各个路由映射</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    component: Home</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得导入组件，可以直接导入，也可以懒加载导入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = () =&gt; <span class="keyword">import</span>(<span class="string">'../views/home/Home'</span>)</span><br></pre></td></tr></table></figure>

<p>之后项目划分：</p>
<p>​    assets-&gt;css、img  放样式和图片<br>​            common-&gt;mixin.js、utils.js、const.js 放公用函数、常量文件<br>​            components-&gt;common、content  放可复用的组件，同时分为公用和业务所需<br>​            network-&gt;request.js、home.js、detail.js 放网络请求的文件 同时对axios进行一层封装为request<br>​                                          之后home.js等文件只需导入request，并传入url、params作为网络请求的config<br>​            router-&gt;index.js  配置路由 大体只配置主要的部分/home /category /cart /profile /detail/:iid<br>​            store-&gt;index.js、actions.js、mutations.js、getters.js  配置Vuex的五大组件 进行状态管理<br>​            views-&gt;home、category、cart、profile、detail  配置主要部分的视图 业务组件都在这里编写</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue零碎知识点</title>
    <url>/2020/05/12/Vue%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="Vue零碎知识点杂笔"><a href="#Vue零碎知识点杂笔" class="headerlink" title="Vue零碎知识点杂笔"></a>Vue零碎知识点杂笔</h3><p>webpack3的使用    webpack ./src/main.js  ./dist/bundle.js<br>        webpack4的使用    webpack ./src/main.js -o ./dist/bundle.js –mode development</p>
<p>但现在直接用Vue-cli4脚手架快速生成Vue项目</p>
<p>npm run build  ：会去package.json寻找script脚本属性里的build的指令执行  就可以执行项目本地的webpack指令</p>
<p>使用vue-cli2<br>           vue init webpack vueclitest（项目名）<br>        使用vue-cli3 4<br>           vue create vueclitest（项目名）</p>
<a id="more"></a>

<p>进入vue项目管理器：vue ui（可在终端直接使用）</p>
<p>添加vue.config.js这个文件可自定义配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">把一个函数作为参数传到另一个函数时使用箭头函数是最多的</span><br><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;  ===  setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)                        &#125;)	</span><br><span class="line">render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)  ===  render: <span class="function">(<span class="params">h</span>) =&gt;</span> &#123;</span><br><span class="line">                             <span class="keyword">return</span>  h(App)					                </span><br><span class="line">                          &#125;</span><br><span class="line">						  h是形参，调用的时候传入实参createElement来创建App组件</span><br></pre></td></tr></table></figure>

<p>$route指的是当前活跃的路由 负责路由映射<br>        $router  是代码跳转路由  等于App.vue注册的router组件  this.$router.push(‘/user/‘ + this.userId)</p>
<p>所有的组件都继承自Vue类的原型<br>        Vue.prototyoe.xxx  里面放了很多东西  例如$router</p>
<p>对路径起别名对import有效  在html元素中的src要加~</p>
<p>props父传子  $emit子传父</p>
<p>使用网络数据请求记得安装axios</p>
<p>default导出之后引入才可以不加大括号  不然就要import {xxx}  并且default导出的是唯一的  所以可以import 新名字 from…</p>
<p>ul&gt;li{分类列表$}*100  再按Tab快速生成一百行</p>
<p>在我们需要监听一个组件的原生事件时，必须给对应的事件加上.native修饰符才能进行监听</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;back-top @click.native=<span class="string">"backClick"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>this.$refs.aaa  即可拿到scroll这个组件 之后就可调用这个组件里的属性、方法 this.$refs.aaa.scrollTo(0,0)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;scroll ref=<span class="string">"aaa"</span>&gt; &lt;<span class="regexp">/scroll&gt;</span></span><br></pre></td></tr></table></figure>

<p>$bus 事件总线  用于联系两个不相关的组件传递一些事件,一开始的$bus是没有值的 记得去main.js去给他赋值</p>
<p>mixin.js  高级用法：混入   mixin.js里写的一些created() mounted()会和组件里相同的created() mounted()里的代码合并起来<br>       在Vue实例里添加属性mixins: [mixin.js导出的方法对象] 即可使用</p>
<p>$el是真正的dom元素，与document.getElementsby…一样</p>
<p>import {mapActions} from ‘vuex’<br>在methods里写 …mapActions([‘你要映射的方法名’]) 就可以直接this.方法名调用了</p>
<p>移动设备上的浏览器默认会在用户点击屏幕大约延迟300毫秒后才会触发点击事件<br>为了立即响应用户的点击事件，使用npm install fastclick –save</p>
<p>图片懒加载 npm install vue-lazyload –save</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img :src=<span class="string">"showImage"</span> &gt;换成 &lt;img v-lazy=<span class="string">"showImage"</span>&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>代码进阶之路</title>
    <url>/2020/05/12/%E4%BB%A3%E7%A0%81%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="对于自我职业规划的问题"><a href="#对于自我职业规划的问题" class="headerlink" title="对于自我职业规划的问题"></a>对于自我职业规划的问题</h3><p>许多人对于自己的一条完整的职业规划之路没有一个清晰的认知，但若你想从一个普通学生变成IT界、大厂里的大牛，往往需要经历什么才从能青铜走向王者呢？</p>
<h4 id="1-青铜——万恶之源"><a href="#1-青铜——万恶之源" class="headerlink" title="1.青铜——万恶之源"></a>1.青铜——万恶之源</h4><p>首先是《计算机基础》这本书，在计算机基础中我们会学到计算机的历史、计算机的特点、进制转换、内存管理、线性数据结构、网络请求协议等等。<br>计算机基础真心很重要，无比重要，究极重要，为啥我这么说呢，里面涉及的计算机知识还有很多网络协议的知识，大家以后一定会用到，我可以负责的告诉你，面试也一定会问，什么Http、Https、Tcp/Ip、三次握手、四次挥手面试不要太常问。<a id="more"></a><br>        Tip：这里有个小插曲就是我身边那个架构师团队Leader这周面试阿里p8岗位的时候，我以为问的都是什么源码，中间件的究极操作，我想大家跟我想的一样，但是大家错了，反而问的很多计算机的基础知识。我聊天大概问了一下面试内容，有什么求二叉树的镜像，内核态和用户态的理解，计算机的缓存页等。 大家是不是惊了，这他*不是我校招的题目么？怎么P8级别的大佬还问这个？其实很好理解，大家想一下到了一定的工作年限技术的广度深度都有一定的造诣了，你写代码就这样了没办法优化了，机器配置也是最好的了，那还能优化啥？<br>        底层！我们都知道所有语言到最后要运行都是变成机器语言的，最后归根究底都是要去跟机器交互的，那计算机的底层是不是最后还是要关注的东西了？<br>        学完计算机基础你基本上对计算机的整个知识体系都一知半解了，对于编程或许还是很懵懂，但是你现在已经要踏入编程的门了。 </p>
<h4 id="2-白银——编程第一课"><a href="#2-白银——编程第一课" class="headerlink" title="2.白银——编程第一课"></a>2.白银——编程第一课</h4><p>计算机基础学了，后面就要编程的入门课程了。想必看我这篇文章有99%的小伙伴都是以下面这段代码开始的自己的程序人生的吧：我还记得大一上开始学习的C语言，《C语言程序设计》课本，在第27页就是第一章，HelloWord，现在回忆起来还历历在目，老师在黑板上写下这两个庄严的单词，同桌的他和我露出无限的求知欲……<br>        我想所有的语言都是语法基础开始的，而且编程语言的基础语法也都是大同小异的。If、For、While等关键字，List、Set、Map等集合，Int、float、Double等基础类型，大家第一次学的时候我想也不会知道，这些关键字将会陪伴我们走完各自的程序生涯吧？<br>        接下去就难一点比如JDBC、IO、文件流啊什么的，依稀的记得当时还是代码里面写SQL然后查询，也不知道记错没有。<br>        学到这里，你可能觉得你JavaSE无敌，出去可以找工作了，反正当时的帅丙，觉得自己可以闯出一片天了，不知天高地厚，四处炫技。但是幼稚的我根本不知道，未知的前方还有什么等着我，我也不知道自己其实才刚入门，但是如果要往WEB方向发展，这些倒是基本足够了。但是你到现在为止学的东西都是服务端的东西呀，怎么让你的服务端东西展示给别人看呢？<br>        这个时候我们就应该去做个丑不拉几的页面，进行简单的交互了，你这个时候要学HTML 、Servlet、MySQL、 JavaScript、Tomcat、CSS等。目标呢就是写出第一个动态网站，也许只是个登陆功能，只能展示下个人资料，但这是很重要的一步，你要弄清楚的是，一个用户的点击产生的请求，是从哪里发起，哪里接收，哪里处理，哪里返回，你得理解浏览器和服务器的关系和分工，Cookie和Session，Request和Response。<br>        Tip：我记得我刚出来面试就有面试题是这样的，一个Http请求从网页发起到服务端产生数据返回中间经历了些什么，或者Spring做了什么？大家可以思考一下<br>         还有有一个自己的项目真心很重要，我就是在大学期间做了项目，至今在校园内网上稳定运行着，出来实习面试的时候基本上也是一路披荆斩棘，吊打了同行面试的仔，反正大学有个项目贼加分，是读者的大学生记住了么？</p>
<h4 id="3-黄金——初出茅庐"><a href="#3-黄金——初出茅庐" class="headerlink" title="3.黄金——初出茅庐"></a>3.黄金——初出茅庐</h4><p>上面的只是WEB开发的学习初级阶段，这都是些JAVA诞生以来最原始的最官方的WEB开发技术，当然现在真正的项目很少直接采用这些技术了，现在都是前后端分离了，Vue、Node.js、React等前端的语言更新迭代速度非常快，我学了一点刚用舒服，前端的朋友告诉我又迭代了……我他喵的不学了！<br>        为了不断提高技术的易用性、开发效率和可维护性、可扩展性，无数开源项目都是在这些原始技术的基础上封装、改进。<br>        所以这个阶段不要盲目乐观地跑去找工作或者对实习挑三拣四，你会被打击到的，又或者找个小公司浑浑噩噩几年过去感觉跟新的技术栈脱节。<br>        有人跟你说小公司学的东西多，他害你的，刚开始能去多大的去多大的，越大越好，你想你去了大的你想去小的分分钟的事情，但是你小的要去大的就相对难了。<br>        好，初始阶段完成，开始进入WEB开发的正题，首先是传说中的框架，SSM（Spring SpringMVC Mybatis）成为熟练的增删改查程序员是必须的，在这个阶段你还要理解为什么要用这仨而不是那些Jsp、Servlet、Jdbc，你要体会到写MVC、三层架构的好处。<br>        这个阶段不要轻易质疑框架的价值，也许刚开始你会觉得麻烦，觉得他们有时候是多此一举，我最开始这么写的时候发现，真的恶心，什么dao，service，Controller等等，分这么多干嘛。等过一两年后回过头来你会觉得少了这些框架你已经很难干活了，没有分层清晰的系统，你反而开口大骂项目的架构师的。不过要提醒大家的是，这个阶段还要避免的心态是，能熟练地增删改查了，就自认为写程序不过如此，然后往简历上填个精通，这也是新手面试被批得体无完肤的原因之一。<br>        浅尝即止，是新手的大忌，为啥这么写，这么写有啥好处，有啥坏处，多问几个为什么，你多年后会感谢敖丙的。<br>        如果你学得好，这会应该能熟练地写个博客啊，小论坛啊之类的WEB项目了，也就是达到了就业的基本要求。<br>        Tip：而且说一下作为一个应届生，你除了基础知识，如果你有自己的技术博客，还有像样的项目能展示给面试官看，是真的很加分，搭建个简单的项目，项目流程你也知道了，技术栈也熟悉了，还可以手机访问网页给面试官现场演示，很加分的。<br>        像我身边的朋友Java3y，JavaGuide，我没有三颗心脏等，就是在这个阶段就已经开始写了自己的博客，并且各自都做出了成绩，这些以后都是你面试的议价能力的一部分，也是你的加分项，和你自身的财富。我问了一下他们，都是靠博客就已经得到不少大公司的面试邀约了，反正有项目，有不错的履历，有不错的博客，都会给你加分，如果你什么都没有，现在动手去多学点，少打两局LOL等你到我这个年纪就会发现，索然无味。</p>
<h4 id="4-铂金——遵义会议"><a href="#4-铂金——遵义会议" class="headerlink" title="4.铂金——遵义会议"></a>4.铂金——遵义会议</h4><p>这会是程序员生涯的一个转折点，把握好了人生起飞，把握不好全盘皆输，所以我用具有重要转折点历史意义的遵义会议，作为这阶段的标题，我觉得，妙啊！<br>        慢慢的你会发现数据库性能实在不行，出于不甘现状，或者赶时髦，你该去了解NoSQL了，Memcached、Redis、Mongodb等非关系型数据库眼花缭乱，没关系，试着用用，能很好地缓解MySQL、Oracle之类关系数据库的压力。<br>        出于公司某些业务需要，你可能会钻研一个特定技术领域，比如全文搜索技术ElasticSearch（以下简称Es），那你了解了Es，你又要想到数据库的数据怎么同步进Es呢？<br>        你可能会接触到Logstash，Canal等中间件，然后发现可视化也是个问题，那Kibana就应运而生，用的时候发现欧洲人的分词习惯跟我们不一样，那Ik中文分词器又得了解啦。使用之后你还会发现他底层的Lucene有很多坑要怎避免，时间多你还可以了解Solr等等。<br>        总之知识就是一个体系，我经常跟群里的仔说，形成知识体系，你面试说了Es那相关的技术栈你一样要了解的，我题目取了叫《吊打面试官》就是噱头，你去面试如果面试官技术深度真的很深，我想被吊打的100%是你。<br>        你甚至会开始对系统中一些比较特殊的存在感兴趣，比如权限系统，单点登陆之类的，又或者某些特定业务领域的算法研究，这些是你的加分项。<br>        你还发现服务拆分后Http通信有诸多弊端，就开始接触优秀的Rpc框架还有消息队列中间件了，如Dubbo、RocketMQ等。<br>        再再后来你发现呀，数据量大得一批，表顶不住了，几亿数据查出来要好几秒，那分库分表就出来，什么水平拆分，垂直拆分，还学习了TDDL、Sharding-JDBC、DRDS等这样的分库分表中间件。但是你用了发现全局的唯一id生成又是一个问题，或许中间件有自带的，但是你还是要了解原理，什么雪花算法，uuid等等也得学。<br>        再再再后来呀，你发现分库分表也顶不住了，业务体量爆炸式增长了，你可能就需要了解动态分库分表的解决思路和解决方案了，特别是FaceBook开源的一些方案。<br>        再再再再后来呀，你发现动态分库分表也不行啊，很多离线的数据也很多啊，每天几个T，公司都要被败光了，那你就要了解大数据场景的离线分析啊，数据缓存啊，数据清洗，数据可视化等等啊什么的。那就需要学什么ODPS啊，Hadoop、Hive、Hbase等等中间件或者工具了。<br>        再再再再再后来你开始发现你的代码很乱，久了以后自己都看不懂，重复的，难以重用的代码堆积如山，不想维护，BUG百出。于是你要开始重视设计模式，合理地改造下自己的代码习惯，不再被僵化的SSH、MVC三层架构束缚住。<br>        再再再再再再…..<br>        到这里不知道你有没有体会到我每篇文章开头那句话的意思？就是工作之后发现自己越来越无知了，你再品一下下面这句话。<br>        你知道的越多，你不知道的越多<br>        Google和各种资料是你进步的动力，极少再遇到必须请教别人才能解决的问题，如果你这个阶段还老是问别人，你的技术生涯也就快到头了。<br>        这个阶段，如果你技术卓越和跟敖丙一样能吹，你的收入将是白领水平，至少接近了，或者大幅领先同龄人了。<br>        我觉得多数程序员在工作多年之后都能达到这个水平，有的人只需要一两年，有的人却要用上五六年，在这个阶段落伍的人，有的是出于天赋和思维所限，有的是出于对技术缺乏热情，有的是出于工作内容的制约。<br>等到年近中年，再也拼不过年轻人，被淘汰出局，只能在自嘲为屌丝和码农的无奈中黯然转行。<br>        这是个很重要的分水龄，你能不能继续进步，能不能在30岁以后继续从事技术工作，能不能在公司里独当一面，我觉得就看你能不能超越这个阶段了。<br>        很多烂公司里工作数年的项目经理，连这个层次都还没达到…<br>        为了30岁的自己听到裁员完全不虚，为了家里的老母亲不再为了省电费不舍得开灯，为了让自己……<br>        我想这个阶段你应该要做好准备，这也是我大篇幅介绍这个阶段的原因。</p>
<h4 id="5-钻石——扬帆起航"><a href="#5-钻石——扬帆起航" class="headerlink" title="5.钻石——扬帆起航"></a>5.钻石——扬帆起航</h4><p>你要读读优秀开源项目的源码，你要搞懂一些当年不懂的基础知识，你开始理解《thinking in java》的精髓，你能写一些底层的代码，有时还会觉得自己封装的比某些开源工具更好用更简单。<br>        当年看不懂的《深入分析JVM虚拟机》现在你已经可以对里面的知识点如数家珍，张口就来，并且能够将大量知识点带入到项目中优化，并且能够看到实质性的变化（暗示KPI）。<br>        WEB的难点和重点永远都在于性能、负载能力上，而现在网络的发达造成了数据量和操作密度的大大上升，硬件却没有相应的进步。<br>        你得试着更好地运用更多的服务器来协同工作，从WEB端到服务端到数据库，全都需要集群，需要分布式，需要合理的控制数据的流向，掌握好网站上下，一大堆机器的平衡，找出性能的瓶颈，找出稳定性和安全性的瓶颈，硬件出现故障，第三方技术出现错误，将被当成家常便饭融入到你的系统和代码里仔细考虑。你会开始觉得方案无比地重要，一将无能累死千军将不断应验，一个不好的设计，一个不好的方案，会让一群优秀的程序员工作成果大打折扣。<br>        你要关注架构知识，不能再满足于SSH三层架构到底。领域驱动设计，面向事件开发，敏捷开发等等一系列的思想在关键时刻能决定你项目的生死，这个阶段不再有标准范例让你照抄，你只知道思想和原理，实践却需要自己不断尝试和改进。<br>        多关注各种杂七杂八的开源技术，有些你可能前面已经接触过了，和通信有关的，和集成开发环境有关的，和架构有关的，各个领域你都应该能信口说上几个主流技术，虽然你可能只是听说过，了解。但关键时刻你得知道如何去选择技术，并快速掌握它。<br>        你还会去考虑尝试下别的语言，这里不是说转向什么C++ C#之类的，那和JAVA程序员不相干，我说的是一些运行于JVM之上的语言，比如scala和groovy，初识他们时你会觉得Java真的老了。<br>        但当你回到一个综合性的大型项目中，又会觉得Java积累下来的整个体系技术是如此完善，就像一个工业化标准一样，你可能发现光是Spring家族的东西你都受用终身，无法完全通读。你能把这个阶段实践好，胜任项目经理，乃至中小公司的技术总监，大厂的小团队Leader都是可以的</p>
<h4 id="6-大师——登峰造极"><a href="#6-大师——登峰造极" class="headerlink" title="6.大师——登峰造极"></a>6.大师——登峰造极</h4><p>其实写到上面这个阶段的时候我觉得，这是很多人满足的地方了，都是小公司技术总监了，那我图啥？<br>但是未知的人生还在那等着你呢，我问了身边顶级的大神，为啥要走出舒适区？去像字节跳动、阿里等这些压力大很多的地方呢？<br>        他们给的回答都不太一样，但是一样的就是挑战自我吧，谁也不知道哪里是自己的终点，那为啥不多做点尝试，新的环境，新的技术栈，新业务场景挑战新的自我。<br>        这个阶段你的一举一动可能都关系一个项目的生死存亡，一个错误或者正确的决策就可能改变整个项目的命运，水能载舟亦能覆舟，我想用在这里也恰到好处。<br>        我身边这样级别的大佬凤毛麟角，但不是没有，他们在公司都是核心人物，大型项目或者项目紧要关头都是他们带领团队冲冲冲，除了问题也是能最快给出解决思路和方案的。<br>        Tip：我现在的老大就是这样的人，双十一大家还手忙脚乱去追数据的时候，他上来一套操作，写了几个脚本就搞定了，卧槽我们当时周围一群人，从头到尾的知识盲区，结束了还没反应过来，只能拍手叫666。<br>        这就是强者的世界，我所向往的世界，当然我知道这样的世界，只有一步一个脚印才能涉足。</p>
<h4 id="7-王者——泰山之巅"><a href="#7-王者——泰山之巅" class="headerlink" title="7.王者——泰山之巅"></a>7.王者——泰山之巅</h4><p>最后王者其实我不会写任何内容，能到这个领域的人本身就是屈指可数了，敖丙身边有，但是我觉得大家自己体会吧，一般就是人脉，交际，能力都到了一定的高度了，这个阶段的事情我也体会不到。<br>        能想到的就只有先祖的诗句：指点江山，挥斥方遒。算是给大家留下无限遐想的空间吧，未来或许你就是你所在领域的王者也说不定的呢对吧。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>不知不觉写了这么多了，以上是我个人眼里的一般向JAVA 程序员的发展线路，限于篇辐也不全面，实际个人成长路线可能因为工作内容的不同差异会很大，有的人偏向了底层研究，有的人偏向了业务需求设计，有的带有浓重的行业色彩，而且技术之外，还有很多知识也很重要，做JAVA没有轻松的方向，但一个对技术抱有兴趣的人，走到这一步时，仍然会对开发抱有热情，想要写出好的项目。<br>        纯为了生计而工作的程序猿是走不到这一步的，这一行来都来了，大家一天都是24小时，为啥有差距，我想你我都明白的，知道为啥那就干出点名堂吧。</p>
<p>Just do it ！</p>
]]></content>
      <categories>
        <category>代码进阶分享</category>
      </categories>
  </entry>
  <entry>
    <title>跨域问题</title>
    <url>/2020/05/07/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="跨域问题的解决"><a href="#跨域问题的解决" class="headerlink" title="跨域问题的解决"></a>跨域问题的解决</h3><p>所谓同源是指,域名,协议,端口均相同,只要有一个不同,就是跨域 </p>
<p>而对于跨域问题的解决很简单，直接在后端创建一个config文件夹</p>
<p>并在里面放上CrosConfig.java文件，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.springboottest.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrosConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"GET"</span>, <span class="string">"HEAD"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>, <span class="string">"OPTIONS"</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>套用代码</category>
      </categories>
  </entry>
</search>
