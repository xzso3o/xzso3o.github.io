<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Eureka服务注册、集群实现</title>
    <url>/2020/12/21/Eureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E3%80%81%E9%9B%86%E7%BE%A4%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="Eureka服务注册、集群实现"><a href="#Eureka服务注册、集群实现" class="headerlink" title="Eureka服务注册、集群实现"></a>Eureka服务注册、集群实现</h3><h4 id="一、创建Eureka服务端"><a href="#一、创建Eureka服务端" class="headerlink" title="一、创建Eureka服务端"></a>一、创建Eureka服务端</h4><p>1.引入eureka服务端依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--eureka-server--&gt;</span><br><span class="line">    &lt;dependency&gt;    </span><br><span class="line">       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    </span><br><span class="line">       &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a> 

<p>2.编写yml文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span>     <span class="comment">#false表示不向注册中心注册自己。</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>     <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">    <span class="comment">#集群指向其它eureka</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka/</span></span><br><span class="line">    <span class="comment">#单机就是7001自己</span></span><br><span class="line"><span class="comment">#     defaultZone: http://eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure>

<p>3.添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br></pre></td></tr></table></figure>

<h4 id="二、创建Eureka客户端"><a href="#二、创建Eureka客户端" class="headerlink" title="二、创建Eureka客户端"></a>二、创建Eureka客户端</h4><p>1.引入eureka客户端依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--eureka-client--&gt;</span><br><span class="line">    &lt;dependency&gt;    </span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    </span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.编写yml文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span>            <span class="comment"># 当前数据源操作类型</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span>              <span class="comment"># mysql驱动包</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xzs666</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer默认为true。</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#单机版</span></span><br><span class="line"><span class="comment">#      defaultZone: http://localhost:7001/eureka</span></span><br><span class="line">      <span class="comment"># 集群版</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.xzs.springcloud.entities</span>    <span class="comment"># 所有Entity别名类所在包</span></span><br></pre></td></tr></table></figure>

<p>3.添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br></pre></td></tr></table></figure>

<h4 id="三、通过RestTemplate调用服务"><a href="#三、通过RestTemplate调用服务" class="headerlink" title="三、通过RestTemplate调用服务"></a>三、通过RestTemplate调用服务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span>  进行负载均衡的注解</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>Object、包装类</title>
    <url>/2021/01/19/Object%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>Java 类分三种：</p>
<p>1、JDK 提供的官方类库</p>
<p>2、第三方提供的类库（工具、框架）</p>
<p>3、开发自定义的类</p>
<p>Object 是 JDK 中的一个类，java.lang 包中，该类是所有类的直接父类或间接父类。</p>
<p>Java 程序中的每个类都是 Object 的后代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        hashCode();</span><br><span class="line">        getClass();</span><br><span class="line">        equals(<span class="keyword">null</span>);</span><br><span class="line">        clone();</span><br><span class="line">        toString();</span><br><span class="line">        notify();</span><br><span class="line">        notifyAll();</span><br><span class="line">        wait();</span><br><span class="line">        wait(<span class="number">100L</span>);</span><br><span class="line">        wait(<span class="number">100L</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="重写-Object-类的方法"><a href="#重写-Object-类的方法" class="headerlink" title="重写 Object 类的方法"></a>重写 Object 类的方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public String toString()</td>
<td>以字符串的形式返回对象的信息</td>
</tr>
<tr>
<td>public boolean equals(Object obj)</td>
<td>判断两个对象是否相等</td>
</tr>
<tr>
<td>public native int hashCode()</td>
<td>返回对象的hash值</td>
</tr>
</tbody></table>
<p><strong>== 比较的永远是变量的值</strong></p>
<p>变量的值就是变量中存储的数据</p>
<p>hashCode 方法用来获取对象的<strong>散列值</strong>，散列值是根据对象的内存地址和对象的信息映射出来的一个数值。</p>
<p>任何两个对象的内存地址肯定不一样，但是实际开发中如果两个对象的属性值完全一致，就认为是同一个对象，那么它们的散列值也是相等的。</p>
<p>eqauls 方法用来判断两个对象是否相等，hashCode 方法是返回对象的哈希值，实际开发中真正判断两个对象是否相等，需要结合 eqauls 和 hashCode 方法一同来判断。</p>
<p>为什么？为了提高效率。</p>
<p>判断两个对象是否相等</p>
<p>1、先判断两个对象的 hashCode 是否相等，如果不相等，则两个对象一定不是同一个对象，但是如果相等，则不能确定两个对象一定相等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2*6 &#x3D; 3*4</span><br></pre></td></tr></table></figure>

<p>2、再通过 equals 方法进行进一步的判断，最终得出两个对象是否相等的结论。</p>
<p>hashCode 执行效率高于 equals，优先使用 hashCode 进行判断，如果 hashCode 能确定结果，则不需要执行效率低的 equals，除非 hashCode 无法确定结果，不得不执行 equals 的时候再去执行 equals 得出结果。</p>
<p>表达式1 &amp; 表达式2 两个表达式都要执行</p>
<p>表达式1 &amp;&amp; 表达式2 表达式1 = false，表达式2 就不需要执行了，从而提升效率</p>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>包装类是 Java 提供的一组类，专门用来创建基本数据类型对应的对象，一共有 8 个，都保存在 java.lang 包中。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>包装类的体系结构</p>
<p><img src="/2021/01/19/Object%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB/1.png" alt="1611038838235"></p>
<h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>装箱：基本数据类型 —&gt; 包装类</p>
<p>public Type(type value) </p>
<p>public Type(String value)</p>
<p>以上两个方法不推荐使用</p>
<p>public static valueOf(type value) 静态工厂方法</p>
<p>静态工厂方法是专门用来创建对象的一个静态方法，功能上与构造器一样，都是用来创建对象的。</p>
<p>获取一个类的实例化对象，有两条路可以选择</p>
<p>1、构造器</p>
<p>2、静态工厂方法</p>
<p>区别：</p>
<p>1、静态工厂方法可以有自定义的名字。</p>
<p>2、静态工厂方法在需要的情况下可以保证单例模式。</p>
<p>拆箱：包装类 —&gt; 基本数据类型</p>
<p>*Value()</p>
<p>parse*(String value)</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>GateWay网关</title>
    <url>/2020/12/21/GateWay%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<h3 id="GateWay网关"><a href="#GateWay网关" class="headerlink" title="GateWay网关"></a>GateWay网关</h3><p>核心逻辑：路由转发+执行过滤器链</p>
<p>三大核心概念：路由、断言、过滤</p>
<p>1.引入POM依赖</p>
<p>GateWay不需要引入web、actuator这两个依赖，本身自己带有</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--gateway--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!--eureka-client--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a> 

<p>2.建立YML文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">            <span class="comment">#- After=2020-02-21T15:51:37.485+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="comment">#- Cookie=username,zzyy</span></span><br><span class="line">            <span class="comment">#- Header=X-Request-Id, \d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式</span></span><br></pre></td></tr></table></figure>

<p>运行过程：寻找路由里uri提供的服务地址，然后前往predicates断言下的服务地址路径，相匹配的则需要通过访问9527网关端口才可访问服务。同时可添加许多断言规则，具体搜官网</p>
<p><img src="/2020/12/21/GateWay%E7%BD%91%E5%85%B3/2.png" alt="01"></p>
<p><img src="/2020/12/21/GateWay%E7%BD%91%E5%85%B3/1.png" alt="01"></p>
<p>同时还可通过编码方式进行配置路由映射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GateWayConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder routeLocatorBuilder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();</span><br><span class="line"></span><br><span class="line">        routes.route(<span class="string">"path_route_xzs"</span>,</span><br><span class="line">                r -&gt; r.path(<span class="string">"/guonei"</span>)</span><br><span class="line">                        .uri(<span class="string">"http://news.baidu.com/guonei"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上为配置了一个叫path_route_xzs的路由，当访问localhost:9527/guonei，则跳转到<a href="http://news.baidu.com/guonei" target="_blank" rel="noopener">http://news.baidu.com/guonei</a></p>
<p>3.路由过滤</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogGateWayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>,<span class="title">Ordered</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        log.info(<span class="string">"***********come in MyLogGateWayFilter:  "</span>+<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">"uname"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(uname == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            log.info(<span class="string">"*******用户名为null，非法用户，o(╥﹏╥)o"</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即实现两个接口GlobalFilter,Ordered，直接进行过滤规则编写。以上为访问时需带上一个uname值才可访问</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>JVM初步认识</title>
    <url>/2021/01/18/JVM%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<h1 id="1-JVM-指令"><a href="#1-JVM-指令" class="headerlink" title="1.JVM 指令"></a>1.JVM 指令</h1><p>class 文件中的程序的执行逻辑，java 文件中编写程序的逻辑，</p>
<p>JVM 对 class 文件的具体执行方式</p>
<p>1、写 Java 代码</p>
<p>2、编译成 class 字节码文件（16 进制，程序员根本看不懂）</p>
<p>3、对 class 字节码进行<strong>反汇编</strong>，成为程序员能看懂的 JVM 指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javap -c Test.java</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">"Test.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0                           <span class="comment">// 栈帧</span></span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>                            <span class="comment">// 结束</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">10</span>                  <span class="comment">//压栈</span></span><br><span class="line">       <span class="number">2</span>: istore_1                          <span class="comment">//把栈顶元素取出来赋给局部变量表第1个元素</span></span><br><span class="line">       <span class="number">3</span>: bipush        <span class="number">20</span>                  <span class="comment">//压栈</span></span><br><span class="line">       <span class="number">5</span>: istore_2                          <span class="comment">//把栈顶元素取出来赋给局部变量表第2个元素</span></span><br><span class="line">       <span class="number">6</span>: iload_1                           <span class="comment">//取出局部变量表第1个元素</span></span><br><span class="line">       <span class="number">7</span>: iload_2                           <span class="comment">//取出局部变量表第2个元素</span></span><br><span class="line">       <span class="number">8</span>: iadd                              <span class="comment">//进行相加操作，压栈</span></span><br><span class="line">       <span class="number">9</span>: istore_3                          <span class="comment">//把栈顶元素取出来赋给局部变量表第3个元素</span></span><br><span class="line">      10: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;  获取out静态实例</span><br><span class="line">      <span class="number">13</span>: iload_3                           <span class="comment">//取出局部变量表第3个元素</span></span><br><span class="line">      14: invokevirtual #13                 // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">17</span>: <span class="keyword">return</span>                            <span class="comment">// 结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-JVM-内存模型"><a href="#2-JVM-内存模型" class="headerlink" title="2.JVM 内存模型"></a>2.JVM 内存模型</h1><p>JVM 可以分为 5 个部分</p>
<p>1、类加载器 Class Loader</p>
<p>2、<strong>运行时数据区 Runtime Data Area</strong></p>
<pre><code>- 方法区
- 虚拟机栈
- 本地方法栈
- 堆
- 程序计数器</code></pre><p>3、执行引擎 Execution Engine</p>
<p>4、本地库接口 Native Interface</p>
<p>5、本地方法库 Native Libraries</p>
<p><img src="/2021/01/18/JVM%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/1.png" alt="1603379698128"></p>
<p>运行时数据区：</p>
<p>1、方法区</p>
<p><strong>存储 JVM 加载的类信息，常量、静态变量。</strong></p>
<p>方法区是一种规范，永久代是方法区的一种实现。</p>
<p>面试题：JDK 7 之前的版本字符串常量池存放在永久代中的，JDK 7 将字符串常量池移动到了堆中，JDK 8 直接删除了永久代，改用<strong>元空间</strong>替代永久代。</p>
<p>2、本地方法栈</p>
<p>用来执行本地方法的</p>
<p>什么是 Java 的本地 native 方法？</p>
<p><strong>Java 是基于应用层的高级编程语言，无法访问操作系统底层信息。</strong></p>
<p><strong>就需要使用其他可以访问底层的编程语言来完成功能 C++，再通过 Java 来调用就可以实现需求。</strong></p>
<p>本地方法的使用原理：</p>
<p>1、在 Java 程序中声明 native 修饰的方法，只有方法定义，没有方法实现，将 Java 文件编译成字节码文件。</p>
<p>2、用 <strong>javah</strong> 编译字节码文件，生成一个后缀为 <strong>.h</strong> 的文件。</p>
<p>3、写一个 .cpp 文件实现 .h 文件中的方法。</p>
<p>4、将 .cpp 文件编译成<strong>动态链接库文件 .dll</strong>。</p>
<p>5、使用 System.loadLibrary() 加载动态链接库，从而实现本地的调用。</p>
<p>利用了<strong>反射机制</strong>，运行时找到 .dll 文件并解析，根据动态链接库中的文件名创建对象和方法，从而实现通过对象调用方法的过程。</p>
<p>常见的本地方法：</p>
<p>getClass、hashCode、clone 都是 Object 类中的方法。</p>
<p>3、程序计数器</p>
<p>占用内存空间较小，是<strong>当前线程所执行的字节码行号指示器</strong>（记录当前线程执行到哪了），多个线程之间的程序计数器是相互独立的，互不影响，为了保证每个线程恢复后都可以找到具体的执行位置。</p>
<p>（例：并发执行时，一个程序员一会写这台电脑代码，一会写另一台电脑代码，间断执行，停下写一台电脑代码时，靠程序计数器记下这个执行位置，等到又要写这台电脑代码时则可从该位置继续写代码）</p>
<p>4、Java 堆</p>
<p>Java 堆用来<strong>存储实例化对象</strong>的，Java 中所有的对象一定都是存储在堆中的，Java 堆<strong>被所有的线程共享</strong>，<strong>在虚拟机启动时创建的，用来存储对象的实例</strong>，是 Java 内存结构中的占比最大的一块区域，也是 GC 垃圾回收机制主要管理的区域，又可以分为年轻代、老年代。</p>
<blockquote>
<p>年轻代</p>
</blockquote>
<p>又分为 Eden（伊甸园），Survivor（存活）：Survivor From、Survivor To</p>
<p>Eden：对象刚被创建的时候，存放在 Eden 区，如果 Eden 区放不下，则放入 Survivor 中，甚至于放入到老年代中。</p>
<p>Survivor：Survivor 又可以分为 Survivor From  和 Survivor To，GC 回收时使用，将 Eden 中存活对象放入 Survivor From 中，下一次回收时，将 Survivor From 中存活的对象转移到 Survivor To 中，清除剩下的对象，下一次回收时，将 Survivor To 中存活的对象转移到 Survivor From 中，清除剩下的对象，下一次回收时，继续重复上述步骤…</p>
<p><img src="/2021/01/18/JVM%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/2.png" alt="1603639162176"></p>
<blockquote>
<p>老年代</p>
</blockquote>
<p>存放生命周期较长的对象，经过多次 GC 之后还没有被回收的，或者引用次数很多、或者引用链比较长的对象，都是存放在老年代中。</p>
<blockquote>
<p>元空间（元数据空间）MetaSpace</p>
</blockquote>
<p>JDK 8 之后开始将类的数据存放在堆内存中，这块区域叫做元空间，JDK 7 以前，元空间时放在永久代中的，JDK 8 之后永久代被删除了，元空间就独立出来了。</p>
<p>元空间和永久代是方法区的实现，方法区只是一种规范，永久代使用 JVM 内存，空间有限，元空间使用的是本地内存，使得程序的内存不再受限于 JVM 内存，本地内存有多少可以用，理论上元空间就有多大，解决了内存空间不足的问题。</p>
<p>5、虚拟机栈</p>
<p>Java 方法执行的内存模型，Java 栈中存放最多的是栈帧，每个栈帧对应一个被调用的方法，栈帧中包括：局部变量表、操作数栈、运算符栈、动态链接、方法的返回地址（方法出口）。</p>
<p>每一个方法的执行，JVM 都会创建一个栈帧，并且将该栈帧压入 Java 栈，方法执行完毕，该栈帧出栈。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;成员变量&#x2F;类变量</span><br><span class="line">int m &#x3D; 10;</span><br><span class="line"></span><br><span class="line">public void test(int a)&#123;</span><br><span class="line">	&#x2F;&#x2F;局部变量</span><br><span class="line">	int i &#x3D; 10;</span><br><span class="line">	int j &#x3D; 20;</span><br><span class="line">	int k &#x3D; i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void test2()&#123;</span><br><span class="line">	int k &#x3D; 100;</span><br><span class="line">	k &#x3D; k+1;</span><br><span class="line">	test();</span><br><span class="line">	m &#x3D; 11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/18/JVM%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/3.png" alt="1603639178292"></p>
<p>局部变量表：存储方法执行过程中的所有变量，包括方法中声明的局部变量和形参。</p>
<p>操作数栈：方法中的计算过程都是借助于操作数栈来完成的，将参与计算的数据压入到操作数栈中。</p>
<p>运算符栈：方法运算过程中用到的运算符，全部压入到运算符栈中。</p>
<p>方法返回地址：一个方法调用结束之后要返回到调用它的地方，所以栈帧中要保存能够返回到方法调用处的地址。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Ribbon服务调用</title>
    <url>/2020/12/21/Ribbon%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Ribbon服务调用"><a href="#Ribbon服务调用" class="headerlink" title="Ribbon服务调用"></a>Ribbon服务调用</h3><p>一句话，主要是通过RestTemplate+负载均衡实现</p>
<p>更换负载均衡算法：在com.xzs下添加一个myrule的包，同时创建一个rule类修改负载均衡算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();<span class="comment">//定义为随机算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时需要在启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>,configuration= MySelfRule<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>Java介绍</title>
    <url>/2021/01/18/Java%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="1-Java版本"><a href="#1-Java版本" class="headerlink" title="1.Java版本"></a>1.Java版本</h1><p>Java每隔半年会发布一个新版本，每第四个版本为稳定版本</p>
<p>稳定版 8、12、16</p>
<p>所以我们大部分使用Java8，十分稳定的版本</p>
<p>为什么要配环境变量？</p>
<p>让操作系统能够识别命令，java 可以</p>
<ul>
<li>1、在指定的路径下(C:\Program Files (x86)\Common Files\Oracle\Java\javapath)找可执行文件 java.exe</li>
<li>2、通过系统的环境变量来找到可执行文件</li>
</ul>
<p>第 1 种方式的优先级要高于第 2 种</p>
<p>Java 开发分为 3 个步骤：</p>
<ul>
<li>1、编写 Java 程序，在后缀为 .java 的文件中写代码，这个文件叫做 Java 源文件</li>
<li>2、通过 JVM 编译器将源文件编译为字节码文件，后缀 .class。记住这个是<strong>16 进制</strong>的</li>
<li>3、JVM 对字节码文件进行解释，翻译成操作系统能够识别的机器码（<strong>2 进 制</strong>），进而运行程序。</li>
</ul>
<p>Java 最大的特点就是它的跨平台特性，一次编写，多次运行（运行在不同 的操作系统中）</p>
<p>Windows、Mac、Linux </p>
<a id="more"></a>

<h1 id="2-Java体系"><a href="#2-Java体系" class="headerlink" title="2.Java体系"></a>2.Java体系</h1><p>Java SE、Java EE、Java ME</p>
<p><img src="/2021/01/18/Java%E4%BB%8B%E7%BB%8D/1.png" alt="1610973844232"></p>
<p>Java SE 定义了 Java 的<strong>核心类库</strong>，包含了各种常用的组件，是 Java 开发的 基础。</p>
<p>Java ME 是基于 Java SE 专用于<strong>移动端设备开发</strong>的一套组件，如手机、机顶 盒、车载导航。</p>
<p>Java EE Java Enterprise Edition 是基于 Java SE 扩展出的一套<strong>企业级开发组件</strong>，Java WEB 又是其中最主流、需求量最大的一套组件，包括 Servlet、JSP，是目前 Java 开发的主流方向。</p>
<h1 id="3-JDK"><a href="#3-JDK" class="headerlink" title="3.JDK"></a>3.JDK</h1><p>JRE   JDK</p>
<p>JRE (Java Runtime Environment Java) <strong>运行环境</strong>，包括 JVM 和 Java 基础类 库，一台电脑要运行 Java 程序，就必须安装 JRE，部署项目的服务器中需 要安装 JRE。</p>
<p>JDK Java Development Kit Java <strong>开发工具包</strong>，包括了 JRE 和编译 Java 源文 件的编译器，如果要在一台电脑上开发 Java 程序，就必须安装 JDK。</p>
<ul>
<li>1、编译程序的命令是 javac Test.java</li>
<li>2、运行程序的命令是 java Test</li>
<li>3、Java 对大小写敏感，编写时需要注意</li>
<li>4、文件名一定和类名一致</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>HashMap底层数据结构</title>
    <url>/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="HashMap-的底层数据结构"><a href="#HashMap-的底层数据结构" class="headerlink" title="HashMap 的底层数据结构"></a>HashMap 的底层数据结构</h1><p>HashMap 底层是数组，称为哈希桶，JDK7 和 JDK8 版本的变动是比较大的。</p>
<p>存储结构：JDK7 是<strong>数组+链表</strong>，JDK8 是<strong>数组+链表+红黑树</strong>。</p>
<p><strong>本质就是为了存数据，改进是为了查询效率越来越高</strong></p>
<p><strong>为什么要使用数组+链表的形式？</strong></p>
<p>HashMap 底层数组的默认大小是 16，最大索引是 15，数组是可以<strong>扩容</strong>的。</p>
<p>HashMap 以 key-value 的形式进行存储，key+value 会以一个 Entry 对象的形式来存储，把 Entry 存入数组中，具体存入的下标不是按顺序存入，而是通过 key 获取对应的 hash 值，再根据 <strong>hash 值与数组最大索引进行按位与运算</strong>（将操作数转换为二进制，分别对比各位上的值，都为 1 则该位返回 1，否则返回 0，得到的结果就是按位与运算结果）</p>
<p>与数组最大索引进行按位与运算是为了保证数组下标不越界</p>
<p>A &amp; B 结果一定是小于等于 B</p>
<p>很有可能出现两个 Entry 下标一样，hash 冲突，我们应该尽量避免，如果一旦一样怎么处理？意味着需要将两个 Entry 存入数组中的同一个位置，所以就形成了链表。</p>
<p>数组中存储的是第一个 Entry 的地址，第二个 Entry 就往后排。</p>
<p><img src="/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.png" alt="1611106695027"></p>
<a id="more"></a>

<p><strong>为什么要使用红黑树呢？</strong></p>
<p>链表的缺点是查询效率低，因为查询链表中的任意一个元素，都需要从头开始遍历。</p>
<p>这种方式会导致 HashMap 取数据很慢，而取数据又是 HashMap 最常用的一个操作，所以 JDK 8 引入了红黑树来解决这个问题。</p>
<p>红黑树可以解决链表查询效率低的问题</p>
<p>红黑树是一种数据结构，其实是一个<strong>平衡二叉树</strong>，二叉树的查询效率很高。</p>
<blockquote>
<p>什么是二叉排序树？</p>
</blockquote>
<p>1、左子树上所有节点的值都小于等于它的根节点的值。</p>
<p>2、右子树上所有节点的值都大于等于它的根节点的值。</p>
<p>3、左、右子树分别为一个新的二叉排序树。</p>
<p><img src="/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.png" alt="1611106717976"></p>
<p>二叉排序树相比较于链表，查询效率很高出很多，所以选择使用二叉排序树来替代链表，但是纯二叉排序树有个缺点，有可能出现不平衡的二叉排序树，查询效率不会比链表高出多少。</p>
<p>所以二叉排序树必须要保证一定是一个平衡二叉树，因为不平衡二叉树其实和链表差不多。</p>
<p><img src="/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.png" alt="1611106741891"></p>
<p><strong>如何让二叉排序树保持平衡？</strong>这就是红黑树的作用。</p>
<p>1、节点是红色或者黑色。</p>
<p>2、根节点是黑色。</p>
<p>3、每个叶子节点都是黑色的空节点。</p>
<p>4、每个红色节点的两个子节点都是黑色（从每个叶子节点到根的路径上不能有两连续的红色节点）</p>
<p>5、从任一节点到它每个叶子节点的路径所包含的黑色节点的数目一致。</p>
<p><img src="/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.png" alt="1611106758744"></p>
<blockquote>
<p>HashMap 构造函数</p>
</blockquote>
<p><img src="/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.png" alt="1611106769184"></p>
<p>构造器中没有创建数组，HashMap 的数组是按需创建，<strong>只有在添加数据调用put的时候才会创建这个数组</strong>，如果不添加数据，则不会创建数组，避免空间浪费。</p>
<p><img src="/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.png" alt="1611110571610"></p>
<blockquote>
<p>HashMap 有两个重要的参数：容量（capacity）和负载因子（loadFactor）</p>
</blockquote>
<ul>
<li>容量：是指 HashMap 中桶的数量，默认值是 16</li>
<li>负载因子：判断 HashMap 是否需要扩容，默认值是 0.75</li>
</ul>
<p>HashMap 存放的元素总数量 / 容量，当该值等于 0.75 的时候，HashMap 就需要进行扩容</p>
<p>16*0.75 = 12</p>
<p>当 HashMap 中元素个数超过 12 的时候，数组就需要进行扩容，成倍扩容 32</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;初始默认值</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line">&#x2F;&#x2F;数组最大容量</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">&#x2F;&#x2F;默认加载因子</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">&#x2F;&#x2F;判断链表是否要转为红黑树，链表长度&gt;&#x3D;8就转换为红黑树了</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">&#x2F;&#x2F;判断红黑树是否转为链表，红黑树的深度&lt;&#x3D;6就转换为链表了</span><br><span class="line">static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">&#x2F;&#x2F;用来判断到底是链表转红黑树还是数组扩容，数组小于64只会发生扩容，不会进行转红黑树</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.png" alt="1611106782856"></p>
<p>当 key = null 直接返回 0，否则返回 key 的 hashCode 值与自己的高 16 位进行异或运算，</p>
<p>h &gt;&gt;&gt; 16 是用来取出 h 的高 16 位，&gt;&gt;&gt; 无符号右移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000 0100 1011 0011 1101 1111 1110 0001</span><br><span class="line">&gt;&gt;&gt; 16</span><br><span class="line">0000 0000 0000 0000 0000 0100 1011 0011</span><br></pre></td></tr></table></figure>

<p>因为 int 的取值范围是 -21 亿到 21 亿，40 亿种可能，长度为 40 亿的数组内存肯定是存不下的，HashMap 默认长度是 16。</p>
<p>所以需要跟自己的高 16 位进行异或运算（相同为 0，不同为 1），这样可以混合原始 hash 码的高位和低位，以此来加大低位的随机性，而且混合之后的低位同样会包含高位的信息，所以高位信息也被保留下来，散列分别更均匀，冲突的概率更小。</p>
<p>可能性太多，内存无法承载，所以需要想办法降低可能性，降低的同时还要保证其随机性，冲突概率更小，所以采用的是跟自己高 16 按位异或的做法。</p>
<p>拿到 key 的 hash 值之后，还要跟数组最大索引进行按位与运算（都为 1 返回 1，否则返回 0），最终的值才是正在的数组下标。</p>
<p>具体步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h&#x3D;hashCode:1111 1111 1111 1111 1111 0000 1110 1010</span><br><span class="line">h&gt;&gt;&gt;16:    0000 0000 0000 0000 1111 1111 1111 1111</span><br><span class="line"></span><br><span class="line">^:		   1111	1111 1111 1111 0000 1111 0001 0101</span><br><span class="line">15:		   0000	0000 0000 0000 0000 0000 0000 1111</span><br><span class="line"></span><br><span class="line">&amp;		   0000 0000 0000 0000 0000 0000 0000 0101</span><br></pre></td></tr></table></figure>

<p>得出下标index = 5</p>
<p>接下来看看putVal源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//创建一个Node数组（哈希桶）</span></span><br><span class="line">    	<span class="comment">//创建一个Node节点p，两个int变量 n，i</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    	<span class="comment">//判断数组是否为空，如果为空就创建数组</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//resize是创建数组和数组扩容的方法，默认创建长度为16的数组</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    		<span class="comment">//计算索引（数组最大索引&amp;hash），取出数组元素，判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果为null，直接创建Node存入</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//如果不为null，判断key是否相同</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//如果相同，则将已经存在的p赋给e</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//如果key不相同，需要在原Node基础上添加新的Node，这就形成了链表</span></span><br><span class="line">            <span class="comment">//判断该位置是链表还是红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//如果是红黑树，将Node存入红黑树</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是链表，就遍历链表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//遍历到最后一位</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//将Node存入</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//判断链表长度是否超过8</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st									    //将链表转为红黑树</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果链表中存在重复的key，则进行替换</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里的e是相同的值</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="comment">//将e的value记录下来</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="comment">//将被替换的值返回</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//哈希映射被修改的次数++</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            <span class="comment">//threshold=capacity*loadfactor=16*0.75=12</span></span><br><span class="line">            resize();<span class="comment">//数组扩容</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">    	<span class="comment">//如果key不重复，返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 底层是单向链表，只需要记录 next。</p>
<p>双向链表，每一个节点都会记录它的上一个节点和下一个节点。</p>
<p>转红黑树的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>如果数组的长度小于64，则不进行红黑树的转换，而是继续进行数组扩容，如果数组的长度大于64，再将链表转为红黑树。</p>
<p><strong>HashMap 存值总体过程：</strong></p>
<p>1、根据key计算hash值。</p>
<p>2、在put的时候判断数组是否存在，如果不存在则用 resize 方法创建默认长度为16的数组。</p>
<p>3、确定要存入的 Node 在数组中的位置，根据 hash 值与数组最大索引进行按位与运算得到索引位置。</p>
<p>4、判断该位置是否有元素，如果没有直接创建一个 Node 存入。</p>
<p>5、如果有元素，判断 key 是否相同，如果相同则覆盖，并且将原来的值直接返回。</p>
<p>6、如果 key 不相同，在原 Node 基础上添加新的 Node，判断该位置是链表还是红黑树。</p>
<p>7、如果是红黑树，将 Node 存入红黑树。</p>
<p>8、如果是链表，遍历链表，找到最后一位，将 Node 存入。</p>
<p>9、将 Node 存入链表之后，判断链表的结构是否要调整，判断链表长度是否超过 8，如果超过 8 需要将链表转为红黑树，这里还有一个条件，如果数组的容量小于 64，不转换红黑树，而是进行数组扩容，当数组的容量大于 64 的时候，再将链表转为红黑树。</p>
<p>10、存完之后，再次判断数组是否进行扩容，根据负载因子来判断。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Hystrix服务降级、熔断、限流</title>
    <url>/2020/12/21/Hystrix%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E3%80%81%E7%86%94%E6%96%AD%E3%80%81%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><h4 id="一、主要三大概念"><a href="#一、主要三大概念" class="headerlink" title="一、主要三大概念"></a>一、主要三大概念</h4><p><img src="/2020/12/21/Hystrix%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E3%80%81%E7%86%94%E6%96%AD%E3%80%81%E9%99%90%E6%B5%81/1.png" alt="01"></p>
<h4 id="二、服务降级"><a href="#二、服务降级" class="headerlink" title="二、服务降级"></a>二、服务降级</h4><p>1.导入一些依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--hystrix--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line"> 	  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;		</span><br><span class="line">   &lt;!--openfeign--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line"> 	  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;!--eureka client--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line"> 	  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.消费端yml文件多添加一项</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>3.添加注解</p>
<p>消费端添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br></pre></td></tr></table></figure>

<p>服务端添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br></pre></td></tr></table></figure>

<p>4.消费端通过openFeign远程调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PROVIDER-HYSTRIX-PAYMENT"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentHystrixService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/payment/hystrix/ok/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/payment/hystrix/timeout/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.服务端通过注解和兜底方法进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentInfo_TimeOutHandler"</span>,commandProperties = &#123;</span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name=<span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value=<span class="string">"5000"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//int age = 10/0;</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">3000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"线程池:  "</span>+Thread.currentThread().getName()+<span class="string">" id:  "</span>+id+<span class="string">"\t"</span>+<span class="string">"O(∩_∩)O哈哈~"</span>+<span class="string">"  耗时(秒): "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOutHandler</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"线程池:  "</span>+Thread.currentThread().getName()+<span class="string">"  8001系统繁忙或者运行报错，请稍后再试,id:  "</span>+id+<span class="string">"\t"</span>+<span class="string">"o(╥﹏╥)o"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>@HystrixCommand(fallbackMethod = “paymentInfo_TimeOutHandler”,设置了paymentInfo_TimeOutHandler这个兜底方法，一旦服务发生异常或超时，则跳入到该兜底方法</p>
<p>，commandProperties = {<br>            @HystrixProperty(name=”execution.isolation.thread.timeoutInMilliseconds”,value=”5000”)<br>        }  设置了允许超时的秒数</p>
<p>6.消费端通过注解和兜底方法进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/hystrix/timeout/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentTimeOutFallbackMethod"</span>,commandProperties = &#123;</span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name=<span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value=<span class="string">"1500"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        String result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeOutFallbackMethod</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>7.但都得写个兜底方法，导致代码膨胀。因此还可使用全局服务降级fallback</p>
<p>先定义全局兜底方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">payment_Global_FallbackMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再在类上加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DefaultProperties</span>(defaultFallback = <span class="string">"payment_Global_FallbackMethod"</span>)</span><br></pre></td></tr></table></figure>

<p>同时方法上只是@HystrixCommand注解，而不需要指名兜底方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="comment">//@HystrixCommand(fallbackMethod = "paymentTimeOutFallbackMethod",commandProperties = &#123;</span></span><br><span class="line">           <span class="comment">//@HystrixProperty(name="execution.isolation.thread.timeoutInMilliseconds",value="1500")</span></span><br><span class="line"><span class="comment">//   &#125;)</span></span><br></pre></td></tr></table></figure>

<p>8.设置更全面的通用服务降级类，实现需要进行服务降级的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentHystrixService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-----PaymentFallbackService fall back-paymentInfo_OK ,o(╥﹏╥)o"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-----PaymentFallbackService fall back-paymentInfo_TimeOut ,o(╥﹏╥)o"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PROVIDER-HYSTRIX-PAYMENT"</span> ,fallback = PaymentFallbackService<span class="class">.<span class="keyword">class</span>)<span class="title">public</span> <span class="title">interface</span> <span class="title">PaymentHystrixService</span></span></span><br></pre></td></tr></table></figure>

<p>注解添加fallback属性指向了PaymentFallbackService这个服务降级类</p>
<h4 id="三、服务熔断"><a href="#三、服务熔断" class="headerlink" title="三、服务熔断"></a>三、服务熔断</h4><p>当一些服务调用失败达到一个阙值时，会对服务进行熔断。当检测到该服务正常时，能够恢复调用链路。</p>
<p>熔断机制注解是@HystrixCommand</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentCircuitBreaker_fallback"</span>,commandProperties = &#123;</span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.enabled"</span>,value = <span class="string">"true"</span>),<span class="comment">// 是否开启断路器</span></span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.requestVolumeThreshold"</span>,value = <span class="string">"10"</span>),<span class="comment">// 请求次数</span></span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.sleepWindowInMilliseconds"</span>,value = <span class="string">"10000"</span>), <span class="comment">// 时间窗口期</span></span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.errorThresholdPercentage"</span>,value = <span class="string">"60"</span>),<span class="comment">// 失败率达到多少后跳闸</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>表示在十秒钟之内发送十次请求，如果失败率达到60%以上就跳闸</p>
<p><img src="/2020/12/21/Hystrix%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E3%80%81%E7%86%94%E6%96%AD%E3%80%81%E9%99%90%E6%B5%81/2.png" alt="01"></p>
<p>熔断时候直接调用fallbackMethod</p>
<h4 id="四、服务限流"><a href="#四、服务限流" class="headerlink" title="四、服务限流"></a>四、服务限流</h4><h4 id="五、Hystrix-Dashboard服务监控"><a href="#五、Hystrix-Dashboard服务监控" class="headerlink" title="五、Hystrix Dashboard服务监控"></a>五、Hystrix Dashboard服务监控</h4><p>1.添加依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> 其中需要监控的服务都要加上这个actuator依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.主启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br></pre></td></tr></table></figure>

<p>3.在可视化页面上填写监控地址<a href="http://localhost:8001/hystrix.stream即可进行监控" target="_blank" rel="noopener">http://localhost:8001/hystrix.stream即可进行监控</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>IO流</title>
    <url>/2021/01/20/IO%E6%B5%81/</url>
    <content><![CDATA[<h1 id="IO-流（输入输出流）"><a href="#IO-流（输入输出流）" class="headerlink" title="IO 流（输入输出流）"></a>IO 流（输入输出流）</h1><p>使用 Java 程序完成输入输出操作，输入 Input，输出 Output</p>
<p>输入是指将文件以数据流的形式读取到 Java 程序中</p>
<p>输出是指通过 Java 程序将数据流写入到文件中</p>
<h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><p>java.lang.File</p>
<p>常用方法</p>
<p>注：目录是指文件夹，文件是指图片、txt、word等等</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public File(String pathname)</td>
<td>根据路径创建文件对象</td>
</tr>
<tr>
<td>public String getName()</td>
<td>获取文件名</td>
</tr>
<tr>
<td>public String getParent()</td>
<td>获取文件所在目录</td>
</tr>
<tr>
<td>public File getParentFile()</td>
<td>获取文件所在目录对应的对象</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>获取文件路径</td>
</tr>
<tr>
<td>public boolean exists()</td>
<td>判断文件是否存在</td>
</tr>
<tr>
<td>public boolean isDirectory()</td>
<td>判断对象是否为目录</td>
</tr>
<tr>
<td>public boolean isFile()</td>
<td>判断对象是否为文件</td>
</tr>
<tr>
<td>public long length()</td>
<td>获取文件大小，以byte为单位</td>
</tr>
<tr>
<td>public boolean createNewFile()</td>
<td>根据当前File创建新的文件</td>
</tr>
<tr>
<td>public boolean delete()</td>
<td>删除文件</td>
</tr>
<tr>
<td>public boolean mkdir()</td>
<td>根据当前对象创建新目录</td>
</tr>
<tr>
<td>public boolean renameTo(File file)</td>
<td>为已存在的对象重命名</td>
</tr>
</tbody></table>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:\\java\\image\\123.png"</span>);</span><br><span class="line">        <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">            System.out.println(file.getName());</span><br><span class="line">            System.out.println(file.length());</span><br><span class="line">            System.out.println(file.getParent());</span><br><span class="line">            System.out.println(file.getPath());</span><br><span class="line">            File parentFile = file.getParentFile();</span><br><span class="line">            System.out.println(parentFile.getName());</span><br><span class="line">            System.out.println(parentFile.isDirectory());</span><br><span class="line">            System.out.println(file.isDirectory());</span><br><span class="line">            System.out.println(parentFile.isFile());</span><br><span class="line">            System.out.println(file.isFile());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file2 = <span class="keyword">new</span> File(<span class="string">"D:\\java\\image\\123.png"</span>);</span><br><span class="line">            System.out.println(file2.createNewFile());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="File-类详解"><a href="#File-类详解" class="headerlink" title="File 类详解"></a>File 类详解</h1><p>流是一种以<strong>先进先出</strong>的方式传输数据的序列，Java 中的流有很多不同的分类。</p>
<ul>
<li>按照方向分，可以分为<strong>输入流</strong>和<strong>输出流</strong>。</li>
<li>按照单位分，可以分为<strong>字节流</strong>和<strong>字符流</strong>，字节流是指每次处理的数据以字节为单位，字符流是指每次处理的数据以字符为单位。</li>
<li>按照功能分，可以分为<strong>节点流</strong>和<strong>处理流</strong>。</li>
</ul>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>以字节为单位处理数据，字节流又可以分为输入字节流（InputStream）和输出字节流（OutputStream）。</p>
<blockquote>
<p>InputStream</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((temp = inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>英文/数字/符号 这些格式的内容，一个字母对应一个字节 byte。</p>
<p>一个汉字对应三个字节 byte（在 UTF-8 编码格式下）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">            <span class="keyword">int</span> length = inputStream.read(bytes);</span><br><span class="line">            <span class="comment">//增强型for循环</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> aByte : bytes) &#123;</span><br><span class="line">                System.out.println(aByte);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">            <span class="comment">//截取流中的部分数据，从下标2开始，截取6个字符</span></span><br><span class="line">            <span class="keyword">int</span> length = inputStream.read(bytes,<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">            <span class="comment">//增强型for循环</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> aByte : bytes) &#123;</span><br><span class="line">                System.out.println(aByte);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>OutputStream</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\java\\image\\copy.txt"</span>);</span><br><span class="line">            outputStream.write(<span class="number">72</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\java\\image\\copy.txt"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = &#123;<span class="number">72</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>&#125;;</span><br><span class="line">            outputStream.write(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\java\\image\\copy.txt"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = &#123;<span class="number">72</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>&#125;;</span><br><span class="line">            outputStream.write(bytes,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 实现文件复制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\javahome\\test\\copy.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((temp = inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                outputStream.write(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>字符一定不小于字节，大于等于字节</p>
<p>字符流又分为输入字符流（Reader）和输出字符流（Writer）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Reader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((temp = reader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Reader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">            reader.read(chars);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">                System.out.println(aChar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Reader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">            reader.read(chars,<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">                System.out.println(aChar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节流是最基础的流，IO 流的基本单位，字符流是基于字节流，字符流是字节流经过处理之后的数据流。</p>
<blockquote>
<p>字符输入流</p>
</blockquote>
<p>Reader -&gt; InputStreamReader -&gt; FileReader</p>
<p>UTF-8 编码下，一个英文字符就是一个字节，在这种情况下，使用字符流和字节流是一样的，没有区别，一个汉字是三个字节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Reader reader = <span class="keyword">null</span>;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"使用字符流读取"</span>);</span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((temp = reader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"使用字节流读取"</span>);</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">while</span> ((temp = inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>read() 将文件中的数据以字符为单位依次读取出来</p>
<p>read(char[] chars)将文件中的数据复制到数组中，并返回数组的有效长度，数组长度要大于文件本身，否则数据读不完。</p>
<p>read(char[] chars,int off,int len)将文件中的数据复制到数组中，并返回数组的有效长度，但是数据会进行截取，len 指截取的文件长度（从 0 开始截取），off 是指数组中的偏移量，不是从 0 开始存数据，而是从 数组下标为off 的位置开始存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Reader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//父类引用指向子类（多态）</span></span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">            <span class="keyword">int</span> length = reader.read(chars,<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">            System.out.println(length);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">                System.out.println(aChar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符输出流</p>
</blockquote>
<p>OutputStream -&gt; OutputStreamWriter -&gt; Writer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Writer writer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writer = <span class="keyword">new</span> FileWriter(<span class="string">"D:\\java\\image\\copy.txt"</span>);</span><br><span class="line">            <span class="keyword">char</span>[] chars = &#123;<span class="string">'你'</span>,<span class="string">'好'</span>,<span class="string">'世'</span>,<span class="string">'界'</span>&#125;;</span><br><span class="line">            writer.write(chars,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>write(int a) 以字符对应的 ACS 码来进行文件数据的输出，需要把字符转为对应的 ASC 码</p>
<p>write(String str) 以字符串为单位进行输出，比较方便</p>
<p>write(String str,int off,int len) 以字符串为单位进行输出，进行截取，从 off 开始，截取长度为 len</p>
<p>write(char[] str) 以字符数组为单位进行输出</p>
<p>write(char[] str,int off,int len) 以字符数组为单位进行输出，进行截取，从 off 开始，截取长度为 len</p>
<p>如果要进行追加操作而不是覆盖的话，只需要在构造 FileWriter 的时候添加一个 boolean 类型参数即可，true 表示追加，false 表示覆盖。</p>
<h2 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h2><blockquote>
<p>处理流</p>
</blockquote>
<p>输入转换流 InputStreamReader</p>
<p>输出转换流 OutputStreamWriter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream,<span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理流和节点流（字节流和字符流）的区别</p>
<p>1、节点流可以直接连接到文件对象本身（看构造器能否直接传文件路径），处理流不能直接连接到文件对象本身，必须基于节点流（处理流的构造器只能将节点流作为参数传入）</p>
<p>2、节点流不能设置数据流的编码，文件本身是什么编码，数据流就是对应的编码，处理流可以通过构造器来设置编码，如果开发中遇到中文乱码的情况，可以使用处理流来进行设置。</p>
<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><blockquote>
<p>缓冲流</p>
</blockquote>
<p>实际开发中，无论使用哪种流（字节流或字符流），都会对硬盘造成损伤，为了解决这个问题，引入了缓冲流，自带缓冲区，可以一次性从硬盘中读取一部分数据存入缓冲区，减少对硬盘的访问次数。</p>
<p>缓冲流也属于处理流，不能直接连接文件对象进行操作，而是对已存在的节点流进行包装，基于节点流。</p>
<blockquote>
<p>字节输入缓冲流</p>
</blockquote>
<p>BufferedInputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        BufferedInputStream bufferedInputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//节点流</span></span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="comment">//缓冲流</span></span><br><span class="line">            bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(inputStream);</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((temp = bufferedInputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">                bufferedInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符输入缓冲流</p>
</blockquote>
<p>BufferedReader，提供了一个 <strong>readLine</strong> 方法，该方法可以按行读取文件中的数据，可以极大提升读取效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Reader reader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">            String s = bufferedReader.readLine();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字节输出缓冲流</p>
</blockquote>
<p>BufferedOutputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        BufferedOutputStream bufferedOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\java\\image\\copy.txt"</span>);</span><br><span class="line">            bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(outputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符输出缓冲流</p>
</blockquote>
<p>BufferedWriter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Writer writer = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writer = <span class="keyword">new</span> FileWriter(<span class="string">"D:\\java\\image\\copy.txt"</span>);</span><br><span class="line">            bufferedWriter = <span class="keyword">new</span> BufferedWriter(writer);</span><br><span class="line">            bufferedWriter.write(<span class="string">"Java是世界上最好的语言"</span>);</span><br><span class="line">            bufferedWriter.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">                bufferedWriter.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用缓冲流之后，一定要注意：在 close 之前必须先 flush，强制把数据输出，缓冲区就清空了，确保缓冲区中的数据已经全部传到了文件中，再来关闭流。否则会抛出 Stream closed 异常。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>OpenFeign服务接口调用</title>
    <url>/2020/12/21/OpenFeign%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h3 id="OpenFeign服务接口调用"><a href="#OpenFeign服务接口调用" class="headerlink" title="OpenFeign服务接口调用"></a>OpenFeign服务接口调用</h3><p>1.引入POM文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--openfeign--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;!--eureka client--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">   	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">  	    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a> 

<p>2.建立YML文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure>

<p>3.加注释</p>
<p>主启动类上加注释@EnableFeignClients </p>
<p>业务逻辑类上加注释@FeignClient(value = “CLOUD-PAYMENT-SERVICE（调用的服务名）”) @Component</p>
<p>然后直接copy自己要调用的服务方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentFeignService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/21/OpenFeign%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/1.png" alt="01"></p>
<p>4.超时控制</p>
<p>默认OpenFeign只等待一秒钟，可通过yml文件进行设置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置feign客户端超时时间(OpenFeign默认支持ribbon)</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="comment">#指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="comment">#指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>5.日志增强</p>
<p>先添加配置类，直接为FULL最全日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再在yml文件里开启</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment"># feign日志以什么级别监控哪个接口</span></span><br><span class="line">    <span class="attr">com.xzs.springcloud.service.PaymentFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud Alibaba-Nacos</title>
    <url>/2020/12/21/SpringCloud-Alibaba-Nacos/</url>
    <content><![CDATA[<h3 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h3><p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/1.png" alt="01"></p>
<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>一句话，等价于Eureka+Config+Bus</p>
<p>Nacos自带负载均衡，且支持AP和CP‘<a id="more"></a> </p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/2.png" alt="02"></p>
<h4 id="一、服务提供者"><a href="#一、服务提供者" class="headerlink" title="一、服务提供者"></a>一、服务提供者</h4><p>1.nacos/bin/startup.cmd启动nacos</p>
<p>2.写POM</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3.写YML</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置Nacos地址</span></span><br><span class="line">        <span class="comment"># 换成nginx的1111端口，做集群</span></span><br><span class="line"><span class="comment">#        server-addr: 192.168.111.144:1111</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure>

<p>4.启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span>   <span class="comment">//不再需要@EnableEurekaClint等注解</span></span><br></pre></td></tr></table></figure>

<h4 id="二、服务消费者"><a href="#二、服务消费者" class="headerlink" title="二、服务消费者"></a>二、服务消费者</h4><p>1.写POM</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;!--SpringCloud</span> <span class="string">ailibaba</span> <span class="string">nacos</span> <span class="string">--&gt;</span></span><br><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">	<span class="string">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line">	<span class="string">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.写YML</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br></pre></td></tr></table></figure>

<p>3.启动类上写注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure>

<h4 id="三、Nacos服务配置中心"><a href="#三、Nacos服务配置中心" class="headerlink" title="三、Nacos服务配置中心"></a>三、Nacos服务配置中心</h4><p>1.写POM</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos-config--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--nacos-discovery--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.写application.yml和bootstrap.yml</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/3.png" alt="03"></p>
<p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br><span class="line">    <span class="comment">#active: test # 表示测试环境</span></span><br><span class="line">    <span class="comment">#active: info</span></span><br></pre></td></tr></table></figure>

<p>bootstrap.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line"><span class="comment">#        group: DEV_GROUP</span></span><br><span class="line"><span class="comment">#        namespace: 7d8f0f5a-6a53-4785-9686-dd460158e5d4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment"># nacos-config-client-dev.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nacos-config-client-test.yaml   ----&gt; config.info</span></span><br></pre></td></tr></table></figure>

<p>3.在nacos页面添加配置</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/4.png" alt="04"></p>
<p>Data ID需要固定设置</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/5.png" alt="05"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/6.png" alt="06"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/7.png" alt="07"></p>
<p>三大配置：Data ID、Group、NameSpace</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/8.png" alt="08"></p>
<p>4.Data ID：根据spring.profiles.active里的配置进行加载nacos上的配置</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/9.png" alt="09"></p>
<p>5.Group:  默认加载默认组，加载特定组只需要在config下添加一条group即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEV_GROUP</span></span><br></pre></td></tr></table></figure>

<p>即若当前active: info，则会加载DEV_GROUP组下的nacos-config-client-info.yaml</p>
<p>6.NameSpace</p>
<p>默认命名空间即在public下</p>
<p>每个命名空间都有特定的ID</p>
<p>访问命名空间则需要再添加一条yml，并添加要读取配置的命名空间ID</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">TEST_GROUP</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">20ffe5ef-79bb-4048-aaa9-5920c61f5761</span></span><br></pre></td></tr></table></figure>

<p>该配置则去寻找命名空间ID为20ffe5ef-79bb-4048-aaa9-5920c61f5761的空间下，TEST_GROUP的nacos-config-client-dev.yaml（application.yml里是active:dev）</p>
<h4 id="四、Nacos集群和持久化配置（重要）"><a href="#四、Nacos集群和持久化配置（重要）" class="headerlink" title="四、Nacos集群和持久化配置（重要）"></a>四、Nacos集群和持久化配置（重要）</h4><p>1.Nacos集群架构</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/10.png" alt="10"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/11.png" alt="11"></p>
<p>2.Nacos内嵌数据库derby存储配置，所以要进行切换数据库derby到我们本地数据库MySQL</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/12.png" alt="12"></p>
<p>3.</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/13.png" alt="13"></p>
<p>4.服务端访问nginx的端口，nginx里配置好映射，映射到三台nacos上</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/14.png" alt="14"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud Alibaba-Sentinel</title>
    <url>/2020/12/21/SpringCloud-Alibaba-Sentinel/</url>
    <content><![CDATA[<h3 id="Sentinel实现熔断与限流"><a href="#Sentinel实现熔断与限流" class="headerlink" title="Sentinel实现熔断与限流"></a>Sentinel实现熔断与限流</h3><p>面对云原生微服务的流量控制、熔断降级组件</p>
<p>分布式系统的流量防卫兵，取代了Hystrix</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/1.png" alt="1"></p>
<h4 id="一、运行"><a href="#一、运行" class="headerlink" title="一、运行"></a>一、运行</h4><p>java -jar sentinel-dashboard-1.7.2.jar</p>
<p>访问<a href="http://localhost:8080即可出现可视化界面">http://localhost:8080即可出现可视化界面</a></p>
<p>用户名密码都是sentinel</p>
<a id="more"></a> 

<h4 id="二、初次使用"><a href="#二、初次使用" class="headerlink" title="二、初次使用"></a>二、初次使用</h4><p>主要配好YML文件即可使用</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/2.png" alt="2"></p>
<h4 id="三、Sentinel流控"><a href="#三、Sentinel流控" class="headerlink" title="三、Sentinel流控"></a>三、Sentinel流控</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/3.png" alt="3"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/4.png" alt="4"></p>
<p>预热</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/5.png" alt="5"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/6.png" alt="6"></p>
<p>排队等待</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/7.png" alt="7"></p>
<h4 id="四、Sentinel降级"><a href="#四、Sentinel降级" class="headerlink" title="四、Sentinel降级"></a>四、Sentinel降级</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/8.png" alt="8"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/9.png" alt="9"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/10.png" alt="10"></p>
<p>1.RT（平均响应时间）</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/11.png" alt="11"></p>
<p>2.异常比例</p>
<p>异常超过一定比例就跳闸</p>
<p>3.异常数</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/12.png" alt="12"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/13.png" alt="13"></p>
<h4 id="五、Sentinel热点Key限流"><a href="#五、Sentinel热点Key限流" class="headerlink" title="五、Sentinel热点Key限流"></a>五、Sentinel热点Key限流</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/14.png" alt="14"></p>
<p>@SentunelResource对Sentinel控制台里的热点规则负责，只要服务违背了配置规则，则会调用下面的兜底方法</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/15.png" alt="15"></p>
<p>当索引为0的参数（即p1）单机阈值（一秒点击率）超过了1，则调用兜底方法，而参数p2随便快速点击多少次也没事</p>
<p>特殊情况：</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/16.png" alt="16"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/17.png" alt="17"></p>
<h4 id="六、Sentinel系统规则"><a href="#六、Sentinel系统规则" class="headerlink" title="六、Sentinel系统规则"></a>六、Sentinel系统规则</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/18.png" alt="18"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/19.png" alt="19"></p>
<p>系统全局的保护规则</p>
<h4 id="七、-SentinelResource配置"><a href="#七、-SentinelResource配置" class="headerlink" title="七、@SentinelResource配置"></a>七、@SentinelResource配置</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/20.png" alt="1602498555342"></p>
<p>对customerBlockHandler进行限流，一旦超出限制，则交由blockHandlerClass里的blockHandler进行兜底</p>
<p>blockHandlerClass里就可以写好几个blockHandler来进行兜底</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/21.png" alt="1602498686863"></p>
<p>即</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/22.png" alt="1602498766708"></p>
<h4 id="八、Sentinel服务熔断"><a href="#八、Sentinel服务熔断" class="headerlink" title="八、Sentinel服务熔断"></a>八、Sentinel服务熔断</h4><p>没有配置：</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/23.png" alt="1602500010113"></p>
<p>只配置fallback，fallback只负责业务java异常：</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/24.png" alt="1602500084574"></p>
<p>只配置blockHandler，只负责sentinal控制台配置违规：</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/25.png" alt="1602500224788"></p>
<p>fallback和blockHandler都配置：</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/26.png" alt="1602500512750"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/27.png" alt="1602500639919"></p>
<p>blockHandler大于fallback</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud Sleuth分布式请求链路跟踪</title>
    <url>/2020/12/21/SpringCloud-Sleuth%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%B7%E6%B1%82%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/</url>
    <content><![CDATA[<h3 id="SpringCloud-Sleuth分布式请求链路跟踪（链路监控）"><a href="#SpringCloud-Sleuth分布式请求链路跟踪（链路监控）" class="headerlink" title="SpringCloud Sleuth分布式请求链路跟踪（链路监控）"></a>SpringCloud Sleuth分布式请求链路跟踪（链路监控）</h3><p>1.问题</p>
<p><img src="/2020/12/21/SpringCloud-Sleuth%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%B7%E6%B1%82%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/1.png" alt="1600257590874"></p>
<p>2.安装zipkin</p>
<p><img src="/2020/12/21/SpringCloud-Sleuth%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%B7%E6%B1%82%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/2.png" alt="1600265041699"></p>
<p>3.服务端payment8001和客户端order80都导入POM</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--包含了sleuth+zipkin--&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a> 

<p>4.写YML</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">    <span class="attr">sleuth:</span></span><br><span class="line">      <span class="attr">sampler:</span></span><br><span class="line">      <span class="comment">#采样率值介于 0 到 1 之间，1 则表示全部采集</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>5.进行服务请求，则可进入localhost:9411/zipkin查看链路追踪</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud五大神兽</title>
    <url>/2020/05/12/SpringCloud%E4%BA%94%E5%A4%A7%E7%A5%9E%E5%85%BD/</url>
    <content><![CDATA[<h4 id="Eureka注册中心："><a href="#Eureka注册中心：" class="headerlink" title="Eureka注册中心："></a>Eureka注册中心：</h4><p> 注册中心：itcast-eureka(1.引入启动器  2.配置spring.application.name=itcast-eureka  3.在引导类上加注解@EnableEurekaServer)<br>        客户端： itcast-service-provider   itcast-service-consumer<br>         ( 1.引入启动器  </p>
<p>   2.配置spring.application.name  eureka.client.service-url.defaultZone=<a href="http://localhost:10086/eureka" target="_blank" rel="noopener">http://localhost:10086/eureka</a> (下载APP)<br>              3. @EnableDiscoveryClient(启用eureka客户端))</p>
<p>服务名称修改：instance.instance-id=”xxx”  主机IP信息显示:  instance.prefer-ip-address: true  显示服务信息info: <a id="more"></a></p>
<h4 id="Ribbon负载均衡："><a href="#Ribbon负载均衡：" class="headerlink" title="Ribbon负载均衡："></a>Ribbon负载均衡：</h4><p>1.不需要添加启动器 Eureka里面自带了</p>
<p>2.不需要覆盖默认配置就能使用了</p>
<p>3.在RestTemplate上启用 @LoadBalanced 开启负载均衡</p>
<p>4.使用：通过服务名service-provider修改getForObject(“xxx”)里的参数</p>
<p>​               this.restTemplate.getForObject(“<a href="http://service-provider/user&quot;+id,User.class" target="_blank" rel="noopener">http://service-provider/user&quot;+id,User.class</a>);</p>
<h4 id="Hystrix容错组件："><a href="#Hystrix容错组件：" class="headerlink" title="Hystrix容错组件："></a>Hystrix容错组件：</h4><p>降级：检查每次请求，是否请求超时；或者连接池已满<br>                   1.pom.xml加启动器<br>                   2.不需要覆盖默认配置 因为默认设置超时时间为一秒钟 开发过程中够用，但如果需要改就去copy笔记放入service-consumer的application.yml中配置<br>                   3.开启@EnableCircuitBreaker熔断器注解<br>                   4.写一个熔断方法fallbackMethod()，返回类似”服务器正忙，请稍后再试！”  同时在原方法上加个注解@HystrixCommand(fallbackMethod=”fallbackMethod”) 使该方法调用失败时则会调用熔断方法 返回值和参数列表都一致<br>                   5.或给类统一设定一个熔断方法：@DefaultProperties(defaultFallback=”fallbackMethod”)，防止方法太多一直写上面那个注解，如果方法有自己设置@HystrixCommand熔断方法，则使用他自己设置的熔断方法  且全局熔断方法的返回值和被熔断方法一致，但参数列表为空<br>       熔断：不在发送请求  三种状态<br>                   1.close：闭合状态，所有请求正常访问<br>                   2.open：打开状态，所有请求都无法访问。如果在一定时间内容，失败的比例不小于50%或者次数不少于20次<br>                   3.half open： 半开状态，打开状态默认5s休眠期，在休眠期所有请求无法正常访问。过了休眠期就会进入半开状态，放部分请求通过                          @SpringCloudApplication=@SpringbootApplication+@EnableDiscoveryClient+@EnableCircuitBreaker</p>
<h4 id="Feign远程调用组件："><a href="#Feign远程调用组件：" class="headerlink" title="Feign远程调用组件："></a>Feign远程调用组件：</h4><p>1.service-consume的pox.xml加openFeign启动器<br>        2.在引导类上加注解@EnableFeignClients  就不需要用restTemplate了<br>        3.使用Feign就是创建一个接口 接口上加@FeignClient(value=”service-provider”//服务提供者名字)<br>        4.不能使用@RequestMapping写主路径  只能在接口方法上面的@GetMapping()里把路径全写出来（现在好像修复了？）<br>        5.feign.hystrix.enabled: true 开启Hystrix熔断  默认不开启要开启一下<br>        6.写一个类UserClientFallback实现接口  实现方法就是熔断方法  ，并且在接口原先注解 @FeignClient(value=”service-provider” fallback=UserClientFallback.class//实现类.class)<br>然后在熔断类上加@Component  添加入组件</p>
<h4 id="Zuul网关："><a href="#Zuul网关：" class="headerlink" title="Zuul网关："></a>Zuul网关：</h4><p>1.建立独立的模块  引入Cloud Routing-&gt;Zuul 依赖<br>        2.配置port和spring.application.name<br>        3.导入类上加注解@EnableZuulProxy<br>        4.配置路由(分发服务)： zuul：(第三种配置)<br>                                                 routes：<br>                                                 service-provider：/service-provider/**   #这个服务前缀路径路由到这个服务id  #路由名称，随便写，习惯写上服务名<br>                                                 service-consumer(路由名称)：/consumer/**<br>                                                 #path：/service-provider/**<br>                                                 #url： http：//localhost：8082  #service-provider的路径<br>                                                 #serviceId：service-provider<br>                                                 prefix：/api    #zuul网关的前缀  判断有没有通过网关访问服务<br>                                                  eureka：<br>                                                       client：<br>                                                          service-url：<br>                                                             defaultZone：http：//localhost：10086/eureka<br>        5.过滤器  继承ZuulFilter 重写四个方法<br>                                                                  filterType: pre route post error<br>                                                                  filterOrder: 返回值越小优先级越高<br>                                                                  shouldFilter: 是否执行run方法。true执行<br>                                                                  run: 具体的拦截逻辑</p>
<h4 id="SpringCloud-Config分布式配置中心："><a href="#SpringCloud-Config分布式配置中心：" class="headerlink" title="SpringCloud Config分布式配置中心："></a>SpringCloud Config分布式配置中心：</h4><p>每个微服务都有个application.yml，要是成百上千个，这么多yml难以管理，所以SpringCloud推出了该配置中心来管理这些yml<br>       运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息<br>       当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置，将配置信息以REST接口的形式暴露<br>          服务端配置（与GitHub连通）：<br>                1.GitHub建一个仓库 拿到config项目的SSH协议的git地址<br>                2.本地磁盘上新建个git仓库  并右键Git Bash Here输入git clone config项目的SSH协议的git地址<br>                3.在仓库的config项目文件夹里面新建application.yml文件，记住保存编码为UTF-8<br>                4.通过git指令(add commit push)将yml文件上传到GitHub仓库<br>                5.在config模块中导入pom依赖<br>                6.覆盖yml配置文件：cloud.config.server.git.url: GitHub上面的仓库名字  保持一致<br>                7.引导类上加@EnableConfigServer注解<br>          客户端配置：<br>                1.保存好客户端要用的yml文件，并传输到GitHub上<br>                2.创建客户端模块，添加pom依赖<br>                3.添加bootstrap.yml文件（优先级高）   127.0.0.1-&gt;config-3344.com 域名映射<br>               spring:<br>                  cloud:<br>                     config:<br>                       name: microservicecloud-config-client #需要从github上读取的资源名称，注意没有yml后缀名<br>                       profile: dev   #本次访问的配置项<br>                       label: master<br>                       uri: <a href="http://config-3344.com:3344" target="_blank" rel="noopener">http://config-3344.com:3344</a>  #本微服务启动后先去找3344号服务端，通过SpringCloudConfig获取GitHub的服务地址<br>               4.添加application.yml，放个名字就好<br>                   spring:<br>                        application:<br>                             name: microservicecloud-config-client<br>               5.添加带有@RestController注解的类  进行获取配置文件信息<br>               6.启动引导类</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringSecurity动态权限配置</title>
    <url>/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="动态权限配置"><a href="#动态权限配置" class="headerlink" title="动态权限配置"></a>动态权限配置</h1><p>之前我们各个用户赋予各个权限，实际中显然不行，我们需要通过后台管理动态去配置用户权限，我们可以修改用户访问权限，也可以修改用户能访问哪些资源</p>
<p>所以我们把权限这套东西放在数据库里，然后通过数据库里数据的关系来描述用户拥有的权限</p>
<p>创建各类表：</p>
<p>menu资源表<img src="/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/1.png" alt="1604396717980"></p>
<p>role角色表<img src="/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/2.png" alt="1604396749741"></p>
<p>user用户表<img src="/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/3.png" alt="1604396775805"></p>
<p>和两个关联表</p>
<a id="more"></a> 

<p>我们就可以通过用户查到用户所拥有的角色，才通过角色查询到所能访问的资源（相当于把9.基于数据库的认证里的访问权限拦截设置也放数据库里了）</p>
<p>原本我们这个路径是自己写死的</p>
<p><img src="/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/4.png" alt="1604398080044"></p>
<p>现在我们就需要查询数据库来得到了</p>
<p>如何动态地从数据库加载呢？我们就需要定义几个东西</p>
<p>定义一个MyFilter实现FilterInvocationSecurityMetadataSource</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">FilterInvocationSecurityMetadataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来匹配路径</span></span><br><span class="line">    AntPathMatcher pathMatcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MenuService menuService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据你的请求地址分析出来需要哪些角色，匹配上就返回需要的角色，没匹配上返回个默认值</span></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//Collection返回你需要的角色</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAttributes</span><span class="params">(Object o)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">//获取请求地址</span></span><br><span class="line">        String requestUrl = ((FilterInvocation) o).getRequestUrl();</span><br><span class="line">        <span class="comment">//菜单里面的pattern就定义了路径规则</span></span><br><span class="line">        List&lt;Menu&gt; allMenus = menuService.getAllMenus();</span><br><span class="line">        <span class="keyword">for</span>(Menu menu : allMenus)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pathMatcher.match(menu.getPattern(),requestUrl))&#123;<span class="comment">//如果你请求的路径和pattern里路径匹配上了</span></span><br><span class="line">                List&lt;Role&gt; roles = menu.getRoles();   <span class="comment">//拿出各个角色放入数组</span></span><br><span class="line">                String[] roleStr = <span class="keyword">new</span> String[roles.size()];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i &lt; roles.size(); i++)&#123;</span><br><span class="line">                    roleStr[i] = roles.get(i).getName();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> SecurityConfig.createList(roleStr);<span class="comment">//然后进到MyAccessDecisionManager进行角色的比较</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果路径都匹配不上，给他返回一个默认资源</span></span><br><span class="line">        <span class="keyword">return</span> SecurityConfig.createList(<span class="string">"ROLE_login"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAllConfigAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sql查询</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAllMenus"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">       select m.*,r.`id` as rid,r.`name` as rname,r.`nameZh` as rnameZh from menu m left join menu_role mr on m.`id`=mr.`mid` left join role r on mr.`rid`=r.`id`</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.xzs.springsecurity3.bean.Menu"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"pattern"</span> <span class="attr">column</span>=<span class="string">"pattern"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"roles"</span> <span class="attr">ofType</span>=<span class="string">"com.xzs.springsecurity3.bean.Role"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"rid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"rname"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"rnameZh"</span> <span class="attr">property</span>=<span class="string">"nameZh"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/5.png" alt="1604398678526"></p>
<p>此时我们已经知道了请求路径需要哪些角色，然后我又有哪些角色，进行比较，比较成功该请求就往下走，如果你需要的角色我没有，那这就是一个非法请求</p>
<p>再定义一个MyAccessDecisionManager实现AccessDecisionManager接口，进行角色比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccessDecisionManager</span> <span class="keyword">implements</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication<span class="comment">/*保存了当前登录用户的信息，知道了我有哪些角色*/</span>, Object o<span class="comment">/*用来获取当前请求对象*/</span>, Collection&lt;ConfigAttribute&gt; collection)</span><span class="comment">/*需要哪些角色的集合*/</span> <span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ConfigAttribute attribute : collection) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"ROLE_login"</span>.equals(attribute.getAttribute()))&#123;</span><br><span class="line">                <span class="keyword">if</span> (authentication <span class="keyword">instanceof</span> AnonymousAuthenticationToken) &#123;<span class="comment">//如果你是个匿名用户，就是未登录</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(<span class="string">"非法请求!"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br><span class="line">            <span class="keyword">for</span> (GrantedAuthority authority : authorities) &#123;<span class="comment">//如果需要的角色集合里有一个我有的，则成功</span></span><br><span class="line">                <span class="keyword">if</span> (authority.getAuthority().equals(attribute.getAttribute())) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(<span class="string">"非法请求!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute configAttribute)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后再在SecurityConfig里进行注入和配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   MyFilter myFilter;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   MyAccessDecisionManager myAccessDecisionManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       http.authorizeRequests()</span><br><span class="line">               .withObjectPostProcessor(<span class="keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="function">O <span class="title">postProcess</span><span class="params">(O o)</span> </span>&#123;</span><br><span class="line">                       o.setAccessDecisionManager(myAccessDecisionManager);</span><br><span class="line">                       o.setSecurityMetadataSource(myFilter);</span><br><span class="line">                       <span class="keyword">return</span> o;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">               .and()</span><br><span class="line">               .formLogin()</span><br><span class="line">               .permitAll()</span><br><span class="line">               .and()</span><br><span class="line">               .csrf().disable();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>此时进行接口访问，使用user对象登录，只拥有访问/user的权限</p>
<p><img src="/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/6.png" alt="1604403843728"></p>
<p>访问其他接口即报错</p>
<p><img src="/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/7.png" alt="1604403863318"></p>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud Stream消息驱动</title>
    <url>/2020/12/21/SpringCloud-Stream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h3 id="SpringCloud-Stream消息驱动"><a href="#SpringCloud-Stream消息驱动" class="headerlink" title="SpringCloud Stream消息驱动"></a>SpringCloud Stream消息驱动</h3><p>一句话：屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型</p>
<p>核心：通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离</p>
<p><img src="/2020/12/21/SpringCloud-Stream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/1.png" alt="1600176801553"></p>
<p><img src="/2020/12/21/SpringCloud-Stream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/2.png" alt="1600175467504"></p>
<a id="more"></a> 

<h4 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h4><p>1.写POM文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.建立YML文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">      <span class="attr">stream:</span></span><br><span class="line">        <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">          <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">            <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">              <span class="attr">spring:</span></span><br><span class="line">                <span class="attr">rabbitmq:</span></span><br><span class="line">                  <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.199</span><span class="number">.171</span></span><br><span class="line">                  <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                  <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                  <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">        <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理   主要配置这个Binding</span></span><br><span class="line">          <span class="attr">output:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">            <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">            <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">            <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 客户端进行Eureka注册的配置</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">send-8801.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 访问的路径变为IP地址</span></span><br></pre></td></tr></table></figure>

<p>3.在ServiceImpl书写逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(Source<span class="class">.<span class="keyword">class</span>) //定义消息的推送管道</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MessageProviderImpl</span> <span class="keyword">implements</span> <span class="title">IMessageProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output;  <span class="comment">//消息发送管道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span> </span>&#123;<span class="comment">//往消息中间件发送流水号</span></span><br><span class="line">        String serial = UUID.randomUUID().toString();</span><br><span class="line">        output.send(MessageBuilder.withPayload(serial).build());<span class="comment">//创建一个消息体并发送</span></span><br><span class="line">        System.out.println(<span class="string">"*******serial:"</span>+serial);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h4><p>Controller逻辑书写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableBinding</span>(Sink<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ReceiveMessageListenerController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Message&lt;String&gt; message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"消费者2号,-----&gt;接受到的消息: "</span>+message.getPayload()+<span class="string">"\t  port: "</span>+serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="避免重复消费问题"><a href="#避免重复消费问题" class="headerlink" title="避免重复消费问题"></a>避免重复消费问题</h4><p>服务提供者发布消息，会存在被多个消费者消费的问题。因为默认分组不同，会被重复消费，同一个组才只能其中一个消费</p>
<p><img src="/2020/12/21/SpringCloud-Stream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/3.png" alt="1600178378666"></p>
<p>解决方法：yml里添加一行group: xzsA</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">          <span class="attr">input:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">            <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">            <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为对象json，如果是文本则设置“text/plain”</span></span><br><span class="line">            <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line">            <span class="attr">group:</span> <span class="string">xzsA</span></span><br></pre></td></tr></table></figure>

<p>同时该group属性也对消息持久性十分重要，没有加的消费者端如果没启动，收不到消息</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud Alibaba-Seata</title>
    <url>/2020/12/21/SpringCloud-Alibaba-Seata/</url>
    <content><![CDATA[<h3 id="Seata处理分布式事务"><a href="#Seata处理分布式事务" class="headerlink" title="Seata处理分布式事务"></a>Seata处理分布式事务</h3><h4 id="一、问题的提出："><a href="#一、问题的提出：" class="headerlink" title="一、问题的提出："></a>一、问题的提出：</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Seata/1.png" alt="01"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Seata/6.png" alt="1602508607972"></p>
<a id="more"></a> 

<h4 id="二、Seata术语："><a href="#二、Seata术语：" class="headerlink" title="二、Seata术语："></a>二、Seata术语：</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Seata/2.png" alt="02"></p>
<h4 id="三、处理过程："><a href="#三、处理过程：" class="headerlink" title="三、处理过程："></a>三、处理过程：</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Seata/3.png" alt="3"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Seata/4.png" alt="4"></p>
<h4 id="四、业务说明"><a href="#四、业务说明" class="headerlink" title="四、业务说明"></a>四、业务说明</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Seata/5.png" alt="5"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>Vuex知识点</title>
    <url>/2020/12/20/Vuex%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="Vuex：状态管理管家"><a href="#Vuex：状态管理管家" class="headerlink" title="Vuex：状态管理管家"></a>Vuex：状态管理管家</h3><p> state：        存放属性  已经在state里定义的属性才有放进响应式系统 通过Vue.set() Vue.delete()是响应式的<br>         getters    ：属性需要经过变化使用该属性 类似计算属性                                                                                                                                              定义的方法可有三个参数（state，getters，rootState）<br>        mutations：存放同步方法                                                                                                                                                                        通过mutations更新state里的属性值：this.$store.commit(‘mutations里定义的方法名’)<br>                              要多传个参数过去直接this.$store.commit(‘方法名’,参数)<br>        action：       类似于mutations，用来替代mutations进行异步操作, this.$store.dispatch(‘action里定义的方法名’)<br>                              context上下文对象  可调用commit那些 但只能在本块区域<br>        modules：  可将state分割成模块，每个模块都有state、mutations、actions、getters，并且最终模块被                                 放到了state里</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>SpringSecurity基于数据库的认证</title>
    <url>/2020/12/21/SpringSecurity%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h1 id="1-基于数据库的认证"><a href="#1-基于数据库的认证" class="headerlink" title="1.基于数据库的认证"></a>1.基于数据库的认证</h1><p> 之前我们都是自己配置用户名、密码和权限，现在我们要从数据库中读取这些数据</p>
<p>过程：</p>
<p>如果我们需要自己从数据库加载用户，在定义用户时要实现UserDetail , 再实现接口里的方法 </p>
<p> UserDetail相当于一个规范，我们每个人定义的User属性名可能不一样，所以通过重写方法返回我们自己定义的用户名、密码等，UserDetail则可知道 </p>
<p>首先Bean里定义的User类需要继承UserDetail</p>
<a id="more"></a> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Boolean enabled;</span><br><span class="line">    <span class="keyword">private</span> Boolean locked;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//账户是否没有过期</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">////账户是否没有被锁定</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !locked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//密码是否没有过期</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户是否可用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enabled;   <span class="comment">//返回我们自己定义的字段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回用户的所有角色</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Role role : roles) &#123;<span class="comment">//SpringSecurity有一个规则，角色要以ROLE_开头，数据库如果不是这样我们就得手动加上</span></span><br><span class="line">            authorities.add(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">"ROLE_"</span>+role.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">getRoles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoles</span><span class="params">(List&lt;Role&gt; roles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roles = roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(Boolean enabled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocked</span><span class="params">(Boolean locked)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.locked = locked;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次UserService也要实现UserDetailsService，再写mapper去数据库查询数据即可</p>
<p>UserService记得要注入SecurityConfig里的auth</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据用户名去查询用户</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        User user = userMapper.loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">"用户不存在!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        user.setRoles(userMapper.getUserRolesById(user.getId()));</span><br><span class="line">        <span class="comment">//登陆成功后，把user返回，至于他填的用户名和密码对不对由SpringSecurity自己去比较</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后书写SecurityConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将userService注入auth</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/dba/**"</span>).hasRole(<span class="string">"dba"</span>)</span><br><span class="line">                .antMatchers(<span class="string">"/admin/**"</span>).hasRole(<span class="string">"admin"</span>)</span><br><span class="line">                .antMatchers(<span class="string">"/user/**"</span>).hasRole(<span class="string">"user"</span>)</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问各个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/dba/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dba</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello dba!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/admin/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello admin!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello user!"</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/21/SpringSecurity%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%A4%E8%AF%81/1.png" alt="1604395766607"></p>
<p>root具有dba和admin权限，admin有admin权限，user有user权限</p>
<p>从数据库中读取用户账户、密码，然后使用root登录</p>
<p> ![img](file:///C:\Users\ASUS\Documents\Tencent Files\1017477355\Image\C2C\OQA[4QB3E$M59T1<code>J@</code>{SZ4.png) </p>
<p>从而root只能访问/dba/hello、/admin/hello接口</p>
<p><img src="/2020/12/21/SpringSecurity%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%A4%E8%AF%81/2.png" alt="1604395976580"></p>
<p><img src="/2020/12/21/SpringSecurity%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%A4%E8%AF%81/3.png" alt="1604395988543"></p>
<p><img src="/2020/12/21/SpringSecurity%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%A4%E8%AF%81/4.png" alt="1604396003816"></p>
<h1 id="2-角色继承"><a href="#2-角色继承" class="headerlink" title="2.角色继承"></a>2.角色继承</h1><p>加上此Bean，dba就有了dab、admin、user权限，admin也有admin、user，user有user</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function">RoleHierarchy <span class="title">roleHierarchy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       RoleHierarchyImpl roleHierarchy = <span class="keyword">new</span> RoleHierarchyImpl();</span><br><span class="line">       String hierarchy = <span class="string">"ROLE_dba &gt; ROLE_admin \n ROLE_admin &gt; ROLE_user"</span>;</span><br><span class="line">       roleHierarchy.setHierarchy(hierarchy);</span><br><span class="line">       <span class="keyword">return</span> roleHierarchy;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>再次用root登录去访问/user接口</p>
<p><img src="/2020/12/21/SpringSecurity%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%A4%E8%AF%81/5.png" alt="1604396311487"></p>
<p>成功访问得到！</p>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
  </entry>
  <entry>
    <title>SpringSecurity配置</title>
    <url>/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="1-HttpSecurity拦截配置"><a href="#1-HttpSecurity拦截配置" class="headerlink" title="1.HttpSecurity拦截配置"></a>1.HttpSecurity拦截配置</h1><p>我们需要配置不同的拦截规则对不同的url进行拦截</p>
<p>1.重写方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       http.authorizeRequests()  <span class="comment">//开启配置</span></span><br><span class="line">               .antMatchers(<span class="string">"/admin/**"</span>).hasRole(<span class="string">"admin"</span>)<span class="comment">//ant风格的匹配符，路径符合这个规则要有哪些角色权限</span></span><br><span class="line">               .antMatchers(<span class="string">"/user/**"</span>).hasAnyRole(<span class="string">"admin"</span>,<span class="string">"user"</span>)<span class="comment">//拥有多个角色中的一个就能访问</span></span><br><span class="line">           <span class="comment">//  .antMatchers("/user/**").access("hasAnyRole('admin','user')")  和上面一样</span></span><br><span class="line">               .anyRequest().authenticated() <span class="comment">//剩下的其他请求都是authenticated，登录之后就能访问</span></span><br><span class="line">               .and()</span><br><span class="line">               .formLogin()  <span class="comment">//登录表单  主要是易于postman发送请求</span></span><br><span class="line">               .loginProcessingUrl(<span class="string">"/doLogin"</span>) <span class="comment">//处理登录的URL postman访问这个接口即可登录</span></span><br><span class="line">               .permitAll()  <span class="comment">//跟登录相关的这些接口就能访问</span></span><br><span class="line">               .and()</span><br><span class="line">               .csrf().disable();  <span class="comment">//spring security自带csrf攻击 关闭csrf攻击就能用postman</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>访问/admin的请求都需要有admin权限</p>
<p>访问/user的请求都需要有user权限</p>
<a id="more"></a> 

<h1 id="2-登陆表单配置"><a href="#2-登陆表单配置" class="headerlink" title="2.登陆表单配置"></a>2.登陆表单配置</h1><p>访问一个接口，spring security会默认给你跳到/login登录页面去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/admin/**"</span>).hasRole(<span class="string">"admin"</span>)</span><br><span class="line"><span class="comment">//                .antMatchers("/user/**").hasAnyRole("admin","user")</span></span><br><span class="line">                .antMatchers(<span class="string">"/user/**"</span>).access(<span class="string">"hasAnyRole('admin','user')"</span>)</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginProcessingUrl(<span class="string">"/doLogin"</span>)</span><br><span class="line">                .loginPage(<span class="string">"/login"</span>)  <span class="comment">//配置自己的登录页面</span></span><br><span class="line">                .usernameParameter(<span class="string">"uname"</span>)  <span class="comment">//postman访问的参数名</span></span><br><span class="line">                .passwordParameter(<span class="string">"pwd"</span>)</span><br><span class="line">            	.successHandler(<span class="keyword">new</span> AuthenticationSuccessHandler() &#123; <span class="comment">//登录成功后的处理</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);<span class="comment">//返回json</span></span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                        map.put(<span class="string">"status"</span>,<span class="number">200</span>);</span><br><span class="line">                        map.put(<span class="string">"msg"</span>,authentication.getPrincipal());<span class="comment">//getPrincipal()保存了刚刚登录成功的用户对象</span></span><br><span class="line">                        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(map));<span class="comment">//把map搞成一个json字符串写出去</span></span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            	.failureHandler(<span class="keyword">new</span> AuthenticationFailureHandler()&#123; <span class="comment">//登录失败的处理</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;<span class="comment">//这时候就没有登录成功的对象authentication了，而是一个异常，通过异常我们就能知道因为什么而登录失败</span></span><br><span class="line">                        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                        map.put(<span class="string">"status"</span>,<span class="number">401</span>);</span><br><span class="line">                        <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> LockedException)&#123;</span><br><span class="line">                            map.put(<span class="string">"msg"</span>,<span class="string">"账户被锁定，登录失败"</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> BadCredentialsException)&#123;</span><br><span class="line">                            map.put(<span class="string">"msg"</span>,<span class="string">"用户名或密码输入错误，登录失败"</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> DisabledException)&#123;</span><br><span class="line">                            map.put(<span class="string">"msg"</span>,<span class="string">"账户被禁用，登录失败"</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> AccountExpiredException)&#123;</span><br><span class="line">                            map.put(<span class="string">"msg"</span>,<span class="string">"账户过期，登录失败"</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> CredentialsExpiredException)&#123;</span><br><span class="line">                            map.put(<span class="string">"msg"</span>,<span class="string">"密码过期，登录失败"</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            map.put(<span class="string">"msg"</span>,<span class="string">"登录失败"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(map));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/1.png" alt="1604327277062"></p>
<p>访问后跳转到/login页面，需要进行登录</p>
<p>这时候使用Postman访问/doLogin接口进行登录</p>
<p><img src="/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/2.png" alt="1604326438237"></p>
<p>此时登录成功，再进行访问/admin/hello接口，访问成功</p>
<p><img src="/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/3.png" alt="1604327236568"></p>
<h1 id="3-注销登陆配置"><a href="#3-注销登陆配置" class="headerlink" title="3.注销登陆配置"></a>3.注销登陆配置</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .logout()</span><br><span class="line">            .logoutUrl(<span class="string">"/logout"</span>)</span><br><span class="line">            .logoutSuccessHandler(<span class="keyword">new</span> LogoutSuccessHandler() &#123;<span class="comment">//注销成功的回调</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLogoutSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">"status"</span>,<span class="number">200</span>);</span><br><span class="line">                    map.put(<span class="string">"msg"</span>,<span class="string">"注销登录成功！"</span>);</span><br><span class="line">                    out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/4.png" alt="1604327611247"></p>
<p>此时为登录状态，访问/logout进行登录注销</p>
<p><img src="/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/5.png" alt="1604327662920"></p>
<p>再次访问/admin/hello，则需要再次登录</p>
<p><img src="/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/6.png" alt="1604327699659"></p>
<h1 id="4-多个HttpSecurity配置"><a href="#4-多个HttpSecurity配置" class="headerlink" title="4.多个HttpSecurity配置"></a>4.多个HttpSecurity配置</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多个HttpSecurity不再需要 extends WebSecurityConfigurerAdapter 只需注入configure方法</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiHttpSecurityConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">"xzs"</span>).password(<span class="string">"111"</span>).roles(<span class="string">"admin"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">"xxzs"</span>).password(<span class="string">"222"</span>).roles(<span class="string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个静态内部类</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="comment">//有多个HttpSecurity，就涉及到优先级问题</span></span><br><span class="line">    <span class="meta">@Order</span>(<span class="number">1</span>) <span class="comment">//数字越小优先级越大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 这种"/admin/**"格式的路径都要有admin权限</span></span><br><span class="line">            http.antMatcher(<span class="string">"/admin/**"</span>).authorizeRequests().anyRequest().hasAnyRole(<span class="string">"admin"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先跟上面匹配，匹配不上才找到这里</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin()</span><br><span class="line">                    .loginProcessingUrl(<span class="string">"/doLogin"</span>)</span><br><span class="line">                    .permitAll()</span><br><span class="line">                    .and()</span><br><span class="line">                    .csrf().disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-密码加密"><a href="#5-密码加密" class="headerlink" title="5.密码加密"></a>5.密码加密</h1><p><img src="/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/7.png" alt="1604330708908"></p>
<p>使用BCryptPasswordEncoder进行加密，生成一些加密密码，将这些加密密码进行替换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">"xzs"</span>).password(<span class="string">"$2a$10$GPZYsEzEes4vFndEhofmneACUmfFvD/KvgblGVL.I9YdzGmMdS6PC"</span>).roles(<span class="string">"admin"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">"xxzs"</span>).password(<span class="string">"$2a$10$Kr.ZQiC/ZGoQ.5Behtuh2u.SJNladI8Mf5XG6Q4O/2ilhuOWUNkTu"</span>).roles(<span class="string">"user"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这时登录仍是用123，但密码已经被加密加盐了</p>
<h1 id="6-方法安全"><a href="#6-方法安全" class="headerlink" title="6.方法安全"></a>6.方法安全</h1><p>在方法上添加注解确保方法的安全</p>
<p>先在配置类上加@EnableGlobalMethodSecurity注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>,securedEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiHttpSecurityConfig</span></span>&#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Service方法上添加注解</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodService</span> </span>&#123;</span><br><span class="line">	<span class="comment">//@PreAuthorize方法调用之后进行校验</span></span><br><span class="line">    <span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('admin')"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello admin!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Secured</span>(<span class="string">"ROLE_user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello user!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreAuthorize</span>(<span class="string">"hasAnyRole('admin','user')"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
  </entry>
  <entry>
    <title>Springboot整合RabbitMQ</title>
    <url>/2020/12/21/Springboot%E6%95%B4%E5%90%88RabbitMQ/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p> 他是一种异步通信方式，消息生产者在生产消息后，把消息保存到消息队列中，直到消息消费者来取走他。消息的生产者和消费者不需要同时和消息队列交互 </p>
<h1 id="2-启动"><a href="#2-启动" class="headerlink" title="2.启动"></a>2.启动</h1><p>使用docker快速启动rabbitmq</p>
<p>docker run -d  -P rabbitmq:3-management </p>
<p>docker run -d –name xzs-rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3-management </p>
<p>15672是管理端接口  5672是真正通信接口    -P随机映射到个接口  </p>
<p>5672映射到32771为通信接口 </p>
<p>15672映射到32769为管理端接口 </p>
<a id="more"></a> 

<h1 id="3-Springboot整合RabbitMQ"><a href="#3-Springboot整合RabbitMQ" class="headerlink" title="3.Springboot整合RabbitMQ"></a>3.Springboot整合RabbitMQ</h1><p>1.导入Web和RabbitMQ依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>2.配置RabbitMQ信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">192.168.199.171</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">32771</span></span><br></pre></td></tr></table></figure>

<h2 id="一、Direct"><a href="#一、Direct" class="headerlink" title="一、Direct"></a>一、Direct</h2><p>直接交换模式</p>
<p>配置DirectConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitDirectConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String DIRECTNAME = <span class="string">"xzs-direct"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">queue</span><span class="params">()</span></span>&#123;<span class="comment">//定义消息队列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"hello.xzs"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DirectExchange <span class="title">directExchange</span><span class="params">()</span></span>&#123;<span class="comment">//定义消息转换器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(DIRECTNAME,<span class="keyword">true</span>,<span class="keyword">true</span>);<span class="comment">//第二个参数：重启后是否有效，第三个参数：长期没有使用是否有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">binding</span><span class="params">()</span></span>&#123;<span class="comment">//把上面Queue和Exchange绑定到一起</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue()).to(directExchange()).with(<span class="string">"direct"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Exchange</p>
<p>再配置一个消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"hello.xzs"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"handler1 ----&gt;"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后使用RabbitTemplate进行发送消息即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringbootRabbitmqApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"hello.xzs"</span>,<span class="string">"hahahaha!xzs"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功接收到消息！</p>
<p><img src="/2020/12/21/Springboot%E6%95%B4%E5%90%88RabbitMQ/1.png" alt="01"></p>
<h2 id="二、Fanout"><a href="#二、Fanout" class="headerlink" title="二、Fanout"></a>二、Fanout</h2><p>所有到达Exchange的消息都转发到所有绑定到该Exchange的Queue</p>
<p>谁跟这个Exchange绑定了谁就能拿到消息</p>
<p>RabbitFanoutConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitFanoutConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String FANOUTNAME = <span class="string">"xzs-fanout"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">queue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.one"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">queue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.two"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(FANOUTNAME,<span class="keyword">true</span>,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">binding1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue1()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">binding2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue2()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FanoutReceiver消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"fanout.one"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"handler1 -------&gt;"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"fanout.two"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"handler2 -------&gt;"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用RabbitTemplate进行发送消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(RabbitFanoutConfig.FANOUTNAME,<span class="keyword">null</span>,<span class="string">"hello fanout！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和Exchange绑定的两个队列都拿到了消息。此时无需绑定routingKey</p>
<p><img src="/2020/12/21/Springboot%E6%95%B4%E5%90%88RabbitMQ/2.png" alt="02"></p>
<h2 id="三、Topic"><a href="#三、Topic" class="headerlink" title="三、Topic"></a>三、Topic</h2><p>Queue通过routingKey绑定到TopicExchange上，当消息到达TopicExchange时，TopicExchange会根据消息的routingKey把消息路由到一个或多个Queue上</p>
<p>RabbitTopicConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitTopicConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String TOPICNAME = <span class="string">"xzs-topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">xiaomi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"xiaomi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">huawei</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"huawei"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">phone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"phone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">TopicExchange <span class="title">topicExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(TOPICNAME,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">xiaomiBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(xiaomi()).to(topicExchange()).with(<span class="string">"xiaomi.#"</span>);<span class="comment">//以小米开头的消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">huaweiBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(huawei()).to(topicExchange()).with(<span class="string">"huawei.#"</span>);<span class="comment">//以小米开头的消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">phoneBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(phone()).to(topicExchange()).with(<span class="string">"#.phone.#"</span>);<span class="comment">//以小米开头的消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TopicReceiver消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"xiaomi"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TopicReceiver  handler1 -------&gt;"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"huawei"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TopicReceiver  handler2 -------&gt;"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"phone"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler3</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TopicReceiver  handler3 -------&gt;"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用RabbitTemplate进行发送消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Testvoid</span> test2() &#123;    rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME,<span class="string">"xiaomi.news"</span>,<span class="string">"小米新闻"</span>);    rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME,<span class="string">"vivo.phone"</span>,<span class="string">"vivo手机"</span>);    rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME,<span class="string">"huawei.phone"</span>,<span class="string">"华为手机"</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>根据发送消息的routingKey进行消息路由转发</p>
<p>小米新闻就路由给了xiaomi队列</p>
<p>vivo手机就路由给了phone队列</p>
<p>华为手机就路由给了huawei队列和phone队列</p>
<p><img src="/2020/12/21/Springboot%E6%95%B4%E5%90%88RabbitMQ/3.png" alt="03"></p>
<p><img src="/2020/12/21/Springboot%E6%95%B4%E5%90%88RabbitMQ/4.png" alt="04"></p>
<h2 id="四、Header"><a href="#四、Header" class="headerlink" title="四、Header"></a>四、Header</h2><p> 消息的Header中只要有一个Header匹配上map的key-value，就把这个消息路由到对应的Queue上去 </p>
<p>RabbitHeaderConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitHeaderConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADERNAME = <span class="string">"xzs-header"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">queueName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"name-queue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">queueAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"age-queue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">HeadersExchange <span class="title">headersExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeadersExchange(HEADERNAME, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"name"</span>, <span class="string">"xzs"</span>);</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueName()).to(headersExchange()).whereAny(map).match();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueAge()).to(headersExchange()).where(<span class="string">"age"</span>).exists();<span class="comment">//只要你有age这个字段我就路由到age-queue上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeaderReceiver：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"name-queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler1</span><span class="params">(<span class="keyword">byte</span>[] msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HeaderReceiver:handler1 --------&gt;"</span> + <span class="keyword">new</span> String(msg, <span class="number">0</span>, msg.length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"age-queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler2</span><span class="params">(<span class="keyword">byte</span>[] msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HeaderReceiver:handler2 --------&gt;"</span> + <span class="keyword">new</span> String(msg, <span class="number">0</span>, msg.length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用RabbitTemplate进行发送消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Message nameMsg = MessageBuilder.withBody(<span class="string">"hello Header !"</span>.getBytes()).setHeader(<span class="string">"name"</span>,<span class="string">"xzs"</span>).build();</span><br><span class="line">    Message ageMsg = MessageBuilder.withBody(<span class="string">"hello Header99 !"</span>.getBytes()).setHeader(<span class="string">"age"</span>,<span class="string">"99"</span>).build();</span><br><span class="line">    rabbitTemplate.send(RabbitHeaderConfig.HEADERNAME, <span class="keyword">null</span>, ageMsg);</span><br><span class="line">    rabbitTemplate.send(RabbitHeaderConfig.HEADERNAME, <span class="keyword">null</span>, nameMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各自路由到各自的消息队列中去</p>
<p><img src="/2020/12/21/Springboot%E6%95%B4%E5%90%88RabbitMQ/5.png" alt="05"></p>
]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
  </entry>
  <entry>
    <title>变量、数据类型</title>
    <url>/2021/01/18/%E5%8F%98%E9%87%8F%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h1><h2 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a>什么是变量？</h2><p>变量是计算机语言中的一个概念，可以表示一个具体的数值，同时这个值是可以改变的。</p>
<h2 id="为什么要使用变量？"><a href="#为什么要使用变量？" class="headerlink" title="为什么要使用变量？"></a>为什么要使用变量？</h2><p>100 元买了一款理财产品，年利率 3%，计算你年底的收益。</p>
<p>100</p>
<p>3%</p>
<p>乘法运算</p>
<p>1、需要在电脑中存储 100 和 3% 这两个数据。</p>
<p>2、将两个数据进行乘法运算。</p>
<p>计算机如何存储数据？</p>
<p>计算机将数据存储在内存中的，内存会为不同的数据开辟不同的空间来存储。</p>
<p><strong>每一块内存都有一个独一无二的地址</strong>，我们通过内存地址找到对应的内存，进而取出内存中存储的数据。</p>
<p>内存地址是一个十六进制的数据，0x6fff5cde3d6c</p>
<p><strong>内存地址不便于记忆，如何解决？通过变量解决</strong></p>
<p>因为内存地址不好记，我们就自定义一个好记的名字来代替内存地址，<strong>指向内存区域。</strong></p>
<a id="more"></a>

<h2 id="如何使用变量"><a href="#如何使用变量" class="headerlink" title="如何使用变量"></a>如何使用变量</h2><p>1、声明变量的数据类型和变量名（可以包含数字、字母、下划线、$，不能包含空格、运算符，不能用纯关键字来命名，不能以数字开头、大小写可以混用，驼峰式命名法：第一个单词全部小写，从第二个单词开始，首字母大写，后面全小写，userId、firstName、studentNum、studentSecondNum）</p>
<p>2、给内存空间赋值，这个值就是变量的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//100</span></span><br><span class="line">        <span class="comment">//1、开辟内存空间，int，变量名 num1</span></span><br><span class="line">        <span class="keyword">int</span> num1;</span><br><span class="line">        <span class="comment">//2、赋值</span></span><br><span class="line">        num1 = <span class="number">100</span>;</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-Java-中的数据类型"><a href="#2-Java-中的数据类型" class="headerlink" title="2.Java 中的数据类型"></a>2.Java 中的数据类型</h1><h2 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h2><p>数值类型、非数值类型</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1个字节（byte）8 bit</td>
</tr>
<tr>
<td>int</td>
<td>4个byte 32bit</td>
</tr>
<tr>
<td>short</td>
<td>2个byte 16bit</td>
</tr>
<tr>
<td>long</td>
<td>8个byte 64bit</td>
</tr>
<tr>
<td>float</td>
<td>4个byte 32bit</td>
</tr>
<tr>
<td>double</td>
<td>8个byte 64bit</td>
</tr>
<tr>
<td>char</td>
<td>2个byte 16bit</td>
</tr>
<tr>
<td>boolean</td>
<td>1 bit，1/8 byte</td>
</tr>
</tbody></table>
<p>int、double、boolean、String（引用类型）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ 既可以表示拼接也可以表示运算</span><br><span class="line">如果 + 左右两边至少有一边是字符串，就是拼接，将不是字符串的数据转成字符串，然后将两个字符串进行拼接</span><br><span class="line">否则就进行算术加法运算</span><br><span class="line">如果 + 左右两边是字符，而不是字符串，则不是拼接，将字符转为对应的 ASCII 码（数值），再进行加法运算</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">        String name = <span class="string">"张三"</span>;</span><br><span class="line">        System.out.println(<span class="string">"用户信息"</span>);</span><br><span class="line">        System.out.println(<span class="string">"编号："</span> + id);</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + name);</span><br><span class="line">        System.out.println(<span class="string">'A'</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>双亲委派模型</title>
    <url>/2021/01/19/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>ClassLoader</p>
<p>1、BootstrapClassLoader java包中的核心类库</p>
<p>2、ExtClassLoader javax包中的扩展类库</p>
<p>3、AppClassLoader 程序员自己写的类</p>
<p>4、自定义 ClassLoader</p>
<p>手写一个自定义 ClassLoader，反射</p>
<p>ClassLoader 的作用是将<strong>字节码文件</strong>加载到内存中</p>
<p>两个核心方法：findClass、defineClass</p>
<p>findClass：通过某种方法找到目标文件</p>
<p>defineClass：加载目标文件</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的类加载器</span></span><br><span class="line"><span class="comment"> * 功能：根据字节码文件的绝对路径来找到它，并完成加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存目标文件所在的目录</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，创建一个MyClassLoader对象的，在创建的同时将绝对路径存起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//定义我们加载字节码的逻辑</span></span><br><span class="line">        String classPath = <span class="keyword">this</span>.path+name+<span class="string">".class"</span>;</span><br><span class="line">        <span class="comment">//IO流读取</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(classPath);</span><br><span class="line">            outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((temp = inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                outputStream.write(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = outputStream.toByteArray();</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义类加载器，重写 findClass 方法，通过 IO 流读取本地编译好的字节码文件，生成字节数组，再将字节数组传给 ClassLoader 的 defineClass 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建MyClassLoader的对象</span></span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"D:\\java\\"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过findClass找到目标字节码文件，抽象成clazz对象</span></span><br><span class="line">            Class clazz = myClassLoader.findClass(<span class="string">"HelloWorld"</span>);</span><br><span class="line">            System.out.println(clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>类在 JVM 中加载的规则，任何一个类只需要在 JVM 中加载一次，不需要重复加载。</p>
<p>加载一个类的时候，首先从自定义的加载器开始查找，看它有没有加载过这个类，如果加载过，则直接返回，如果没有加载过，怎么办？就委派给 AppClassLoader 去加载。</p>
<p>开始查找 AppClassLoader 有没有加载过这个类，如果加载过，直接返回，否则委派给 ExtClassLoader 去加载，重复上述过程，直到委派给 BootstrapClassLoader，如果加载过，直接返回，如果此时还是没有加载，就会逆向加载，将整个过程反过来</p>
<p>BootstrapClassLoader –&gt; ExtClassLoader –&gt; AppClassLoader –&gt; 自定义 ClassLoader</p>
<p>如果还是没有加载到，就会抛出 ClassNotFoundException。</p>
<p><img src="/2021/01/19/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/1.png" alt="1611035147371"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz1 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">        System.out.println(clazz1);</span><br><span class="line">        Class clazz2 = Class.forName(<span class="string">"javax.sql.DataSource"</span>);</span><br><span class="line">        System.out.println(clazz2);</span><br><span class="line">        Class clazz3 = Class.forName(<span class="string">"com.southwind.test.User"</span>);</span><br><span class="line">        System.out.println(clazz3);</span><br><span class="line"></span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"D:\\java\\"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过findClass找到目标字节码文件，抽象成clazz对象</span></span><br><span class="line">            Class clazz4 = myClassLoader.findClass(<span class="string">"HelloWorld"</span>);</span><br><span class="line">            System.out.println(clazz4);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class clazz5 = Class.forName(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(clazz5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看源码 loadClass 加载类的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//上锁，避免多线程导致类重复加载</span></span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="comment">//c==null，表示没有加载过</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//判断它的父加载器是否为 null</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//委托父加载器进行加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果父加载器==null，说明到了顶层，Bootstarp加载器加载该类</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">//如果还是没有加载到，调用Bootstrap的findClass加载</span></span><br><span class="line">                <span class="comment">//依次向下发展</span></span><br><span class="line">                <span class="comment">//如果还是找不到则抛出ClassNotFoundException异常</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2021/01/20/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射非常重要，它是<strong>动态</strong>语言的关键。</p>
<p>动态语言就是<strong>不写死</strong>，而是根据程序的具体执行情况做出不同的变化。</p>
<p>反射概念很抽象</p>
<p>日常生活中的反射：照镜子可以反射物体的形态</p>
<p>都是通过一个虚像可以映射到一个事物，可以直接获取实物的某些特征。</p>
<p>程序中的反射是通过某些信息（对象、类名 “java.lang.String”）可以映射到类，在程序运行期间获取类的相关信息。</p>
<p>反射的工作都是在程序运行期间进行的</p>
<p>反射具体操作简单来说就是在程序运行期间，<strong>动态获取类的信息</strong>，从而完成某些操作。</p>
<p>常规情况下，是通过类创建对象，反射就是将其进行反转，通过对象来获取类的信息。</p>
<a id="more"></a>

<h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><p>Class 类是反射的源头，反射就是获取某些类的信息，<strong>抽象出一个对象来表示类的信息</strong>，Class 就是用来创建这些对象的类。</p>
<p>Class 的实例化对象是专门用来描述其他类，Class 是专门用来描述其他类的类。</p>
<p>Class构造器是私有的，不能new出实例化对象。因为实例化对象需要描述一个其他类，这是必须给定的，不可能让你随便new出来，这样子根本不知道他用来描述哪一个类</p>
<p>如何获取 Class 的实例化对象？一共有 3 种方式，都跟目标类有关系。</p>
<p><strong>1、通过类名获取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class aClass = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">        System.out.println(aClass);</span><br><span class="line">        Class&lt;?&gt; aClass1 = Class.forName(<span class="string">"java.io.Serializable"</span>);</span><br><span class="line">        System.out.println(aClass1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、通过类字面量获取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class class2 = String<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>3、通过类的实例化对象获取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class class3 = str.getClass();</span><br></pre></td></tr></table></figure>

<p>无论通过哪种方式获取的 Class 对象都是同一个，为什么呢？</p>
<p>Java 中的类只会加载一次，加载到 JVM 内存中类叫做“<strong>运行时类</strong>”，Class 对象就是运行时类映射出来的一个对象。</p>
<h2 id="获取类的结构"><a href="#获取类的结构" class="headerlink" title="获取类的结构"></a>获取类的结构</h2><p>类的结构包括：成员变量、方法、构造函数、继承的父类、实现的接口等等。</p>
<p>Constructor 是 Java 反射包提供的一个类，它的作用是专门用来描述其他类的构造器的，一个 Constructor 实例化对象映射的就是某个类的某个构造函数。</p>
<blockquote>
<p>构造器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor[] constructors = clazz.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"*****************************************"</span>);</span><br><span class="line">Constructor constructor = clazz.getConstructor();</span><br><span class="line">System.out.println(constructor);</span><br><span class="line">constructor = clazz.getConstructor(Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(constructor);</span><br><span class="line">constructor = clazz.getConstructor(Integer<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(constructor);</span><br><span class="line">System.out.println(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"a"</span>));</span><br><span class="line">System.out.println(constructor.newInstance(<span class="number">1</span>,<span class="string">"a"</span>));</span><br></pre></td></tr></table></figure>

<p>你并不知道其他人要用哪个类，通过反射即可实现动态的让别人使用，下面是反射的一个应用，动态地创建各类对象，用户传什么全类名就创建该类对象</p>
<p><img src="/2021/01/20/%E5%8F%8D%E5%B0%84/1.png" alt="1611142446180"></p>
<p><img src="/2021/01/20/%E5%8F%8D%E5%B0%84/2.png" alt="1611142486849"></p>
<blockquote>
<p>接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class clazz = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class anInterface : interfaces) &#123;</span><br><span class="line">            System.out.println(anInterface);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态代理（Proxy）</strong>机制，给目标类找一个代理去完成工作，代理类不是提前写好的，而是程序运行时动态生成的，动态生成的代理类和目标类肯定是有关联的，代理类必须具备目标类的功能。</p>
<p>Java 中如何描述功能？用接口描述，在动态生成类的时候，需要参照目标类的接口来生成这个动态代理类。</p>
<blockquote>
<p>属性（成员变量）</p>
</blockquote>
<p>getFields() 方法获取的是类中的<strong>公有成员变量</strong>（包括从父类继承过来的公有成员变量），public 修饰的</p>
<p>getDeclaredFields() 方法获取的是类中<strong>全部成员变量</strong>（跟修饰无关，但是不包含父类中的成员变量）</p>
<p>getField(String name) <strong>根据名称</strong>获取公有成员变量（包含父类继承过来的）</p>
<p>getDeclaredField(String name) 根据名称获取成员变量（不包含父类继承过来的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常规方式</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.id = <span class="number">1</span>;</span><br><span class="line">System.out.println(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射方式</span></span><br><span class="line">Field id = clazz.getField(<span class="string">"id"</span>);</span><br><span class="line">id.set(user, <span class="number">2</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>

<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Field id = clazz.getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        <span class="comment">//赋值 取值</span></span><br><span class="line">        Constructor&lt;User&gt; constructor = clazz.getConstructor(<span class="keyword">null</span>);</span><br><span class="line">        User user = constructor.newInstance(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//暴力反射</span></span><br><span class="line">        id.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        id.set(user, <span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Field id = clazz.getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        <span class="comment">//赋值 取值</span></span><br><span class="line">        Constructor&lt;User&gt; constructor = clazz.getConstructor(<span class="keyword">null</span>);</span><br><span class="line">        User user = constructor.newInstance(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//暴力反射</span></span><br><span class="line">        id.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object o = id.get(user);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class clazz = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getMethods 方法获取目标类中的所有公有方法，<strong>包含从父类继承过来的公有方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">    System.out.println(declaredMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getDeclaredMethods 方法获取目标类中的所有方法，<strong>不包含</strong>从父类继承过来的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//        Method[] methods = clazz.getMethods();</span></span><br><span class="line"><span class="comment">//        for (Method method : methods) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(method);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        Method[] declaredMethods = clazz.getDeclaredMethods();</span></span><br><span class="line"><span class="comment">//        for (Method declaredMethod : declaredMethods) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(declaredMethod);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        Method getId = clazz.getDeclaredMethod(<span class="string">"getId"</span>, <span class="keyword">null</span>);<span class="comment">//方法存在重载，所以要传参数</span></span><br><span class="line">        User user = (User) clazz.getConstructor(<span class="keyword">null</span>).newInstance(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        Method setId = clazz.getMethod(<span class="string">"setId"</span>, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        setId.invoke(user, <span class="number">22</span>);<span class="comment">//invoke让方法去执行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//取值</span></span><br><span class="line">        System.out.println(getId.invoke(user, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射机制在实际开发中最主要的三个应用构造器、方法、成员变量。</p>
<p>Spring 框架，IoC 容器，自动创建对象，不需要开发者手动创建对象，程序根据配置文件自动生成程序需要的各种对象。</p>
<p>1、通过构造器创建对象</p>
<p>2、给对象的属性赋值</p>
<h2 id="反射应用之—动态代理"><a href="#反射应用之—动态代理" class="headerlink" title="反射应用之—动态代理"></a>反射应用之—动态代理</h2><p>代理(Proxy)模式是一种常用的 Java 设计模式，代理模式是指处理一个业务逻辑时，通过代理的方式完成。</p>
<p>代理模式中包含被代理方（委托方），和代理方，委托方委托代理帮助他完成某些工作。</p>
<p>在所有的代理模式中，委托方和代理方都有一个共性，即双方都具备完成需求的能力。</p>
<p>Java 程序中如何描述这个关系？将类所具备的能力封装成接口，<strong>Java 委托类和代理类需要实现同一个接口</strong>。</p>
<p>代理类和委托类是通过依赖注入进行关联，在设计程序时需要将委托类定义为代理类的成员变量，</p>
<p>1、所有的操作全部在代理类中完成</p>
<p>2、核心业务操作还是由委托类本身完成</p>
<p>3、代理类完成其他非核心工作</p>
<p>4、委托类需要作为成员变量注入到代理类中</p>
<p>代理模式又可以分为静态代理和动态代理，两者的区别在于静态代理需要提前编写好代理类的代码，在编译期间代理类的 class 文件就已经生成了，代码是写死的。</p>
<p>动态代理是指编译期间代理类的代码不确定，而是在程序运行期间根据代码的指示动态生成的，代码不是写死的，而是灵活变通的。</p>
<p>静态代理和反射没有任何关系，动态代理是需要通过反射机制来实现灵活性的。</p>
<p>静态代理代码如下：</p>
<p>1、创建接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">salePhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建委托类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">salePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"销售iPhone手机"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWei</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">salePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"销售华为手机"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneProxy</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Phone phone;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhoneProxy</span><span class="params">(Phone phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">salePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打广告、宣传等其他代理业务操作"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.phone.salePhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PhoneProxy phoneProxy = <span class="keyword">new</span> PhoneProxy(<span class="keyword">new</span> Apple());</span><br><span class="line">        System.out.println(phoneProxy.salePhone());</span><br><span class="line">        phoneProxy = <span class="keyword">new</span> PhoneProxy(<span class="keyword">new</span> HuaWei());</span><br><span class="line">        System.out.println(phoneProxy.salePhone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个厂商，既可以卖代理卖手机，也可以代理卖汽车，未来还可能代理卖别的东西。</p>
<p><strong>动态代理：</strong></p>
<p>需求：</p>
<p>要求提供这样一种机制，可以为各种委托类实现代理机制。</p>
<p>1、肯定需要包含目前项目中已经存在的委托类（销售手机、销售汽车）</p>
<p>2、同时还要具备非常好的扩展性，这套程序写好之后，如果后期有新的委托类（销售房子）</p>
<p>代码完全不需要修改，还可以完成代理机制。</p>
<p>动态代理机制可以实现上述需求，简单理解就是代理类不是提前写好的，根本就不存在，而是程序运行期间动态生成的，（JDK 动态代理）</p>
<p>开发程序的时候只需要写一个辅助类，辅助动态代理机制动态生成真正的代理类。</p>
<p>就是动态生成代理类的功能，<strong>Java 中如何让一个类具备某种功能？</strong></p>
<p>Java 中用接口定义功能，只需要让目标类实现该接口，目标类就具备了相应的功能。</p>
<p>java.lang.reflect.InvocationHandler</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassLoader loader,</span><br><span class="line">Class&lt;?&gt;[] interfaces,</span><br><span class="line">InvocationHandler h &#x2F;&#x2F;InvocationHandler实例</span><br></pre></td></tr></table></figure>

<p>借助于辅助对象 MyInvocationHandler 动态创建代理类，进而创建代理对象</p>
<p>动态创建一个类，代理类，替代委托类完成某些工作的，这个代理类就需要实现委托类的接口。</p>
<p>动态创建代理类的时候，必须结合委托类的接口来创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录委托对象</span></span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入委托对象</span></span><br><span class="line">    <span class="comment">//返回动态创建的代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                MyInvocationHandler<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),//类加载器</span></span><br><span class="line"><span class="class">                <span class="title">object</span>.<span class="title">getClass</span>().<span class="title">getInterfaces</span>(),//委托对象接口</span></span><br><span class="line"><span class="class">                <span class="title">this</span>)</span>;<span class="comment">//InvocationHandler实例，就可以用当前对象this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//invoke通过反射机制来完成方法调用的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start proxy model"</span>);</span><br><span class="line">        <span class="comment">//委托对象调用核心业务方法</span></span><br><span class="line">        Object result = method.invoke(<span class="keyword">this</span>.object, args);<span class="comment">//通过反射传入委托对象调用核心业务</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        //委托对象</span></span><br><span class="line"><span class="comment">//        Phone phone = new HuaWei();</span></span><br><span class="line"><span class="comment">//        //获取代理</span></span><br><span class="line"><span class="comment">//        MyInvocationHandler handler = new MyInvocationHandler();</span></span><br><span class="line"><span class="comment">//        Phone proxy = (Phone) handler.bind(phone);</span></span><br><span class="line"><span class="comment">//        System.out.println(proxy.salePhone());</span></span><br><span class="line"></span><br><span class="line">        Car car = <span class="keyword">new</span> BMW();</span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line">        Car proxy = (Car) handler.bind(car);</span><br><span class="line">        System.out.println(proxy.saleCar());<span class="comment">//调用代理对象方法时会自动地通过反射机制来获取到proxy里的方法，然后自动进到invoke方法中</span></span><br><span class="line">        System.out.println(proxy.add(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总体流程：</strong></p>
<p>1.创建各个实例化对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Phone phone = <span class="keyword">new</span> HuaWei();</span><br><span class="line">MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br></pre></td></tr></table></figure>

<p>2.通过bind()方法创建代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Phone proxy = (Phone) handler.bind(phone);</span><br></pre></td></tr></table></figure>

<p>3.调用代理对象的方法，会自动地通过反射机制来获取到proxy里的方法，然后自动进到invoke方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">proxy.salePhone()</span><br><span class="line">然后跳到invoke方法</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"start proxy model"</span>);</span><br><span class="line">    <span class="comment">//委托对象调用核心业务方法</span></span><br><span class="line">    Object result = method.invoke(<span class="keyword">this</span>.object, args);<span class="comment">//通过反射传入委托对象调用核心业务</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>代码进阶之路</title>
    <url>/2020/05/12/%E4%BB%A3%E7%A0%81%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="对于自我职业规划的问题"><a href="#对于自我职业规划的问题" class="headerlink" title="对于自我职业规划的问题"></a>对于自我职业规划的问题</h3><p>许多人对于自己的一条完整的职业规划之路没有一个清晰的认知，但若你想从一个普通学生变成IT界、大厂里的大牛，往往需要经历什么才从能青铜走向王者呢？</p>
<h4 id="1-青铜——万恶之源"><a href="#1-青铜——万恶之源" class="headerlink" title="1.青铜——万恶之源"></a>1.青铜——万恶之源</h4><p>首先是《计算机基础》这本书，在计算机基础中我们会学到计算机的历史、计算机的特点、进制转换、内存管理、线性数据结构、网络请求协议等等。<br>计算机基础真心很重要，无比重要，究极重要，为啥我这么说呢，里面涉及的计算机知识还有很多网络协议的知识，大家以后一定会用到，我可以负责的告诉你，面试也一定会问，什么Http、Https、Tcp/Ip、三次握手、四次挥手面试不要太常问。<a id="more"></a><br>        Tip：这里有个小插曲就是我身边那个架构师团队Leader这周面试阿里p8岗位的时候，我以为问的都是什么源码，中间件的究极操作，我想大家跟我想的一样，但是大家错了，反而问的很多计算机的基础知识。我聊天大概问了一下面试内容，有什么求二叉树的镜像，内核态和用户态的理解，计算机的缓存页等。 大家是不是惊了，这他*不是我校招的题目么？怎么P8级别的大佬还问这个？其实很好理解，大家想一下到了一定的工作年限技术的广度深度都有一定的造诣了，你写代码就这样了没办法优化了，机器配置也是最好的了，那还能优化啥？<br>        底层！我们都知道所有语言到最后要运行都是变成机器语言的，最后归根究底都是要去跟机器交互的，那计算机的底层是不是最后还是要关注的东西了？<br>        学完计算机基础你基本上对计算机的整个知识体系都一知半解了，对于编程或许还是很懵懂，但是你现在已经要踏入编程的门了。 </p>
<h4 id="2-白银——编程第一课"><a href="#2-白银——编程第一课" class="headerlink" title="2.白银——编程第一课"></a>2.白银——编程第一课</h4><p>计算机基础学了，后面就要编程的入门课程了。想必看我这篇文章有99%的小伙伴都是以下面这段代码开始的自己的程序人生的吧：我还记得大一上开始学习的C语言，《C语言程序设计》课本，在第27页就是第一章，HelloWord，现在回忆起来还历历在目，老师在黑板上写下这两个庄严的单词，同桌的他和我露出无限的求知欲……<br>        我想所有的语言都是语法基础开始的，而且编程语言的基础语法也都是大同小异的。If、For、While等关键字，List、Set、Map等集合，Int、float、Double等基础类型，大家第一次学的时候我想也不会知道，这些关键字将会陪伴我们走完各自的程序生涯吧？<br>        接下去就难一点比如JDBC、IO、文件流啊什么的，依稀的记得当时还是代码里面写SQL然后查询，也不知道记错没有。<br>        学到这里，你可能觉得你JavaSE无敌，出去可以找工作了，反正当时的帅丙，觉得自己可以闯出一片天了，不知天高地厚，四处炫技。但是幼稚的我根本不知道，未知的前方还有什么等着我，我也不知道自己其实才刚入门，但是如果要往WEB方向发展，这些倒是基本足够了。但是你到现在为止学的东西都是服务端的东西呀，怎么让你的服务端东西展示给别人看呢？<br>        这个时候我们就应该去做个丑不拉几的页面，进行简单的交互了，你这个时候要学HTML 、Servlet、MySQL、 JavaScript、Tomcat、CSS等。目标呢就是写出第一个动态网站，也许只是个登陆功能，只能展示下个人资料，但这是很重要的一步，你要弄清楚的是，一个用户的点击产生的请求，是从哪里发起，哪里接收，哪里处理，哪里返回，你得理解浏览器和服务器的关系和分工，Cookie和Session，Request和Response。<br>        Tip：我记得我刚出来面试就有面试题是这样的，一个Http请求从网页发起到服务端产生数据返回中间经历了些什么，或者Spring做了什么？大家可以思考一下<br>         还有有一个自己的项目真心很重要，我就是在大学期间做了项目，至今在校园内网上稳定运行着，出来实习面试的时候基本上也是一路披荆斩棘，吊打了同行面试的仔，反正大学有个项目贼加分，是读者的大学生记住了么？</p>
<h4 id="3-黄金——初出茅庐"><a href="#3-黄金——初出茅庐" class="headerlink" title="3.黄金——初出茅庐"></a>3.黄金——初出茅庐</h4><p>上面的只是WEB开发的学习初级阶段，这都是些JAVA诞生以来最原始的最官方的WEB开发技术，当然现在真正的项目很少直接采用这些技术了，现在都是前后端分离了，Vue、Node.js、React等前端的语言更新迭代速度非常快，我学了一点刚用舒服，前端的朋友告诉我又迭代了……我他喵的不学了！<br>        为了不断提高技术的易用性、开发效率和可维护性、可扩展性，无数开源项目都是在这些原始技术的基础上封装、改进。<br>        所以这个阶段不要盲目乐观地跑去找工作或者对实习挑三拣四，你会被打击到的，又或者找个小公司浑浑噩噩几年过去感觉跟新的技术栈脱节。<br>        有人跟你说小公司学的东西多，他害你的，刚开始能去多大的去多大的，越大越好，你想你去了大的你想去小的分分钟的事情，但是你小的要去大的就相对难了。<br>        好，初始阶段完成，开始进入WEB开发的正题，首先是传说中的框架，SSM（Spring SpringMVC Mybatis）成为熟练的增删改查程序员是必须的，在这个阶段你还要理解为什么要用这仨而不是那些Jsp、Servlet、Jdbc，你要体会到写MVC、三层架构的好处。<br>        这个阶段不要轻易质疑框架的价值，也许刚开始你会觉得麻烦，觉得他们有时候是多此一举，我最开始这么写的时候发现，真的恶心，什么dao，service，Controller等等，分这么多干嘛。等过一两年后回过头来你会觉得少了这些框架你已经很难干活了，没有分层清晰的系统，你反而开口大骂项目的架构师的。不过要提醒大家的是，这个阶段还要避免的心态是，能熟练地增删改查了，就自认为写程序不过如此，然后往简历上填个精通，这也是新手面试被批得体无完肤的原因之一。<br>        浅尝即止，是新手的大忌，为啥这么写，这么写有啥好处，有啥坏处，多问几个为什么，你多年后会感谢敖丙的。<br>        如果你学得好，这会应该能熟练地写个博客啊，小论坛啊之类的WEB项目了，也就是达到了就业的基本要求。<br>        Tip：而且说一下作为一个应届生，你除了基础知识，如果你有自己的技术博客，还有像样的项目能展示给面试官看，是真的很加分，搭建个简单的项目，项目流程你也知道了，技术栈也熟悉了，还可以手机访问网页给面试官现场演示，很加分的。<br>        像我身边的朋友Java3y，JavaGuide，我没有三颗心脏等，就是在这个阶段就已经开始写了自己的博客，并且各自都做出了成绩，这些以后都是你面试的议价能力的一部分，也是你的加分项，和你自身的财富。我问了一下他们，都是靠博客就已经得到不少大公司的面试邀约了，反正有项目，有不错的履历，有不错的博客，都会给你加分，如果你什么都没有，现在动手去多学点，少打两局LOL等你到我这个年纪就会发现，索然无味。</p>
<h4 id="4-铂金——遵义会议"><a href="#4-铂金——遵义会议" class="headerlink" title="4.铂金——遵义会议"></a>4.铂金——遵义会议</h4><p>这会是程序员生涯的一个转折点，把握好了人生起飞，把握不好全盘皆输，所以我用具有重要转折点历史意义的遵义会议，作为这阶段的标题，我觉得，妙啊！<br>        慢慢的你会发现数据库性能实在不行，出于不甘现状，或者赶时髦，你该去了解NoSQL了，Memcached、Redis、Mongodb等非关系型数据库眼花缭乱，没关系，试着用用，能很好地缓解MySQL、Oracle之类关系数据库的压力。<br>        出于公司某些业务需要，你可能会钻研一个特定技术领域，比如全文搜索技术ElasticSearch（以下简称Es），那你了解了Es，你又要想到数据库的数据怎么同步进Es呢？<br>        你可能会接触到Logstash，Canal等中间件，然后发现可视化也是个问题，那Kibana就应运而生，用的时候发现欧洲人的分词习惯跟我们不一样，那Ik中文分词器又得了解啦。使用之后你还会发现他底层的Lucene有很多坑要怎避免，时间多你还可以了解Solr等等。<br>        总之知识就是一个体系，我经常跟群里的仔说，形成知识体系，你面试说了Es那相关的技术栈你一样要了解的，我题目取了叫《吊打面试官》就是噱头，你去面试如果面试官技术深度真的很深，我想被吊打的100%是你。<br>        你甚至会开始对系统中一些比较特殊的存在感兴趣，比如权限系统，单点登陆之类的，又或者某些特定业务领域的算法研究，这些是你的加分项。<br>        你还发现服务拆分后Http通信有诸多弊端，就开始接触优秀的Rpc框架还有消息队列中间件了，如Dubbo、RocketMQ等。<br>        再再后来你发现呀，数据量大得一批，表顶不住了，几亿数据查出来要好几秒，那分库分表就出来，什么水平拆分，垂直拆分，还学习了TDDL、Sharding-JDBC、DRDS等这样的分库分表中间件。但是你用了发现全局的唯一id生成又是一个问题，或许中间件有自带的，但是你还是要了解原理，什么雪花算法，uuid等等也得学。<br>        再再再后来呀，你发现分库分表也顶不住了，业务体量爆炸式增长了，你可能就需要了解动态分库分表的解决思路和解决方案了，特别是FaceBook开源的一些方案。<br>        再再再再后来呀，你发现动态分库分表也不行啊，很多离线的数据也很多啊，每天几个T，公司都要被败光了，那你就要了解大数据场景的离线分析啊，数据缓存啊，数据清洗，数据可视化等等啊什么的。那就需要学什么ODPS啊，Hadoop、Hive、Hbase等等中间件或者工具了。<br>        再再再再再后来你开始发现你的代码很乱，久了以后自己都看不懂，重复的，难以重用的代码堆积如山，不想维护，BUG百出。于是你要开始重视设计模式，合理地改造下自己的代码习惯，不再被僵化的SSH、MVC三层架构束缚住。<br>        再再再再再再…..<br>        到这里不知道你有没有体会到我每篇文章开头那句话的意思？就是工作之后发现自己越来越无知了，你再品一下下面这句话。<br>        你知道的越多，你不知道的越多<br>        Google和各种资料是你进步的动力，极少再遇到必须请教别人才能解决的问题，如果你这个阶段还老是问别人，你的技术生涯也就快到头了。<br>        这个阶段，如果你技术卓越和跟敖丙一样能吹，你的收入将是白领水平，至少接近了，或者大幅领先同龄人了。<br>        我觉得多数程序员在工作多年之后都能达到这个水平，有的人只需要一两年，有的人却要用上五六年，在这个阶段落伍的人，有的是出于天赋和思维所限，有的是出于对技术缺乏热情，有的是出于工作内容的制约。<br>等到年近中年，再也拼不过年轻人，被淘汰出局，只能在自嘲为屌丝和码农的无奈中黯然转行。<br>        这是个很重要的分水龄，你能不能继续进步，能不能在30岁以后继续从事技术工作，能不能在公司里独当一面，我觉得就看你能不能超越这个阶段了。<br>        很多烂公司里工作数年的项目经理，连这个层次都还没达到…<br>        为了30岁的自己听到裁员完全不虚，为了家里的老母亲不再为了省电费不舍得开灯，为了让自己……<br>        我想这个阶段你应该要做好准备，这也是我大篇幅介绍这个阶段的原因。</p>
<h4 id="5-钻石——扬帆起航"><a href="#5-钻石——扬帆起航" class="headerlink" title="5.钻石——扬帆起航"></a>5.钻石——扬帆起航</h4><p>你要读读优秀开源项目的源码，你要搞懂一些当年不懂的基础知识，你开始理解《thinking in java》的精髓，你能写一些底层的代码，有时还会觉得自己封装的比某些开源工具更好用更简单。<br>        当年看不懂的《深入分析JVM虚拟机》现在你已经可以对里面的知识点如数家珍，张口就来，并且能够将大量知识点带入到项目中优化，并且能够看到实质性的变化（暗示KPI）。<br>        WEB的难点和重点永远都在于性能、负载能力上，而现在网络的发达造成了数据量和操作密度的大大上升，硬件却没有相应的进步。<br>        你得试着更好地运用更多的服务器来协同工作，从WEB端到服务端到数据库，全都需要集群，需要分布式，需要合理的控制数据的流向，掌握好网站上下，一大堆机器的平衡，找出性能的瓶颈，找出稳定性和安全性的瓶颈，硬件出现故障，第三方技术出现错误，将被当成家常便饭融入到你的系统和代码里仔细考虑。你会开始觉得方案无比地重要，一将无能累死千军将不断应验，一个不好的设计，一个不好的方案，会让一群优秀的程序员工作成果大打折扣。<br>        你要关注架构知识，不能再满足于SSH三层架构到底。领域驱动设计，面向事件开发，敏捷开发等等一系列的思想在关键时刻能决定你项目的生死，这个阶段不再有标准范例让你照抄，你只知道思想和原理，实践却需要自己不断尝试和改进。<br>        多关注各种杂七杂八的开源技术，有些你可能前面已经接触过了，和通信有关的，和集成开发环境有关的，和架构有关的，各个领域你都应该能信口说上几个主流技术，虽然你可能只是听说过，了解。但关键时刻你得知道如何去选择技术，并快速掌握它。<br>        你还会去考虑尝试下别的语言，这里不是说转向什么C++ C#之类的，那和JAVA程序员不相干，我说的是一些运行于JVM之上的语言，比如scala和groovy，初识他们时你会觉得Java真的老了。<br>        但当你回到一个综合性的大型项目中，又会觉得Java积累下来的整个体系技术是如此完善，就像一个工业化标准一样，你可能发现光是Spring家族的东西你都受用终身，无法完全通读。你能把这个阶段实践好，胜任项目经理，乃至中小公司的技术总监，大厂的小团队Leader都是可以的</p>
<h4 id="6-大师——登峰造极"><a href="#6-大师——登峰造极" class="headerlink" title="6.大师——登峰造极"></a>6.大师——登峰造极</h4><p>其实写到上面这个阶段的时候我觉得，这是很多人满足的地方了，都是小公司技术总监了，那我图啥？<br>但是未知的人生还在那等着你呢，我问了身边顶级的大神，为啥要走出舒适区？去像字节跳动、阿里等这些压力大很多的地方呢？<br>        他们给的回答都不太一样，但是一样的就是挑战自我吧，谁也不知道哪里是自己的终点，那为啥不多做点尝试，新的环境，新的技术栈，新业务场景挑战新的自我。<br>        这个阶段你的一举一动可能都关系一个项目的生死存亡，一个错误或者正确的决策就可能改变整个项目的命运，水能载舟亦能覆舟，我想用在这里也恰到好处。<br>        我身边这样级别的大佬凤毛麟角，但不是没有，他们在公司都是核心人物，大型项目或者项目紧要关头都是他们带领团队冲冲冲，除了问题也是能最快给出解决思路和方案的。<br>        Tip：我现在的老大就是这样的人，双十一大家还手忙脚乱去追数据的时候，他上来一套操作，写了几个脚本就搞定了，卧槽我们当时周围一群人，从头到尾的知识盲区，结束了还没反应过来，只能拍手叫666。<br>        这就是强者的世界，我所向往的世界，当然我知道这样的世界，只有一步一个脚印才能涉足。</p>
<h4 id="7-王者——泰山之巅"><a href="#7-王者——泰山之巅" class="headerlink" title="7.王者——泰山之巅"></a>7.王者——泰山之巅</h4><p>最后王者其实我不会写任何内容，能到这个领域的人本身就是屈指可数了，敖丙身边有，但是我觉得大家自己体会吧，一般就是人脉，交际，能力都到了一定的高度了，这个阶段的事情我也体会不到。<br>        能想到的就只有先祖的诗句：指点江山，挥斥方遒。算是给大家留下无限遐想的空间吧，未来或许你就是你所在领域的王者也说不定的呢对吧。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>不知不觉写了这么多了，以上是我个人眼里的一般向JAVA 程序员的发展线路，限于篇辐也不全面，实际个人成长路线可能因为工作内容的不同差异会很大，有的人偏向了底层研究，有的人偏向了业务需求设计，有的带有浓重的行业色彩，而且技术之外，还有很多知识也很重要，做JAVA没有轻松的方向，但一个对技术抱有兴趣的人，走到这一步时，仍然会对开发抱有热情，想要写出好的项目。<br>        纯为了生计而工作的程序猿是走不到这一步的，这一行来都来了，大家一天都是24小时，为啥有差距，我想你我都明白的，知道为啥那就干出点名堂吧。</p>
<p>Just do it ！</p>
]]></content>
      <categories>
        <category>代码进阶分享</category>
      </categories>
  </entry>
  <entry>
    <title>SpringSecurity初体验</title>
    <url>/2020/12/21/SpringSecurity%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="1-初体验"><a href="#1-初体验" class="headerlink" title="1.初体验"></a>1.初体验</h1><p>1.引入spring-security依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.项目啥都不用做，引入了上面的依赖即保护了整个项目的接口</p>
<p>书写Controller接口，进行访问</p>
<p><img src="/2020/12/21/SpringSecurity%E5%88%9D%E4%BD%93%E9%AA%8C/1.png" alt="1604052679784"></p>
<a id="more"></a> 

<p>发现需要进行登陆，而这时项目启动时会随机生成一个字符串，就是登陆密码，登录名是user</p>
<p><img src="/2020/12/21/SpringSecurity%E5%88%9D%E4%BD%93%E9%AA%8C/2.png" alt="1604052719069"></p>
<p>登陆成功后即可访问到接口</p>
<p><img src="/2020/12/21/SpringSecurity%E5%88%9D%E4%BD%93%E9%AA%8C/3.png" alt="1604052770236"></p>
<h1 id="2-手工配置用户名密码"><a href="#2-手工配置用户名密码" class="headerlink" title="2.手工配置用户名密码"></a>2.手工配置用户名密码</h1><p>1.第一种配置方式</p>
<p><img src="/2020/12/21/SpringSecurity%E5%88%9D%E4%BD%93%E9%AA%8C/4.png" alt="1604053020964"></p>
<p>2.第二种配置方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//SpringSecurity登录需要进行密码加密</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NoOpPasswordEncoder.getInstance(); <span class="comment">//已过时</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//重写该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication() <span class="comment">//基于内存的认证</span></span><br><span class="line">                .withUser(<span class="string">"xzs"</span>).password(<span class="string">"123"</span>).roles(<span class="string">"admin"</span>) <span class="comment">//设置用户、密码、权限</span></span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">"xxxzs"</span>).password(<span class="string">"456"</span>).roles(<span class="string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
  </entry>
  <entry>
    <title>Vue零碎知识点</title>
    <url>/2020/05/12/Vue%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="Vue零碎知识点杂笔"><a href="#Vue零碎知识点杂笔" class="headerlink" title="Vue零碎知识点杂笔"></a>Vue零碎知识点杂笔</h3><p>webpack3的使用    webpack ./src/main.js  ./dist/bundle.js<br>        webpack4的使用    webpack ./src/main.js -o ./dist/bundle.js –mode development</p>
<p>但现在直接用Vue-cli4脚手架快速生成Vue项目</p>
<p>npm run build  ：会去package.json寻找script脚本属性里的build的指令执行  就可以执行项目本地的webpack指令</p>
<p>使用vue-cli2<br>           vue init webpack vueclitest（项目名）<br>        使用vue-cli3 4<br>           vue create vueclitest（项目名）</p>
<a id="more"></a>

<p>进入vue项目管理器：vue ui（可在终端直接使用）</p>
<p>添加vue.config.js这个文件可自定义配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">把一个函数作为参数传到另一个函数时使用箭头函数是最多的</span><br><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;  ===  setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)                        &#125;)	</span><br><span class="line">render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)  ===  render: <span class="function">(<span class="params">h</span>) =&gt;</span> &#123;</span><br><span class="line">                             <span class="keyword">return</span>  h(App)					                </span><br><span class="line">                          &#125;</span><br><span class="line">						  h是形参，调用的时候传入实参createElement来创建App组件</span><br></pre></td></tr></table></figure>

<p>$route指的是当前活跃的路由 负责路由映射<br>        $router  是代码跳转路由  等于App.vue注册的router组件  this.$router.push(‘/user/‘ + this.userId)</p>
<p>所有的组件都继承自Vue类的原型<br>        Vue.prototyoe.xxx  里面放了很多东西  例如$router</p>
<p>对路径起别名对import有效  在html元素中的src要加~</p>
<p>props父传子  $emit子传父</p>
<p>使用网络数据请求记得安装axios</p>
<p>default导出之后引入才可以不加大括号  不然就要import {xxx}  并且default导出的是唯一的  所以可以import 新名字 from…</p>
<p>ul&gt;li{分类列表$}*100  再按Tab快速生成一百行</p>
<p>在我们需要监听一个组件的原生事件时，必须给对应的事件加上.native修饰符才能进行监听</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;back-top @click.native=<span class="string">"backClick"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>this.$refs.aaa  即可拿到scroll这个组件 之后就可调用这个组件里的属性、方法 this.$refs.aaa.scrollTo(0,0)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;scroll ref=<span class="string">"aaa"</span>&gt; &lt;<span class="regexp">/scroll&gt;</span></span><br></pre></td></tr></table></figure>

<p>$bus 事件总线  用于联系两个不相关的组件传递一些事件,一开始的$bus是没有值的 记得去main.js去给他赋值</p>
<p>mixin.js  高级用法：混入   mixin.js里写的一些created() mounted()会和组件里相同的created() mounted()里的代码合并起来<br>       在Vue实例里添加属性mixins: [mixin.js导出的方法对象] 即可使用</p>
<p>$el是真正的dom元素，与document.getElementsby…一样</p>
<p>import {mapActions} from ‘vuex’<br>在methods里写 …mapActions([‘你要映射的方法名’]) 就可以直接this.方法名调用了</p>
<p>移动设备上的浏览器默认会在用户点击屏幕大约延迟300毫秒后才会触发点击事件<br>为了立即响应用户的点击事件，使用npm install fastclick –save</p>
<p>图片懒加载 npm install vue-lazyload –save</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img :src=<span class="string">"showImage"</span> &gt;换成 &lt;img v-lazy=<span class="string">"showImage"</span>&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>子类访问权限、方法重写和重载</title>
    <url>/2021/01/19/%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="子类访问权限"><a href="#子类访问权限" class="headerlink" title="子类访问权限"></a>子类访问权限</h1><p>子类可以通过 super 关键字访问父类中的资源，但并不是所有的父类资源都可以被子类访问。</p>
<p>访问权限修饰符</p>
<p>public、private、protected、缺省默认（不写）</p>
<table>
<thead>
<tr>
<th></th>
<th>同一个类</th>
<th>同一个包中</th>
<th>不同包</th>
<th>子类（同包）</th>
<th>子类（不同包）</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>可以访问</td>
<td>可以访问</td>
<td>可以访问</td>
<td>可以访问</td>
<td>可以访问</td>
</tr>
<tr>
<td>protected</td>
<td>可以访问</td>
<td>可以访问</td>
<td>不可以访问</td>
<td>可以访问，super可以访问</td>
<td>不可以访问，super可以访问</td>
</tr>
<tr>
<td>缺省默认</td>
<td>可以访问</td>
<td>可以访问</td>
<td>不可以访问</td>
<td>可以访问，super可以访问</td>
<td>不可以访问，super不可以访问</td>
</tr>
<tr>
<td>private</td>
<td>可以访问</td>
<td>不可以访问</td>
<td>不可以访问</td>
<td>不可以访问</td>
<td>不可以访问</td>
</tr>
</tbody></table>
<p>包（package）是 Java 管理文件的一种方式，一个工程可能会出现重名的类，通过包来解决冲突问题。</p>
<p>包的命名方式一般采用公司/组织的倒置域名</p>
<p>default 关键字是用来表示接口中的默认方法的，和访问权限修饰符的缺省默认值没有关系。</p>
<a id="more"></a>

<h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><p>子类在继承父类方法的基础上，对父类方法重新定义并覆盖的操作叫做方法重写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"输出人员信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.java.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个学生"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法不能被重写，构造方法不能被继承。</p>
<p>方法重写的规则：</p>
<p>1、父子类的方法名必须相同。</p>
<p>2、父子类的方法参数列表必须相同。</p>
<p>3、子类方法返回值与父类方法返回值相同，或者是其子类。</p>
<p>4、子类方法的访问权限不能小于父类，至少和父类一样，或者大于父类。</p>
<p>public &gt; protected &gt; 默认 &gt; private</p>
<p>父类 public，子类 public</p>
<p>父类 protected，子类 public、protected</p>
<p>父类默认，子类 public、protected、默认</p>
<p>父类 private，子类无法重写父类的方法，<strong>重写需要建立在继承的基础上</strong>，必须先有继承，才能有重写，父类的 private 修饰的方法是无法被子类继承的，所以无法重写。</p>
<h2 id="方法重写和方法重载"><a href="#方法重写和方法重载" class="headerlink" title="方法重写和方法重载"></a>方法重写和方法重载</h2><table>
<thead>
<tr>
<th></th>
<th>所在位置</th>
<th>方法名</th>
<th>参数列表</th>
<th>返回值</th>
<th>访问权限</th>
</tr>
</thead>
<tbody><tr>
<td>方法重写</td>
<td>子类重写父类方法</td>
<td>相同</td>
<td>相同</td>
<td>相同或是其子类</td>
<td>不能小于父类</td>
</tr>
<tr>
<td>方法重载</td>
<td>同一个类中</td>
<td>相同</td>
<td>不相同</td>
<td>没有要求</td>
<td>没有要求</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2020/05/12/Vue/</url>
    <content><![CDATA[<h3 id="Vue整体概括"><a href="#Vue整体概括" class="headerlink" title="Vue整体概括"></a>Vue整体概括</h3><p>main.js主文件  进行App.vue这个根文件  进行渲染，同时可设置路由router</p>
<p>App.vue主界面入口  导入一些自己写的组件 同时可用router-view进行路由渲染 从而不在这里面放入太多的组件</p>
<p>index.js 路由文件  导入VueRouter 并Vue.use(VueRouter)使用  同时写上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"> 	routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>并在上面定义一个routes路由数组 在数组里配置各个路由映射</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    component: Home</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得导入组件，可以直接导入，也可以懒加载导入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = () =&gt; <span class="keyword">import</span>(<span class="string">'../views/home/Home'</span>)</span><br></pre></td></tr></table></figure>

<p>之后项目划分：</p>
<p>​    assets-&gt;css、img  放样式和图片<br>​            common-&gt;mixin.js、utils.js、const.js 放公用函数、常量文件<br>​            components-&gt;common、content  放可复用的组件，同时分为公用和业务所需<br>​            network-&gt;request.js、home.js、detail.js 放网络请求的文件 同时对axios进行一层封装为request<br>​                                          之后home.js等文件只需导入request，并传入url、params作为网络请求的config<br>​            router-&gt;index.js  配置路由 大体只配置主要的部分/home /category /cart /profile /detail/:iid<br>​            store-&gt;index.js、actions.js、mutations.js、getters.js  配置Vuex的五大组件 进行状态管理<br>​            views-&gt;home、category、cart、profile、detail  配置主要部分的视图 业务组件都在这里编写</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>循环</title>
    <url>/2021/01/18/%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="while-循环和-do-while-循环的区别"><a href="#while-循环和-do-while-循环的区别" class="headerlink" title="while 循环和 do-while 循环的区别"></a>while 循环和 do-while 循环的区别</h1><p>do-while 循环会先执行一次循环体，再做判断（循环条件），决定是否进行下一次的循环，如果成立，则继续执行循环条，如果不成立，则跳出循环，所以至少会执行一次循环体。</p>
<p>while 先判断循环条件，再执行循环体，有可能一次都不执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"just do it"</span>);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;<span class="keyword">while</span> (num&lt;<span class="number">90</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">while</span> (num&lt;<span class="number">90</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"just do it"</span>);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="for-和-while、do-while-之间的区别"><a href="#for-和-while、do-while-之间的区别" class="headerlink" title="for 和 while、do-while 之间的区别"></a>for 和 while、do-while 之间的区别</h1><p>相同点：都遵循循环四要素。</p>
<p>不同点：</p>
<ul>
<li>while 和 do-while 适用于循环次数不确定的场景，for 适用于循环次数确定的场景。</li>
</ul>
<p>阻塞式方法</p>
<p>程序暂停，等待某一个操作，如果这个操作不执行，程序会一直暂停，直到该操作执行，才会继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//次数确定</span></span><br><span class="line">        <span class="comment">//Scanner 是 JDK 提供的一个对象，可以通过该对象获取用户输入的数据</span></span><br><span class="line"><span class="comment">//        System.out.print("请输入num的值：");</span></span><br><span class="line"><span class="comment">//        Scanner scanner = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">//        int num = scanner.nextInt();</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; num; i++) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(i);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//张三练习写代码 hello world，直到我满意为止</span></span><br><span class="line"><span class="comment">//        String result = "no";</span></span><br><span class="line"><span class="comment">//        Scanner scanner = new Scanner(System.in);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        do &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("张三练习写代码 hello world");</span></span><br><span class="line"><span class="comment">//            System.out.print("你是否满意？yes/no:");</span></span><br><span class="line"><span class="comment">//            result = scanner.next();</span></span><br><span class="line"><span class="comment">//        &#125;while(result.equals("no"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        while(result.equals("no"))&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("张三练习写代码 hello world");</span></span><br><span class="line"><span class="comment">//            System.out.print("你是否满意？yes/no:");</span></span><br><span class="line"><span class="comment">//            result = scanner.next();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println("张三练习完毕");</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>for 和 while 是先判断循环条件，再执行循环体；do-while 第一次是先执行，再判断循环条件。</li>
</ul>
<h1 id="双重循环"><a href="#双重循环" class="headerlink" title="双重循环"></a>双重循环</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">300</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span> ; i++) &#123;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/18/%E5%BE%AA%E7%8E%AF/1.png" alt="1610975904763"></p>
<p>像这种编程题就是找规律：</p>
<p>上半部分</p>
<p>第一行0：先打印 3 个空格，再打印 1 个数字</p>
<p>第二行1：先打印 2 个空格，再打印 2 个数字</p>
<p>第三行2：先打印 1 个空格，再打印 3 个数字</p>
<p>第四行3：先打印 0 个空格，再打印 4 个数字</p>
<p>行号从 0 开始，空格数 = 3 - 行号，数字个数 = 行号 + 1</p>
<p>下半部分</p>
<p>第一行0：先打印 1 个空格，再打印 3 个数字</p>
<p>第二行1：先打印 2 个空格，再打印 2 个数字</p>
<p>第三行2：先打印 3 个空格，再打印 1 个数字</p>
<p>行号从 0 开始，空格数 = 行号+1，数字个数 = 3 - 行号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上半部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//打印空格</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>-j; k++) &#123;</span><br><span class="line">                System.out.print(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt; <span class="number">2</span>*j+<span class="number">1</span>; i++) &#123;</span><br><span class="line">                System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下半部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//打印空格</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j+<span class="number">1</span>; k++) &#123;</span><br><span class="line">                System.out.print(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>-j; i &lt; <span class="number">5</span>-<span class="number">2</span>*j; i++) &#123;</span><br><span class="line">                System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="终止循环"><a href="#终止循环" class="headerlink" title="终止循环"></a>终止循环</h1><p>break</p>
<p>continue</p>
<p>break 跳出整个循环，continue 跳出本次循环，进入下一次循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1-100整数之和,当结果大于50的时候,结束循环</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">50</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>封装、static关键字</title>
    <url>/2021/01/19/%E5%B0%81%E8%A3%85%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="面向对象三大特征：封装、继承、多态"><a href="#面向对象三大特征：封装、继承、多态" class="headerlink" title="面向对象三大特征：封装、继承、多态"></a>面向对象三大特征：封装、继承、多态</h1><h2 id="什么是封装？"><a href="#什么是封装？" class="headerlink" title="什么是封装？"></a>什么是封装？</h2><p>类中的属性外部可以没有任何限制的随时访问和修改，造成数据的不安全。</p>
<p>为了避免这种情况，所以我们应该将类中的信息全部封装起来，让外部不能直接访问，而是有限制条件的进行访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让外部修改值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.err.println(<span class="string">"传入了非法的数据，已启用默认值0"</span>);</span><br><span class="line">            <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<p>1、将成员变量（属性）私有化（private）修饰。</p>
<p>2、提供公有的 setter/getter 方法。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使类和成员的可访问性最小化</p>
<p>组件</p>
<p>API Application Interface 应用程序接口</p>
<p>组件化搭配 将功能模块拆分成一个个组件，再把这些组件整合到一起，共同实现业务功能，组件怎么称呼 API</p>
<p>封装可以将 API 和具体实现进行隔离</p>
<p>接口，抽象类，类中的方法都是抽象没有具体实现，只提供概念，需要具体的实现类来完成抽象的实现。</p>
<p>组件之间只需要通过 API 进行通信即可，不同的组件完全不需要知道其他组件的具体实现。</p>
<p>解耦合</p>
<p>低耦合 高内聚</p>
<h1 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h1><p>static 表示静态或者全局，可以用来修饰成员变量或者成员方法或者代码块，</p>
<p>非 static 修饰的方法要调用，必须依赖于某个具体的实例化对象，而 static 修饰的方法不需要依赖于任何一个对象，属于类的信息，同时被该类所有的实例化对象所共享，所以是全局概念。</p>
<p>用 static 修饰的成员变量，多个对象共用，内存中只有一份，没有被 static 修饰的成员变量叫做实例变量，一个对象对应一个，内存中有多份。</p>
<p><img src="/2021/01/19/%E5%B0%81%E8%A3%85%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97/1.png" alt="1611036038080"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 test2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">            test2.id++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(test2.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>static 修饰成员方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个User对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>static 修饰代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"123"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态代码块的特点是只执行一次，当类被加载到 JVM 内存中的时候去执行。</p>
<p>静态代码块只执行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(<span class="string">"执行了静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个User对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user1 = <span class="keyword">new</span> User();</span><br><span class="line">        User user2 = <span class="keyword">new</span> User();</span><br><span class="line">        User user3 = <span class="keyword">new</span> User();</span><br><span class="line">        System.out.println(user1.num);</span><br><span class="line">        System.out.println(user2.num);</span><br><span class="line">        System.out.println(user3.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"static code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"main() execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/19/%E5%B0%81%E8%A3%85%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97/2.png" alt="1611036066885"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"static code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"main() execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/19/%E5%B0%81%E8%A3%85%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97/3.png" alt="1611036080142"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"static code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"main() execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/19/%E5%B0%81%E8%A3%85%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97/4.png" alt="1611036091484"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Test3 test3 = <span class="keyword">new</span> Test3();</span><br><span class="line">        System.out.println(<span class="string">"main() execute"</span>);</span><br><span class="line">        Test3 test2 = <span class="keyword">new</span> Test3();</span><br><span class="line">        Test3 test1 = <span class="keyword">new</span> Test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/19/%E5%B0%81%E8%A3%85%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97/5.png" alt="1611036103674"></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型转换、运算符和流程控制</title>
    <url>/2021/01/18/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="1-数据类型转换"><a href="#1-数据类型转换" class="headerlink" title="1.数据类型转换"></a>1.数据类型转换</h1><h2 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        <span class="keyword">double</span> num2 = num1;</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序会自动识别数据类型并完成转换，这种操作对数据类型是有要求的，并不是所有的数据类型都能完成自动转换。</p>
<p>1、整型转浮点型都可以，跟字节大小没有关系。</p>
<p>int  –&gt;  float/double</p>
<p>long  –&gt;  float/double</p>
<p>2、浮点型转整型，都无法完成，因为有精度损失，小数点后数值有丢失，对数据的描述不精准。</p>
<p>3、精度一样（都是整型/都是浮点型）的情况下，只能由低字节转为高字节，反之则不行。</p>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>当自动转换不能实现的时候，我们可以通过强制手段进行转换，尽量不要强转，如果是基本数据类型，可能会有数据的精度损失，如果是引用类型，可能抛出类型转换异常。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> num1 = <span class="number">10.6f</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = (<span class="keyword">int</span>)num1;</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        Cat cat = (Cat) animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h1><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>=，将 = 右边的值赋给等号左边，= 右边可以是具体数值，也可以是一个变量，= 左边一定是变量。</p>
<p>int num1 = 10；int num2 = 11;交换 num1 和 num2 的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        temp = num1;</span><br><span class="line">        num1 = num2;</span><br><span class="line">        num2 = temp;</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本算术运算符"><a href="#基本算术运算符" class="headerlink" title="基本算术运算符"></a>基本算术运算符</h2><p>+、-、*、/、++、–</p>
<p>num++，先执行，再+1</p>
<p>++num，先+1，再执行</p>
<h2 id="复合算术运算符"><a href="#复合算术运算符" class="headerlink" title="复合算术运算符"></a>复合算术运算符</h2><p>在基本算术运算符的基础上进行进一步的简化操作</p>
<p>+=、-=、*=、/=、%=</p>
<p>变量A += 变量B：先求出变量A+变量B的值，再将结果赋值给变量A</p>
<p>变量A = 变量A+变量B</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>是用来计算一个表达式是否成立，boolean true/false</p>
<p>==、!=、&gt;、&lt;、&gt;=、&lt;=</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D; 只能用作数值类型的比较</span><br><span class="line">&#x3D;&#x3D;、!&#x3D; 所有类型都可以用</span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>只能操作 boolen 类型的数据，判断 boolean 数据之间的逻辑关系，与、或、非</p>
<p>&amp;、|、！、&amp;&amp;（短路与）、||（短路或）</p>
<p>&amp;&amp; 和 &amp; 从结果上看没有区别，但是 &amp;&amp; 的效率更高。</p>
<p>&amp;/&amp;&amp; 两个操作数都为 true，结果为 true，否则为 false</p>
<p>|/|| 两个操作数只要有一个为 true，结果为 true，否则为 false</p>
<p>! 取反操作</p>
<p>&amp;&amp; 如果左边表达式为 false，则不执行右边的表达式，直接返回结果 false。</p>
<p>|| 如果左边表达式为 true，则不执行右边的表达式，直接返回结果 true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">11</span>;</span><br><span class="line">        System.out.println((num1++ == num2) &amp;&amp; (++num1 == num2));</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>三目运算符、三元表达式，执行赋值操作，根据不同的条件给同一个变量赋不同的值。</p>
<p>变量A = 条件？值1：值2</p>
<p>int num = 10==9?1:2</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>对操作数以二进制为单位进行运算，首先将操作数转为二进制，再进行运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp; 按位与:每一位数字一一对应，如果都为1，则该位记作1，否则为0</span><br><span class="line"></span><br><span class="line">| 按位或:每一位数字一一对应，只要有一个为1，则改为记作1，否则为0</span><br><span class="line"></span><br><span class="line">^ 按位异或:每一位数字一一对应，相同记作0，不同记作1</span><br><span class="line"></span><br><span class="line">&lt;&lt; 左移:A&lt;&lt;B,A 乘以 2 的B次方</span><br><span class="line"></span><br><span class="line">&gt;&gt; 右移:A&gt;&gt;B,A 除以 2 的B次方</span><br></pre></td></tr></table></figure>



<h1 id="3-流程控制"><a href="#3-流程控制" class="headerlink" title="3.流程控制"></a>3.流程控制</h1><p>if-else 可以嵌套使用</p>
<ul>
<li>if 后面必须跟(条件)</li>
<li>else 后面不能根据(条件)</li>
<li>else 后面可以直接跟{}，也可以跟另外一个 if(条件)</li>
</ul>
<p>switch-case</p>
<p>功能上跟 if-else 是一致的，都是用来做流程控制的，区别在于 if-else 可以做等值判断、大于小于判断，switch-case 只能做等值判断。</p>
<p>同样做等值判断的情况下，switch-case 结构会比 if-else 更加清晰，有利于代码的可读性。</p>
<p>case 后面需要加 break</p>
<p>循环</p>
<p>for、while、do-while、foreach</p>
<p>循环四要素：</p>
<p>1、初始化循环变量</p>
<p>2、循环条件</p>
<p>3、循环体</p>
<p>4、更新循环变量</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2021/01/19/%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口是由抽象类衍生出来的概念，抽象类是指类中至少存在一个抽象方法，抽象类是由抽象方法和非抽象方法组成的。</p>
<p>接口就是<strong>极度抽象的抽象类</strong>，类中所有方法都是抽象方法，没有非抽象方法。</p>
<p>接口主要用来实现解耦合。</p>
<p>面向接口编程的优点：</p>
<p>1、能够最大限度的解耦合，降低程序的耦合度。</p>
<p>2、使程序易于扩展。</p>
<p>3、有利于程序的后期维护。</p>
<h2 id="如何使用接口"><a href="#如何使用接口" class="headerlink" title="如何使用接口"></a>如何使用接口</h2><p>接口在 Java 中是独立存在的一种结构，和类相似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface 接口名&#123;</span><br><span class="line">	方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>接口中的方法全部都是抽象方法，同时接口中允许存在成员变量，有要求：</p>
<p>1、不能定义 private 和 protected 修饰的成员变量，只能定义 public 和默认成员变量。</p>
<p>2、接口中的成员变量在定义时必须初始化。</p>
<p>3、接口中的成员变量都是静态常量，可以通过接口之间访问，同时值不能修改。</p>
<p>使用接口，需要有实现类，实现类来实现接口中的抽象方法，把抽象的内容具体化。</p>
<p>1、用普通Java类实现接口，重写（实现）接口中的抽象方法。</p>
<p>2、如果实现类不希望重写方法，将实现类定义成抽象类即可。</p>
<p>3、接口不能实现接口。</p>
<p>4、接口可以继承接口。</p>
<p>接口其实是对继承的一种扩展，都是多态的体现。</p>
<p>扩展什么呢？</p>
<p>继承的原则是单继承，一个类只能有一个父类，但是接口是没有这个限制，一个实现类可以同时实现多个接口。</p>
<h2 id="面向接口编程的实际应用"><a href="#面向接口编程的实际应用" class="headerlink" title="面向接口编程的实际应用"></a>面向接口编程的实际应用</h2><p>面向对象编程 OOP 是一种思想，面向接口编程是一种具体的开发方式。</p>
<p>工厂生产产品A，需要用设备A来生产</p>
<p>Factory、EquipmentA</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.com.xzs.test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EquipmentA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"设备A运行，生产产品A..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.com.xzs.test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EquipmentA equipmentA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EquipmentA <span class="title">getEquipmentA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> equipmentA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEquipmentA</span><span class="params">(EquipmentA equipmentA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.equipmentA = equipmentA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始生产..."</span>);</span><br><span class="line">        <span class="keyword">this</span>.equipmentA.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.com.xzs.test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EquipmentA equipmentA = <span class="keyword">new</span> EquipmentA();</span><br><span class="line">        Factory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">        factory.setEquipmentA(equipmentA);</span><br><span class="line">        factory.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂接了新订单，生产产品B，必须由设备B来生产，工厂中只能有一台设备。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.com.xzs.test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Equiment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.com.xzs.test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Equiment equiment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Equiment <span class="title">getEquiment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> equiment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEquiment</span><span class="params">(Equiment equiment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.equiment = equiment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始生产..."</span>);</span><br><span class="line">        <span class="keyword">this</span>.equiment.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.com.xzs.test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EquipmentA equipmentA = <span class="keyword">new</span> EquipmentA();</span><br><span class="line">        EquipmentB equipmentB = <span class="keyword">new</span> EquipmentB();</span><br><span class="line">        EquipmentC equipmentC = <span class="keyword">new</span> EquipmentC();</span><br><span class="line">        Factory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">        factory.setEquiment(equipmentC);</span><br><span class="line">        factory.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2021/01/19/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="什么是异常？"><a href="#什么是异常？" class="headerlink" title="什么是异常？"></a>什么是异常？</h2><p>Java 中的错误大致分为两类：</p>
<p>1、<strong>编译时错误</strong>，语法错误</p>
<p>2、<strong>运行时错误</strong>，语法正确，逻辑错误</p>
<p>Java 中有一组类专门描述各种不同的运行时错误，叫做异常类，实例化对象就是各种异常对象。</p>
<p>1、程序出现错误时，会自动创建一个包含错误信息的异常对象。</p>
<p>2、将异常对象提交给系统。</p>
<p>3、由系统转交给能够处理这个异常的代码进行处理。</p>
<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>本质上分为两大类：</p>
<p>1、Error：指系统错误，由JVM生成，无法处理。</p>
<p>2、Exception：程序运行期间出现的错误，可以处理。</p>
<a id="more"></a>

<h2 id="异常的使用"><a href="#异常的使用" class="headerlink" title="异常的使用"></a>异常的使用</h2><p>try-catch</p>
<p>try（尝试运行） 包裹可能出现异常的代码，一旦出现异常，自动创建一个异常对象，交给系统，系统要分配下去，找到可以处理的代码进行处理。</p>
<p>catch（捕获异常）捕获系统抛出的异常，进行处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	&#x2F;&#x2F;可能抛出异常的代码</span><br><span class="line">&#125;catch(Exception exception)&#123;</span><br><span class="line">	&#x2F;&#x2F;处理异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论程序是否抛出异常，finally 代码块中的代码一定会执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	&#x2F;&#x2F;可能抛出异常的代码</span><br><span class="line">&#125;catch(Exception exception)&#123;</span><br><span class="line">	&#x2F;&#x2F;处理异常</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	&#x2F;&#x2F;一定要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"try..."</span>);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"finally..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h2><p>异常类的最顶端是 Throwable</p>
<p>Throwable 有两个直接子类：Error 和 Exception</p>
<p>Throwable、Error、Exception 三个类都存在于 java.lang 包中。</p>
<p>Error 常见的子类：VMError、AWTError、IOError。</p>
<p>VMError 常见子类：StackOverflowError、OutOfMemoryError。</p>
<p>Exception 常见子类：IOException 和 RuntimeException</p>
<p>IOException 的常见子类：FileLockInterruptionException、FileNotFoundException。</p>
<p>RuntimeException 的常见子类：</p>
<p>ArithmeticException 数学异常</p>
<p>ClassNotFoundException 类未定义异常</p>
<p>IllelgalArgumentException 参数格式异常</p>
<p>ArrayIndexOutOfBoundsException 数组下标越界异常</p>
<p>NullPointerException 空指针异常</p>
<p>NoSuchMethodException 方法未定义异常</p>
<p>NumberFormatException 将其他类型转为数字时报错，格式错误</p>
<p><img src="/2021/01/19/%E5%BC%82%E5%B8%B8/1.png" alt="1611040744372"></p>
<h2 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h2><p>都是 Java 处理异常时的关键字，都跟抛出异常有关系。</p>
<p>throws 是用来修饰方法的，表示该方法可能会抛出某个异常，告诉调用者使用的时候需要注意。</p>
<p><img src="/2021/01/19/%E5%BC%82%E5%B8%B8/2.png" alt="1611040797254"></p>
<p>throw 是抛出异常对象具体实现代码。</p>
<p><img src="/2021/01/19/%E5%BC%82%E5%B8%B8/3.png" alt="1611040817783"></p>
<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>++，参数必须是整数，不是整数就抛出异常（自定义异常）</p>
<p><img src="/2021/01/19/%E5%BC%82%E5%B8%B8/4.png" alt="1611041073624"></p>
<p>如果异常的父类是 RuntimeException，那么使用该异常的时候，可以不进行处理，叫做不检查异常。</p>
<p>如果异常的父类是 Exception，则该异常是受检查异常，使用该异常的时候，需要进行处理（1、try-catch自己解决，2、再次抛出 throws）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNumberException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNumberException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xzs.exception.MyNumberException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(add(<span class="keyword">new</span> Object()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Object object)</span> <span class="keyword">throws</span> MyNumberException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(object <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">            Integer num = (Integer)object;</span><br><span class="line">            <span class="keyword">return</span> ++num;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyNumberException(<span class="string">"操作数类型不是整数！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>构造函数、方法重载、成员变量和局部变量</title>
    <url>/2021/01/19/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>定义类的目的是为了创建对象，对象是 Java 的核心，面向对象编程语言。</p>
<p>如何通过类创建对象？</p>
<p>通过构造函数/构造方法/构造器创建对象。</p>
<p>构造函数其实是一种特殊的方法：</p>
<p>1、方法名必须是类名</p>
<p>2、不需要定义返回值类型</p>
<p>构造方法可以分为两类：无参构造和有参构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个类都拥有一个默认的无参构造函数，不需要开发者手动定义。</p>
<p>但是如果手动定义一个有参构造，则默认的无参构造会被覆盖掉，导致对象无法创建。</p>
<p>User@b4c966a</p>
<p>表示对象的信息 类@内存地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><p>用 this 来指代当前类的实例化对象</p>
<p>一个类可以生成 N 个对象</p>
<p>无参创建对象的时候，this = 799</p>
<p><img src="/2021/01/19/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/1.png" alt="1611035514896"></p>
<p>有参创建对象的时候，this = 866</p>
<p><img src="/2021/01/19/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/2.png" alt="1611035527432"></p>
<p>this 可以调用当前对象的属性和方法</p>
<p>this.id</p>
<p>this.show();</p>
<p>this();</p>
<h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><p>1、同一个类中</p>
<p>2、方法名相同</p>
<p>3、参数列表不同</p>
<p>4、与返回值和访问权限修饰符无关</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1+num2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,<span class="keyword">int</span> num3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1+num2+num3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">        test2.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        test2.add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h1><p>成员变量和局部变量指的是两种不同类型的变量，区别在哪？</p>
<p>变量所在的位置不同，作用域不同。</p>
<p>成员变量的作用域是整个类，成员变量是定义在方法外类中的。</p>
<p>局部变量的作用域只在它的方法中，局部变量是定义在某个方法中的。</p>
<p>成员变量会有默认值，可以不赋值</p>
<p>局部变量没有默认值，必须手动赋值</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构复杂度计算</title>
    <url>/2021/01/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><ul>
<li>数据就是指一组数据的存储结构。</li>
<li>算法就是操作数据的一种方式。</li>
</ul>
<p>数据结构为算法进行服务，算法需要在特定的数据结构之上运行。</p>
<p>快：让程序运行速度更快，时间</p>
<p>省：让程序更加节省内存空间，空间</p>
<p>如何分析算法的执行效率</p>
<p>直接统计程序的运行时间和占用内存是可以的，叫做事后统计法，这种方式显然不客观，</p>
<p>太依赖于硬件配置和数据规模。</p>
<p>我们需要有一种统计方式，不需要考虑硬件配置和数据规模，估算算法执行效率的方式，这个方法就是时间复杂度分析法和空间复杂度分析法。</p>
<p>时间复杂度分析的是一个大概的趋势，并不是具体的数值。</p>
<a id="more"></a>

<h1 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">		sum += i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">    sum += i;</span><br></pre></td></tr></table></figure>

<p>每行代码执行时间为 time，我们认为只有读数据、运算、写数据的代码才占用时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time+time+n*time+n*time &#x3D; 2time+2n*time&#x3D;(2n+2)*time</span><br></pre></td></tr></table></figure>

<p>代码的执行时间和每行代码的执行次数成正比，记作 T(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">		j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;=n;j++)&#123;</span><br><span class="line">            sum += i*j;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;j&lt;=n;j++)&#123;</span><br><span class="line">        sum += i*j;</span><br></pre></td></tr></table></figure>

<p>每行代码执行时间为 time，我们认为只有读数据、运算、写数据的代码才占用时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3*time + 2n*time + 2n^2*time &#x3D; (2n^2+2n+3)*time</span><br></pre></td></tr></table></figure>

<p>T(n)：所有代码的执行时间和每行代码的执行次数成正比。</p>
<p>大 O 公式：T(n) = O(f(n))</p>
<p>T(n) 表示代码的执行时间</p>
<p>n 表示数据规模</p>
<p>f(n) 表示每行代码执行的次数总和的计算公式</p>
<p>O 表示代码的执行时间 T(n) 和 f(n) 成正比。</p>
<p>(2n+2)*time</p>
<p>T(n) = O((2n+2))</p>
<p>T(n) = O(2n^2+2n+3)</p>
<p>当 n 趋于无穷大的时候，低阶、系数、常量都可以省略，只需要记录最大量级即可。</p>
<p>T(n) = O(n)</p>
<p>T(n) = O(n^2)</p>
<h1 id="3-种时间复杂度统计方法"><a href="#3-种时间复杂度统计方法" class="headerlink" title="3 种时间复杂度统计方法"></a>3 种时间复杂度统计方法</h1><p>1、只关注循环执行次数最多的一行代码</p>
<p>2、加法法则：总复杂度等于量级最大的那段代码的复杂度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p &lt; <span class="number">100</span>;p++)&#123;</span><br><span class="line">        sum1 =+ p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;q&lt;n;q++)&#123;</span><br><span class="line">        sum2 += q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;=n;j++)&#123;</span><br><span class="line">            sum3 += i*j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum1+sum2+sum3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>100 + O(n) + O(n^2) </p>
<p>O(n^2)</p>
<p>T1(n) = O(f(n))</p>
<p>T2(n) = O(g(n))</p>
<p>T(n) = T1(n) + T2(n) = max(O(f(n)),O(g(n))) </p>
<p>3、乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T1(n) &#x3D; O(f(n))，T2(n) &#x3D; O(g(n))</span><br><span class="line">T(n) &#x3D; T1(n)*T2(n) &#x3D; O(f(n))*O(g(n)) &#x3D; O(f(n)*g(n))</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">		ret += f(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T(n) = O(n)*O(n) = O(n^2)</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>时间复杂度：表示算法的执行时间和数据规模之间的增长关系。</p>
<p>空间复杂度：表示算法的存储空间于数据规模之间的增长关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        a[i] = i*i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        sout(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间复杂度 O(n)</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2021/01/19/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组就是一种可以存放大量<strong>数据类型相同</strong>的变量的数据结构。</p>
<p>数组下标是 0 开始的，为什么？</p>
<p>为了极致的检索效率</p>
<p><img src="/2021/01/19/%E6%95%B0%E7%BB%84/1.png" alt="1611034260693"></p>
<p>1、数组中存储的数据必须都是同一种数据类型的。</p>
<p>2、数组在内存中开辟的空间是连续的，通过寻址公式快速计算出不同下标对应的内存地址。</p>
<a id="more"></a>

<h1 id="数组的基本要素"><a href="#数组的基本要素" class="headerlink" title="数组的基本要素"></a>数组的基本要素</h1><p>一个数组是由 4 个基本元素构成：</p>
<p>1、数组名称</p>
<p>2、数组元素</p>
<p>3、元素下标</p>
<p>4、数据类型</p>
<p><img src="/2021/01/19/%E6%95%B0%E7%BB%84/2.png" alt="1611034325423"></p>
<h1 id="如何使用数组"><a href="#如何使用数组" class="headerlink" title="如何使用数组"></a>如何使用数组</h1><p>1、声明数组：数据类型[] 数组名;数据类型 数组名[];</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array;</span><br></pre></td></tr></table></figure>

<p>2、分配内存空间：创建数组时必须要指定它的长度，数组长度不可变，固定的，根据这个长度和数据类型在内存（堆内存）中开辟一串连续的空间来存储数组元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br></pre></td></tr></table></figure>

<p>3、给数组赋值：通过下标找到对应的内存空间，把值存入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">array[<span class="number">1</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>4、使用数组：通过下标取出对应的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sout(array[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先声明，再赋值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] array;</span></span><br><span class="line"><span class="comment">//        array = new int[3];</span></span><br><span class="line"><span class="comment">//        array[0] = 1;</span></span><br><span class="line"><span class="comment">//        array[1] = 2;</span></span><br><span class="line"><span class="comment">//        array[2] = 3;</span></span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>边声明边赋值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用数组常见错误</p>
</blockquote>
<p>1、数组的数据类型不匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>2、边声明边赋值必须写在同一行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array;</span><br><span class="line">array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>3、数组下标越界异常</p>
<p><img src="/2021/01/19/%E6%95%B0%E7%BB%84/3.png" alt="1611034399727"></p>
<h1 id="数组的常用操作和方法"><a href="#数组的常用操作和方法" class="headerlink" title="数组的常用操作和方法"></a>数组的常用操作和方法</h1><p>1、求数组中元素的最大值</p>
<p>2、求数组中元素的最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">73</span>,<span class="number">80</span>,<span class="number">62</span>,<span class="number">93</span>,<span class="number">96</span>,<span class="number">87</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt; max)&#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、在数组的指定位置插入一个数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">73</span>,<span class="number">80</span>,<span class="number">62</span>,<span class="number">93</span>,<span class="number">96</span>,<span class="number">87</span>&#125;;</span><br><span class="line">        <span class="comment">//将83插入到下标为3的位置</span></span><br><span class="line">        <span class="keyword">int</span> score = <span class="number">83</span>;</span><br><span class="line">        <span class="comment">//1、创建长度为7的新数组</span></span><br><span class="line">        <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//2、将原数组中的值转移到新数组中，将下标3空出来</span></span><br><span class="line">        <span class="comment">//3以前</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            newArray[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3以后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; newArray.length; i++) &#123;</span><br><span class="line">            newArray[i] = array[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把83存入下标3中</span></span><br><span class="line">        newArray[<span class="number">3</span>] = <span class="number">83</span>;</span><br><span class="line">        System.out.println(Arrays.toString(newArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、数组排序 </p>
<p>冒泡排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">96</span>,<span class="number">93</span>,<span class="number">87</span>,<span class="number">80</span>,<span class="number">73</span>,<span class="number">62</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>-j; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &gt; array[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = array[i];</span><br><span class="line">            array[i] = array[i+<span class="number">1</span>];</span><br><span class="line">            array[i+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 提供了一个工具类，专门对数组进行各种操作，Arrays</p>
<p>1、安装虚拟机 Linux 不需要花钱</p>
<p>2、租一台服务器 阿里云 腾讯云 华为云 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraysTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">73</span>,<span class="number">80</span>,<span class="number">62</span>,<span class="number">93</span>,<span class="number">96</span>,<span class="number">87</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] array2 = &#123;<span class="number">73</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">93</span>,<span class="number">96</span>,<span class="number">87</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] array3 = &#123;<span class="number">66</span>,<span class="number">55</span>,<span class="number">44</span>,<span class="number">33</span>,<span class="number">22</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.equals(array, array2));</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        Arrays.fill(array, <span class="number">6</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        <span class="keyword">int</span>[] newArray = Arrays.copyOf(array3, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(newArray));</span><br><span class="line">        <span class="comment">//二分查找法的前提是目标数组必须是有序的，使用二分查找法之前应该先对数组进行排序</span></span><br><span class="line">        Arrays.sort(array2);</span><br><span class="line">        System.out.println(Arrays.toString(array2));</span><br><span class="line">        System.out.println(Arrays.binarySearch(array2, <span class="number">99</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p>一共有 6 个货柜，每个货柜中有 10 件商品</p>
<p>用数组的结构来保存所有商品的价格</p>
<p>二维数组其实就是一维数组，只不过一维数组中保存的值是另一个一维数组。</p>
<p><img src="/2021/01/19/%E6%95%B0%E7%BB%84/4.png" alt="1611034565490"></p>
<p>二维数组使用与一维数组类似</p>
<p>1、声明</p>
<p>2、开辟内存空间</p>
<p>3、赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、声明二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] array;</span><br><span class="line">        <span class="comment">//2、开辟内存空间</span></span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br><span class="line">        <span class="comment">//3、赋值</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        array[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] children = array[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; children.length; j++) &#123;</span><br><span class="line">                System.out.println(children[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"****************"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>超市卖鸡蛋货柜分上、中、下3层，每层分6个格挡，每个格挡中鸡蛋的个数是层数*格挡数，要求使用二维数组来装载所有的鸡蛋并求出总数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">6</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"------第"</span>+(i+<span class="number">1</span>)+<span class="string">"层货柜------"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = (i+<span class="number">1</span>) * (j+<span class="number">1</span>);</span><br><span class="line">                sum += num;</span><br><span class="line">                System.out.println(<span class="string">"第"</span>+(j+<span class="number">1</span>)+<span class="string">"个格挡的鸡蛋个数是："</span>+num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"鸡蛋的总数是"</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>继承、内部类</title>
    <url>/2021/01/19/%E7%BB%A7%E6%89%BF%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>描述类和类之间的一种关系，是 Java 实现代码重用/复用的重要机制。</p>
<p>被继承的类叫做父类 / 超类，继承父类的类叫做子类 / 派生类。</p>
<p>子类可以继承父类中的公有资源（成员变量和成员方法），父类的私有信息，子类无法继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="comment">//信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	<span class="comment">//继承父类的公有信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="子类访问父类"><a href="#子类访问父类" class="headerlink" title="子类访问父类"></a>子类访问父类</h2><p>只要两个类实现了继承关系，那么在创建子类对象的时候，一定会先创建父类对象。</p>
<p>无论子类对象是通过有参构造还是无参构造来创建，父类默认都是用无参构造创建。</p>
<p>每个类只能有一个直接父类，但是可以有多个间接父类。</p>
<p>可以通过手动修改的方式让父类调用自己的有参构造。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Student no args constructor execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Student args constructor execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>super 关键字表示在子类中访问父类的信息，跟 this 形成对比，this 关键字表示在类中访问本体的信息。</p>
<p>this()/this(…)   super()/super(…) 必须写在调用方法的第一行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(str + <span class="string">" object created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Stub parentStaticObject = <span class="keyword">new</span> Stub(<span class="string">"parent static object"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"parent static code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"parent code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stub parentObject = <span class="keyword">new</span> Stub(<span class="string">"parent object"</span>);</span><br><span class="line"></span><br><span class="line">    Stub stub;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"parent constructor execute"</span>);</span><br><span class="line">        stub = <span class="keyword">new</span> Stub(<span class="string">"parent constructor create object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Stub childStaticObject = <span class="keyword">new</span> Stub(<span class="string">"child static object"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"child static code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"child code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stub childObject = <span class="keyword">new</span> Stub(<span class="string">"child object"</span>);</span><br><span class="line"></span><br><span class="line">    Stub stub;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"child constructor execute"</span>);</span><br><span class="line">        stub = <span class="keyword">new</span> Stub(<span class="string">"child constructor create object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent static object object created</span><br><span class="line">parent static code execute</span><br><span class="line">child static object object created</span><br><span class="line">child static code execute</span><br><span class="line">parent code execute</span><br><span class="line">parent object object created</span><br><span class="line">parent constructor execute</span><br><span class="line">parent constructor create object object created</span><br><span class="line">child code execute</span><br><span class="line">child object object created</span><br><span class="line">child constructor execute</span><br><span class="line">child constructor create object object created</span><br></pre></td></tr></table></figure>



<p>new 一个类，加载这个类，（静态成员变量，静态代码块）</p>
<p>创建对象，（成员变量，代码块）-&gt; 构造器</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>是指一个类是另外一个类的内部成员，定义在某个类的内部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String outerName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OuterClass display"</span>);</span><br><span class="line">        System.out.println(outerName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String innerName;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">            innerName = <span class="string">"inner class"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"InnerClass display"</span>);</span><br><span class="line">            System.out.println(innerName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        outerClass.display();</span><br><span class="line">        InnerClass innerClass = outerClass.<span class="keyword">new</span> InnerClass();</span><br><span class="line">        innerClass.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>内部类对象的创建必须要依赖于外部类的实例化对象</strong></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2021/01/20/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java-网络编程"><a href="#Java-网络编程" class="headerlink" title="Java 网络编程"></a>Java 网络编程</h1><p>计算机网络就是通过硬件设施、传输媒介把分布在不同物理地址上的计算机进行连接，形成一个资源共享和数据传输的网络系统。</p>
<p>两台终端通过网络进行连接时，需要遵守一定的规则，网络协议：</p>
<p>1、语法：数据信息的结构。</p>
<p>2、语义：描述请求、动作和响应。</p>
<p>3、同步：动作的实现顺序。</p>
<p>TCP/IP、IPX/SPX、NetBEUI…</p>
<p>最常用的是 TCP/IP</p>
<p>1、应用层</p>
<p>2、传输层</p>
<p>3、网络层</p>
<p>4、网络接口层（数据链路层+物理层）</p>
<p><img src="/2021/01/20/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1.png" alt="1611152396457"></p>
<a id="more"></a>

<h2 id="IP-和端口"><a href="#IP-和端口" class="headerlink" title="IP 和端口"></a>IP 和端口</h2><p>IP 地址 = {&lt;网络地址&gt;,&lt;主机地址&gt;}</p>
<p>127.0.0.1/localhost 表示本机 IP</p>
<p>Java 中用 InetAddress 来描述 IP 地址，常用方法如下</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getLocalHost()</td>
<td>获取主机的 InetAddress 对象</td>
</tr>
<tr>
<td>getByName(String name)</td>
<td>通过主机名称创建 InetAddress 对象</td>
</tr>
<tr>
<td>getHostName()</td>
<td>获取主机名称</td>
</tr>
<tr>
<td>getHostAddress()</td>
<td>获取主机 IP 地址</td>
</tr>
<tr>
<td>getByAddress(String host,byte[] address)</td>
<td>通过主机名称和 IP 地址创建 InetAddress 对象</td>
</tr>
</tbody></table>
<p>通过端口来区分一台电脑上不同的应用程序</p>
<p>Tomcat 8080</p>
<p>MySQL 3306</p>
<p>Java localhost:3306</p>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>URL 统一资源定位符，定位到网络中一个具体的资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http"</span>,<span class="string">"gimg2.baidu.com"</span>,<span class="string">"/image_search/src=http%3A%2F%2Fimg0.pconline.com.cn%2Fpconline%2F1303%2F12%2F3208685_java-01.jpg&amp;refer=http%3A%2F%2Fimg0.pconline.com.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1613052044&amp;t=f63787304a34d2904a8fe95779be1489"</span>);</span><br><span class="line">System.out.println(url.getHost());</span><br><span class="line">System.out.println(url.getFile());</span><br><span class="line">System.out.println(url.getPath());</span><br><span class="line">System.out.println(url.getPort());</span><br></pre></td></tr></table></figure>

<h1 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h1><p>TCP 协议是面向连接的运输层协议，应用程序使用 TCP 协议之前需要先<strong>建立连接</strong>，才能进行数据的传输，数据传输完毕之后需要释放已经建立的连接，打电话。</p>
<p>TCP 的优点是安全，可靠，通过 TCP 协议传输的数据，不会出现数据丢失的情况，并且数据是按照先后顺序依次到达。</p>
<p>TCP 的缺点是慢，效率低。</p>
<p>Java 中如何开发基于 TCP 协议的应用程序，API，Socket 类</p>
<p>Socket 表示客户端，ServerSocket 表示服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义变量</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        DataInputStream dataInputStream = <span class="keyword">null</span>;</span><br><span class="line">        DataOutputStream dataOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//开启了一个8080服务</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">            System.out.println(<span class="string">"---服务端---"</span>);</span><br><span class="line">            System.out.println(<span class="string">"已启动，等待接收客户端请求..."</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//接收请求</span></span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                inputStream = socket.getInputStream();</span><br><span class="line">                dataInputStream = <span class="keyword">new</span> DataInputStream(inputStream);</span><br><span class="line">                String request = dataInputStream.readUTF();</span><br><span class="line">                System.out.println(<span class="string">"接收到了客户端请求："</span> + request);</span><br><span class="line">                <span class="comment">//做出响应</span></span><br><span class="line">                String response = <span class="string">"Hello World!"</span>;</span><br><span class="line">                outputStream = socket.getOutputStream();</span><br><span class="line">                dataOutputStream = <span class="keyword">new</span> DataOutputStream(outputStream);</span><br><span class="line">                dataOutputStream.writeUTF(response);</span><br><span class="line">                System.out.println(<span class="string">"服务端："</span> + response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dataInputStream.close();</span><br><span class="line">                inputStream.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                serverSocket.close();</span><br><span class="line">                dataOutputStream.close();</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        DataInputStream dataInputStream = <span class="keyword">null</span>;</span><br><span class="line">        DataOutputStream dataOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//发送请求</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>);</span><br><span class="line">            System.out.println(<span class="string">"---客户端---"</span>);</span><br><span class="line">            String request = <span class="string">"你好，服务器！"</span>;</span><br><span class="line">            System.out.println(<span class="string">"客户端说："</span> + request);</span><br><span class="line">            outputStream = socket.getOutputStream();</span><br><span class="line">            dataOutputStream = <span class="keyword">new</span> DataOutputStream(outputStream);</span><br><span class="line">            dataOutputStream.writeUTF(request);</span><br><span class="line">            <span class="comment">//接收响应</span></span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">            dataInputStream = <span class="keyword">new</span> DataInputStream(inputStream);</span><br><span class="line">            String response = dataInputStream.readUTF();</span><br><span class="line">            System.out.println(<span class="string">"服务端回复："</span> + response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dataOutputStream.close();</span><br><span class="line">                outputStream.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                dataInputStream.close();</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h1><p>UDP 所有的连接都是不可靠的，不需要预先建立连接，想发送就发送，想接收就接收，UDP 速度更快，效率更高，但是安全性较差，可能会造成数据的丢失。</p>
<p>没有严格的服务端和客户端区分</p>
<p>DatagramSocket、DatagramPacket</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//接收消息</span></span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(buff, buff.length);</span><br><span class="line">            DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">8181</span>);<span class="comment">//不用去关</span></span><br><span class="line">            datagramSocket.receive(datagramPacket);</span><br><span class="line">            String mess = <span class="keyword">new</span> String(datagramPacket.getData(),<span class="number">0</span>,datagramPacket.getLength());</span><br><span class="line">            System.out.println(<span class="string">"我是TerminalA，接收到了["</span> + datagramPacket.getAddress().getHostAddress() + <span class="string">":"</span> + datagramPacket.getPort()</span><br><span class="line">                    + <span class="string">"]传来的数据："</span> + mess);</span><br><span class="line">            <span class="comment">//发送消息</span></span><br><span class="line">            String reply = <span class="string">"我是TerminalA，已经接收到你发来的消息"</span>;</span><br><span class="line">            SocketAddress socketAddress = datagramPacket.getSocketAddress();</span><br><span class="line">            DatagramPacket datagramPacket2 = <span class="keyword">new</span> DatagramPacket(reply.getBytes(), reply.getBytes().length,socketAddress);</span><br><span class="line">            datagramSocket.send(datagramPacket2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//发送消息</span></span><br><span class="line">            String mess = <span class="string">"我是TerminalB，你好！"</span>;</span><br><span class="line">            <span class="comment">//获取接收方的IP</span></span><br><span class="line">            InetAddress inetAddress = InetAddress.getByName(<span class="string">"localhost"</span>);</span><br><span class="line">            DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(mess.getBytes(), mess.getBytes().length,inetAddress,<span class="number">8181</span>);</span><br><span class="line">            DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">8080</span>);</span><br><span class="line">            datagramSocket.send(datagramPacket);</span><br><span class="line">            <span class="comment">//接收消息</span></span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            DatagramPacket datagramPacket2 = <span class="keyword">new</span> DatagramPacket(buff, buff.length);</span><br><span class="line">            datagramSocket.receive(datagramPacket2);</span><br><span class="line">            String reply = <span class="keyword">new</span> String(datagramPacket2.getData(),<span class="number">0</span>,datagramPacket2.getLength());</span><br><span class="line">            System.out.println(<span class="string">"我是TerminalB，接收到["</span> + datagramPacket2.getSocketAddress() + <span class="string">"]返回的数据："</span> + reply);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>注解、多态的使用、 抽象方法和抽象类</title>
    <url>/2021/01/19/%E6%B3%A8%E8%A7%A3%E3%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>@Override 它告诉编译器这个方法是用来覆盖父类方法的。</p>
<p>@WebServlet Java Web 开发中表示某个类是一个 Servlet，Web 容器就会识别该类，从而加载运行该类，替代传统的 XML 开发，让程序开发更简洁。</p>
<p>注解和注释</p>
<p>注释完全不影响程序的运行，注解会影响程序的运行。</p>
<p>注释是给开发者看的，注解是给程序看的，编译器、框架、Web 容器。</p>
<p><strong>元注解</strong>：用来描述注解的注解，JDK 提供默认的注解，用这些默认注解帮助</p>
<p>开发者自定义需要的注解。</p>
<p>@Target 指定该注解使用的地方（类/方法）</p>
<ul>
<li><p>ElementType.TYPE   给类/接口使用</p>
</li>
<li><p>ElementType.METHOD 给方法使用</p>
</li>
<li><p>ElementType.FIELD 给属性使用</p>
</li>
<li><p>ElementType.PARAMETER 给方法参数使用</p>
</li>
</ul>
<p>@Retention 指定注解的保留域</p>
<ul>
<li><p>RetentionPolicy.SOURCE    编译器处理，处理之后就不再保留</p>
</li>
<li><p>RetentionPolicy.CLASS    class文件处理，类对应的class文件</p>
</li>
<li><p>RetentionPolicy.RUNTIME    JVM 读取，程序运行时使用</p>
</li>
</ul>
<a id="more"></a>

<p>自定义注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InitMethod &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitMethod</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitMethod</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解的解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取使用了注解的目标类</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.java.servlet.InitDemo"</span>);</span><br><span class="line">        <span class="comment">//检查目标类中哪些方法使用注解</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">if</span>(methods!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">               <span class="keyword">boolean</span> isInitMethod = method.isAnnotationPresent(InitMethod<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">               <span class="keyword">if</span>(isInitMethod)&#123;</span><br><span class="line">                   System.out.println(method.getName() + <span class="string">"使用了InitMethod注解"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>一个事物可以有多种表现形态，一个类本质是抽象的，实际使用的时候可以有多种不同的表现形态。</p>
<p>Java 程序中，定义一个抽象的方法，只有方法的声明，但是没有实现。在具体的生成环境中根据不同的需求呈现出不同的业务逻辑，很灵活，扩展性更好，实现了解耦合。</p>
<h1 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h1><p><strong>父类引用指向子类对象</strong>，就是多态的一种表现形式。</p>
<p>多态主要有两种表现形式：</p>
<p>1、方法定义时，形参为父类，调用方法时传入的参数是子类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">settlement</span><span class="params">(Member member)</span></span>&#123;</span><br><span class="line">    member.buyBook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OrdinaryMember ordinaryMember = <span class="keyword">new</span> OrdinaryMember();</span><br><span class="line">cashier.settlement(ordinaryMember);</span><br></pre></td></tr></table></figure>

<p>2、方法定义时，返回值为父类，调用方法时返回的是子类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Member <span class="title">getMember</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"ordinaryMember"</span>.equals(name))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrdinaryMember();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"superMember"</span>.equals(name))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SuperMember();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"参数有误"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(cashier.getMember(<span class="string">"ordinaryMember"</span>));</span><br><span class="line">System.out.println(cashier.getMember(<span class="string">"superMember"</span>));</span><br></pre></td></tr></table></figure>

<p>父子类之间的类型转换分为两种：向上转型、向下转型</p>
<p>向上转型就是将子类对象转为父类类型，自动完成类型转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Member member = <span class="keyword">new</span> OrdinaryMember();</span><br></pre></td></tr></table></figure>

<p>向下转型就是将父类对象转为子类类型，无法完成自动转型，需要手动进行强制转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OrdinaryMember ordinaryMember = (OrdinaryMember) <span class="keyword">new</span> Member();</span><br></pre></td></tr></table></figure>

<p>父类动物 子类猫</p>
<p>猫是动物 </p>
<p>动物是猫</p>
<h1 id="抽象方法和抽象类"><a href="#抽象方法和抽象类" class="headerlink" title="抽象方法和抽象类"></a>抽象方法和抽象类</h1><p>抽象方法：一个方法只有定义，没有具体实现。</p>
<p>抽象类：一个类中一旦出现抽象方法，该类就必须被定义抽象类。</p>
<p>为什么要有抽象方法？</p>
<p>多态的一种应用，多态场景下，需要定义一个父类，对父类进行编程，具体的实现交给子类完成，子类就需要对父类方法进行重写，也就是说父类方法无论怎么定义，最终都会被子类覆盖，那么父类的方法就不需要定义了，所以就需要将该方法定义为抽象的。</p>
<p>为什么一旦有了抽象方法，类就必须是抽象的？</p>
<p>抽象方法只是一种声明，没有具体实现，意味着方法所在的类不能被实例化，因为一旦实例化该类，意味着可以直接调用方法，但是方法是没有实现，所以不能调用。</p>
<p><strong>抽象方法所在的类不能被实例化</strong></p>
<p>将类定义成抽象类，抽象类的特点是不能被实例化。</p>
<p>抽象类/抽象方法如何使用</p>
<p>通过继承来实现多态，定义一个子类，继承抽象类，子类中实现抽象方法，写程序的时候操作子类即可。</p>
<p>如果子类也不想实现抽象方法，只需要将子类也定义成抽象类即可，相当于将实现抽象方法的任务再交给它的子类了。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>集合框架</title>
    <url>/2021/01/19/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p>多个对象、多种类型，进行存储，数组</p>
<p>1、数组长度不可变</p>
<p>2、数组存入的数据类型必须是统一的</p>
<p>集合就是来解决问题的，替代数组来存储多个对象，多种数据类型</p>
<p>集合底层就是一个长度可变、类型可变的动态数组。</p>
<p>集合不是由一个类来完成的，而是由一组接口和类共同构成一个框架体系。</p>
<p>大致分为 3 层，最上层是接口，第二层是实现类，第三层是对集合进行操作的各种工具类。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>集合框架中最基础的父接口，可以存储一组无序、不唯一的对象。</p>
<p>迭代器 遍历集合</p>
<p>Collection 中的各种方法就组成了集合框架的基础</p>
<blockquote>
<p>Collection 的主要子接口</p>
</blockquote>
<ul>
<li>List：存放有序、不唯一的元素</li>
<li>Set：存放无序、唯一的元素</li>
<li>Queue：队列接口</li>
</ul>
<a id="more"></a>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 接口在继承 Collection 接口的基础上进行了 API 的扩展</p>
<p>get(int index)：通过下标找到元素</p>
<p>set(int index,Object o)：在指定下标处插入元素</p>
<p>indexOf(Object o)：找到元素在集合中的下标</p>
<blockquote>
<p>List 接口的实现类</p>
</blockquote>
<p>ArrayList 实现了长度可变的数组，底层是数组。</p>
<p>特点：查询快，增删慢</p>
<p>在内存中是一串连续的空间来存储数据。</p>
<p>LinkedList 底层是基于链表的结构，特点和 ArrayList 恰好相反</p>
<p>特点：查询慢、增删快</p>
<p>内存空间是不连续的，通过指针（前驱指针、后继指针）进行关联</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        arrayList.add(<span class="string">"Hello"</span>);</span><br><span class="line">        arrayList.add(<span class="string">"World"</span>);</span><br><span class="line">        arrayList.add(<span class="string">"JavaSE"</span>);</span><br><span class="line">        arrayList.add(<span class="string">"JavaME"</span>);</span><br><span class="line">        arrayList.add(<span class="string">"JavaEE"</span>);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        System.out.println(arrayList.contains(<span class="string">"Hello"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">            System.out.println(arrayList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line">        <span class="comment">//迭代器，也可以遍历集合</span></span><br><span class="line">        Iterator iterator = arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------"</span>);</span><br><span class="line">        iterator = arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------"</span>);</span><br><span class="line">        System.out.println(arrayList.remove(<span class="number">2</span>));</span><br><span class="line">        System.out.println(arrayList.size());</span><br><span class="line">        arrayList.add(<span class="number">1</span>, <span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        System.out.println(arrayList.indexOf(<span class="string">"abc"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector 是早期的一个 List 实现类，用法基本和 ArrayList 一致。</p>
<p>Vector 是线程安全的集合，Vector 都是用 synchronized 修饰的，</p>
<p>ArrayList 是线程不安全的集合。</p>
<p>线程安全的同时带来的缺陷是效率低、执行速度慢</p>
<p><strong>Vector、ArrayList、LinkedList 的区别？</strong></p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>Stack 是 Vector 的子类，Java 语言对栈这种数据结构的实现，后进先出</p>
<p>Java 借助于 List 容器来实现栈的特性</p>
<p>push 是入栈，将元素添加到栈中</p>
<p>peek 是取出栈顶元素的值，但是栈顶不出栈</p>
<p>pop 是直接让栈顶元素出栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        stack.push(<span class="string">"Hello"</span>);</span><br><span class="line">        stack.push(<span class="string">"JavaSE"</span>);</span><br><span class="line">        stack.push(<span class="string">"JavaME"</span>);</span><br><span class="line">        stack.push(<span class="string">"JavaEE"</span>);</span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; stack.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(stack.get(i));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 是 Collection 的子接口，Set 中存储的数据没有顺序，存储一组<strong>无序且唯一</strong>（数据不会重复）的数据。</p>
<p>List 存储一组有序（元素有下标）且不唯一（元素可以重复）的数据</p>
<p>Set 存储一组无序（元素没有下标）且唯一（元素不能重复）的数据</p>
<h3 id="Set常用的实现类"><a href="#Set常用的实现类" class="headerlink" title="Set常用的实现类"></a>Set常用的实现类</h3><p>HashSet 是开发中使用频率较高的 Set 的实现类，存储一组无序且唯一的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet hashSet = <span class="keyword">new</span> HashSet();</span><br><span class="line">        hashSet.add(<span class="string">"Hello"</span>);</span><br><span class="line">        hashSet.add(<span class="string">"World"</span>);</span><br><span class="line">        System.out.println(hashSet.add(<span class="string">"Java"</span>));</span><br><span class="line">        hashSet.add(<span class="string">"Python"</span>);</span><br><span class="line">        hashSet.add(<span class="string">"C++"</span>);</span><br><span class="line">        hashSet.add(<span class="string">"HTML"</span>);</span><br><span class="line">        System.out.println(hashSet.add(<span class="string">"Java"</span>));</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        System.out.println(hashSet.size());</span><br><span class="line">        System.out.println(<span class="string">"------------------------------------------------"</span>);</span><br><span class="line">        Iterator iterator = hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashSet 是 Set 另外一个实现类，可以存储一组有序且唯一的元素，这里的有序不是说元素有下标，这里的元素依然没有下标，有序是指元素存入的顺序和遍历的顺序是一致的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashSet linkedHashSet = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        linkedHashSet.add(<span class="string">"Hello"</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">"World"</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">"Java"</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">"Python"</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">"C++"</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">"HTML"</span>);</span><br><span class="line">        System.out.println(linkedHashSet);</span><br><span class="line">        Iterator iterator = linkedHashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(linkedHashSet.remove(<span class="string">"C++"</span>));</span><br><span class="line">        System.out.println(linkedHashSet.remove(<span class="string">"C++"</span>));</span><br><span class="line">        System.out.println(linkedHashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>hashCode 即使两个对象不一样，hashCode 的值也有可能相等</p>
<p>不能单纯用 hashCode 相等就来判断两个对象相等，如果 hashCode 值不相等，那么肯定是两个对象，但是 hashCode 值相等，不一定就是一个对象，进一步通过 eqauls 方法进行判断，如果 equals 方法返回 true，才能认为对象相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashSet linkedHashSet = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> A(<span class="number">1</span>));</span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> A(<span class="number">1</span>));</span><br><span class="line">        System.out.println(linkedHashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A&#123;"</span> +</span><br><span class="line">                <span class="string">"num="</span> + num +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>TreeSet 中也可以保存有序元素，这里的有序和 LinkedHashSet 不一样</p>
<p>LinkedHashSet 的有序是指元素的存入顺序和遍历顺序一致（怎么存怎么取）</p>
<p>TreeSet 的有序是指集合内部会<strong>自动给所有元素按照升序进行排队</strong>（大小个排队）</p>
<p>Java 中的接口是用来描述功能的，一个接口就表示某种功能 </p>
<p>java.lang.Comparable 的功能就是比较大小，哪个类实现了 Comparable 接口，就意味着该类的实例化具备比较大小的能力了。</p>
<p><strong>也就是说自动排序的功能依靠Comparable 实现，我们也可以自己写的类实现Comparable 接口自定义排序规则</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按大小排序</span></span><br><span class="line">        TreeSet treeSet = <span class="keyword">new</span> TreeSet();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> B(<span class="number">1</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> B(<span class="number">3</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> B(<span class="number">6</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> B(<span class="number">2</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> B(<span class="number">5</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> B(<span class="number">4</span>));</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B&#123;"</span> +</span><br><span class="line">                <span class="string">"num="</span> + num +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//自己定义排序规则</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A.compareTo(B)</span></span><br><span class="line"><span class="comment">         * 1:A &gt; B</span></span><br><span class="line"><span class="comment">         * 0:A = B</span></span><br><span class="line"><span class="comment">         * -1:A &lt; B</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        B b = (B)o;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.num &gt; b.num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.num == b.num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Set、List 都是 Collection 的子接口，Map 跟 Collection 是兄弟关系，平行的另外一套集合体系。</p>
<p>Set、List、Collection 只能操作单个元素，Map 可以操作一对元素（两个元素），这两个值是键值对的形式（key-value）</p>
<p>value 是真正的值，key 是 value 的别名</p>
<p>HashMap 是 Map 常用的实现类，存储一组无序，key 不可重复，value 可重复的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        hashMap.put(<span class="string">"h"</span>, <span class="string">"Hello"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"w"</span>, <span class="string">"World"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"j"</span>, <span class="string">"Java"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"s"</span>, <span class="string">"JavaSE"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"p"</span>,<span class="string">"Python"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"c"</span>, <span class="string">"C++"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"h2"</span>, <span class="string">"Hello"</span>);</span><br><span class="line">        System.out.println(hashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map 接口的实现类</p>
<ul>
<li>HashMap：存储一组无序，key 不能重复，value 可重复的数据</li>
<li>Hashtable：存储一组无序，key 不能重复，value 可重复的数据</li>
<li>TreeMap：存储一组有序，key 不能重复，value 可重复的数据</li>
</ul>
<p>Hashtable 是早期的一个 Map 实现类，线程安全，HashMap 是线程不安全的，所以</p>
<p>它的效率更高，实际开发中使用更多。</p>
<p>如果场景要求线程安全，则需要使用 Hashtable。</p>
<p>Map 无序，所有没有下标，不能用 for 循环遍历。</p>
<p>Map 没有继承 Iterable 接口，不能迭代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hashtable.put(<span class="string">"h"</span>, <span class="string">"Hello"</span>);</span><br><span class="line">        hashtable.put(<span class="string">"w"</span>, <span class="string">"World"</span>);</span><br><span class="line">        hashtable.put(<span class="string">"j"</span>, <span class="string">"Java"</span>);</span><br><span class="line">        hashtable.put(<span class="string">"p"</span>, <span class="string">"Python"</span>);</span><br><span class="line">        hashtable.put(<span class="string">"c"</span>, <span class="string">"C"</span>);</span><br><span class="line">        System.out.println(hashtable);</span><br><span class="line">        System.out.println(hashtable);</span><br><span class="line">        System.out.println(<span class="string">"----------------------------------------"</span>);</span><br><span class="line">        System.out.println(hashtable.containsKey(<span class="string">"c"</span>));</span><br><span class="line">        System.out.println(hashtable.containsValue(<span class="string">"TT"</span>));</span><br><span class="line">        System.out.println(hashtable.contains(<span class="string">"Hello"</span>));</span><br><span class="line">        <span class="comment">//迭代 Iterator</span></span><br><span class="line">        <span class="comment">//将Map中所有的key取出，返回一个Set</span></span><br><span class="line">        Set set = hashtable.keySet();</span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        Collection values = hashtable.values();</span><br><span class="line">        Iterator iterator1 = values.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator1.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        Set keySet = hashtable.keySet();</span><br><span class="line">        Iterator keyIter = keySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (keyIter.hasNext())&#123;</span><br><span class="line">            Object key = keyIter.next();</span><br><span class="line">            Object value = hashtable.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">"="</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeMap 中存储数据是有序的，有序指的是集合中的数据会按照 key 值进行升序排列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap treeMap = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> A(<span class="number">3</span>), <span class="string">"Java"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> A(<span class="number">1</span>), <span class="string">"JavaME"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> A(<span class="number">2</span>), <span class="string">"Hello"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> A(<span class="number">6</span>), <span class="string">"JavaEE"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> A(<span class="number">4</span>), <span class="string">"World"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> A(<span class="number">5</span>), <span class="string">"JavaSE"</span>);</span><br><span class="line">        System.out.println(treeMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A&#123;"</span> +</span><br><span class="line">                <span class="string">"num="</span> + num +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        A a = (A)o;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.num &lt; a.num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.num == a.num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/2021/01/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>万物皆对象：将 Java 程序的所有参与角色都看成一个个对象，通过对象和对象之间的相互调用来完成系统的功能。</p>
<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><p>面向对象编程思想产生之前，使用的是面向过程的编程思想（面向功能划分的软件结构），自上至下，将一个大问题拆分成很多个小问题，再将小问题拆分成更小的问题，解决问题划分成一个个具体的步骤，分别执行，所有的步骤整合起来就是应用程序的功能，最小粒度细化到了方法的层面。</p>
<p>一个应该程序是由 N 个方法组成的，然后这些方法按一定的顺序执行。</p>
<p>你开车去北京：</p>
<p>1、打开车门</p>
<p>2、坐进车里</p>
<p>3、发动汽车</p>
<p>4、踩油门</p>
<p>……</p>
<p>500</p>
<p>….</p>
<p>1000、到达北京</p>
<p>面向过程的方式步骤繁琐、代码的可维护性很差，我们需要解决这些问题，如何解决？使用新的编程思想来完成，面向对象的编程思想。</p>
<p>面向对象只需要关注整件事情的参与者，即将每一个参与者都抽象成一个对象，再让这些对象完成相互关联即可。</p>
<p>你开车去北京：你、汽车、天津</p>
<p>让汽车载着你去北京，忽略掉过程中的每一个细节，关注点在于 3 个对象之间的关系，面向过程关注点在于每一个细微的步骤。</p>
<p>面向对象的优势在于灵活性和扩展性会更好。</p>
<a id="more"></a>

<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>1、属性：描述对象的静态特征</p>
<p>2、方法：描述对象的动态特征</p>
<p>对象就是用来描述客观存在的一个实体，该实体由一组方法和属性构成。</p>
<p>类是用来组织 Java 程序的，Java 程序是由很多个类组成的。</p>
<p>类是产生对象的模板，所有的对象都是通过类来创建的。</p>
<p>二者关系：</p>
<p>1、类是很多同类型对象的抽象化描述，这些对象具有相同的特征（属性和方法）。</p>
<p>2、对象是类的具体实例。</p>
<p>狗狗是类，隔壁家的旺财是对象。</p>
<p>一个类可以创建出很多个对象，一个对象一般来讲只能属于一个类，但是不够准确，因为类还有继承的概念（狗属于宠物的子类，宠物属于动物的子类），旺财是狗的对象，也可以是宠物的对象，也可以是动物的对象（继承、多态）。</p>
<h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>基本语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">	<span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">public</span> 数据类型 属性名;</span><br><span class="line">	<span class="comment">//定义方法</span></span><br><span class="line">    <span class="keyword">public</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String result = test2();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sout(<span class="string">"123"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="comment">//定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"展示用户信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Java-中的类是如何加载的？"><a href="#Java-中的类是如何加载的？" class="headerlink" title="Java 中的类是如何加载的？"></a>Java 中的类是如何加载的？</h2><p>类加载器 ClassLoader：将字节码文件（不是 Java 文件，而是编译之后的 class 文件）加载到内存（JVM Java虚拟机）中。</p>
<p>主要作用是将 JVM 以外的 Class 字节码文件装载到 JVM 中，进行初始化、执行操作。</p>
<p>Java 类的加载过程分为三步：加载（把文件给机器）、链接（机器读取文件数据）、初始化（根据数据创建对象及其他信息）。</p>
<p><img src="/2021/01/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.png" alt="1611034876559"></p>
<h2 id="ClassLoader-有-4-种类型"><a href="#ClassLoader-有-4-种类型" class="headerlink" title="ClassLoader 有 4 种类型"></a>ClassLoader 有 4 种类型</h2><p>1、<strong>Bootstrap</strong>ClassLoader</p>
<p>2、<strong>Ext</strong>ClassLoader</p>
<p>3、<strong>App</strong>ClassLoader</p>
<p>4、<strong>自定义</strong> ClassLoader</p>
<p>BootstrapClassLoader，C++ 编写，用来加载 Java 的<strong>核心类库</strong>，JDK 中大部分的类，java 开头的类。</p>
<p>ExtClassLoader，Java 编写，用来加载 Java 的<strong>扩展类库</strong>，javax 开头的类。</p>
<p>AppClassLoader，Java 编写，用来加载<strong>程序员自己编写的类</strong>。</p>
<p>自定义 ClassLoader，Java 编写，开发者可以<strong>根据具体的需求来编写类加载器</strong>，可以实现定制化加载。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>跨域问题</title>
    <url>/2020/05/07/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="跨域问题的解决"><a href="#跨域问题的解决" class="headerlink" title="跨域问题的解决"></a>跨域问题的解决</h3><p>所谓同源是指,域名,协议,端口均相同,只要有一个不同,就是跨域 </p>
<p>而对于跨域问题的解决很简单，直接在后端创建一个config文件夹</p>
<p>并在里面放上CrosConfig.java文件，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.springboottest.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrosConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"GET"</span>, <span class="string">"HEAD"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>, <span class="string">"OPTIONS"</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>套用代码</category>
      </categories>
  </entry>
  <entry>
    <title>回调的理解</title>
    <url>/2020/05/12/%E5%9B%9E%E8%B0%83%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="在axios中的回调"><a href="#在axios中的回调" class="headerlink" title="在axios中的回调"></a>在axios中的回调</h3><p>回调就是把函数当作参数传进来，然后你可以调用这个函数，调用的同时你不就可以传些东西出去了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config, success, failure</span>) </span>&#123; <span class="comment">//1.三个参数 后面两个是回调函数</span></span><br><span class="line">  <span class="comment">// 创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'http://123.207.32.32:8000'</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">  instance(config)    <span class="comment">//config为请求参数</span></span><br><span class="line">    .then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(results);</span></span><br><span class="line">      success(results);      <span class="comment">//2.使用传进来的那个函数  并且将results放入这个函数就可以回调传出去</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(error);</span></span><br><span class="line">      failure(error)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">'/home/multidata'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);    <span class="comment">//3. 这里就可以拿到results放入res执行函数，完成回调</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(err);</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2021/01/19/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>Generics （泛型）是指在类定义时<strong>不指定类中信息的具体数据类型</strong>，而是用一个标识符来替代，当外部实例化对象时来指定具体的数据类型。</p>
<p>有了泛型，就可以在定义类的时候不指定具体的类型信息，极大的提升程序的灵活性。</p>
<h2 id="泛型的应用"><a href="#泛型的应用" class="headerlink" title="泛型的应用"></a>泛型的应用</h2><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class 类名&lt;T,D,A...&gt;&#123;</span><br><span class="line">	private T param1;</span><br><span class="line">	private D param2;</span><br><span class="line">	private A param3;</span><br><span class="line">	</span><br><span class="line">	public T test()&#123;</span><br><span class="line">		return T;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Time</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Time&lt;Integer&gt; time = <span class="keyword">new</span> Time();</span><br><span class="line">        time.setValue(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"现在的时间是:"</span> + time.getValue());</span><br><span class="line">        Time&lt;String&gt; time1 = <span class="keyword">new</span> Time();</span><br><span class="line">        time1.setValue(<span class="string">"十点整"</span>);</span><br><span class="line">        System.out.println(<span class="string">"现在的时间是:"</span> + time1.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Time</span>&lt;<span class="title">H</span>,<span class="title">M</span>,<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> H hour;</span><br><span class="line">    <span class="keyword">private</span> M minute;</span><br><span class="line">    <span class="keyword">private</span> S second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> H <span class="title">getHour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHour</span><span class="params">(H hour)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hour = hour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> M <span class="title">getMinute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMinute</span><span class="params">(M minute)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.minute = minute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(S second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Time&lt;String,Integer,Float&gt; time = <span class="keyword">new</span> Time();</span><br><span class="line">        time.setHour(<span class="string">"十点"</span>);</span><br><span class="line">        time.setMinute(<span class="number">10</span>);</span><br><span class="line">        time.setSecond(<span class="number">10.0f</span>);</span><br><span class="line">        System.out.println(<span class="string">"现在时间是   "</span> + time.getHour() + <span class="string">":"</span> + time.getMinute() + <span class="string">":"</span> + time.getSecond());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>当方法的参数泛型不明确的时候，可以使用 ? 替代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list2.add(<span class="string">"a"</span>);</span><br><span class="line">        test(list1);</span><br><span class="line">        test(list2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ArrayList&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="泛型上限和下限"><a href="#泛型上限和下限" class="headerlink" title="泛型上限和下限"></a>泛型上限和下限</h2><p>泛型上限表示实例化的具体数据类型，可以是上限类型的子类或者上限类型本身，用 extends 关键字实现。</p>
<p>类名&lt;? extends 上限类名&gt;</p>
<p>泛型下限表示实例化的具体数据类型，可以是下限类型的父类或者下限类型本身，用 super 关键字实现。</p>
<p>类名&lt;? super 下限类型&gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1(<span class="keyword">new</span> Data&lt;Integer&gt;());</span><br><span class="line">        test1(<span class="keyword">new</span> Data&lt;Number&gt;());</span><br><span class="line">        test1(<span class="keyword">new</span> Data&lt;Double&gt;());</span><br><span class="line">        test2(<span class="keyword">new</span> Data&lt;String&gt;());</span><br><span class="line">        test2(<span class="keyword">new</span> Data&lt;Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Data&lt;? extends Number&gt; data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Data&lt;? <span class="keyword">super</span> String&gt; data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>注释、关键词</title>
    <url>/2021/01/18/%E6%B3%A8%E9%87%8A%E3%80%81%E5%85%B3%E9%94%AE%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h1><p>帮助开发者更好地读懂代码，用<strong>通俗易懂</strong>的语言对代码进行解释说明，方便自己和他人阅读。</p>
<p>注释可以是编程思路，也可以是功能描述或者程序的作用，总之就是对代码的进一步阐述。</p>
<p>注释是专门给程序员看的，计算机直接跳过。</p>
<p>Java 中有几种注释？</p>
<p>1、单行注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注释内容</span><br></pre></td></tr></table></figure>

<p>2、多行注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*注释内容</span><br><span class="line">注释内容</span><br><span class="line">注释内容*&#x2F;</span><br></pre></td></tr></table></figure>

<p>3、文档注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*注释内容</span><br><span class="line">*注释内容</span><br><span class="line">*注释内容</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p>IDEA/Eclipse 可以自动生成文档注释，根据 JDK 的 javadoc 工具来自动生成，直接显示到代码中。</p>
<p>javadoc 注释</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@author</td>
<td>标识作者</td>
</tr>
<tr>
<td>@param</td>
<td>标识方法的参数</td>
</tr>
<tr>
<td>@renturn</td>
<td>标识方法的返回值</td>
</tr>
<tr>
<td>@version</td>
<td>标识版本</td>
</tr>
<tr>
<td>@since</td>
<td>标识从哪个版本开始引入</td>
</tr>
<tr>
<td>@see</td>
<td>标识参考的内容（相关的类有哪些）</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2.关键字"></a>2.关键字</h1><p>Java 语言预先定义好的，具有特殊意义的标识符（单词），是程序的核心组成。</p>
<p>Java 程序：关键字 + JDK类库 + 逻辑代码</p>
<p>关键字构建程序的主体框架</p>
<p>JDK 类库提供某些功能的调用</p>
<p>逻辑代码实现程序的业务逻辑的</p>
<p>IDEA 中橙色字体显示的都是关键字 public、static、int、void…</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>case</td>
<td>与switch组合使用，进行流程控制</td>
</tr>
<tr>
<td>catch</td>
<td>捕获异常</td>
</tr>
<tr>
<td>char</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>class</td>
<td>声明一个类</td>
</tr>
<tr>
<td>continue</td>
<td>跳出循环</td>
</tr>
<tr>
<td>default</td>
<td>与switch组合使用，表示默认值</td>
</tr>
<tr>
<td>do</td>
<td>与while组合使用，表示循环</td>
</tr>
<tr>
<td>double</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>else</td>
<td>与if组合使用，进行流程控制</td>
</tr>
<tr>
<td>enum</td>
<td>枚举类型，Java 中的一种特殊的类</td>
</tr>
<tr>
<td>extends</td>
<td>实现类的继承</td>
</tr>
<tr>
<td>final</td>
<td>修饰常量</td>
</tr>
<tr>
<td>finally</td>
<td>与try、catch搭配使用，处理异常</td>
</tr>
<tr>
<td>float</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>for</td>
<td>循环</td>
</tr>
<tr>
<td>if</td>
<td>流程控制</td>
</tr>
<tr>
<td>implements</td>
<td>实现接口</td>
</tr>
<tr>
<td>import</td>
<td>引入某个类</td>
</tr>
<tr>
<td>int</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>interface</td>
<td>接口</td>
</tr>
<tr>
<td>instanceof</td>
<td>判断对象的类型</td>
</tr>
<tr>
<td>long</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>native</td>
<td>修饰本地方法</td>
</tr>
<tr>
<td>new</td>
<td>创建实例对象</td>
</tr>
<tr>
<td>package</td>
<td>表示包，用来组织 Java 类的</td>
</tr>
<tr>
<td>private</td>
<td>访问权限修饰符，表示私有</td>
</tr>
<tr>
<td>protected</td>
<td>访问权限修饰符，表示保护</td>
</tr>
<tr>
<td>public</td>
<td>访问权限修饰符，表示公开</td>
</tr>
<tr>
<td>return</td>
<td>表示方法的返回值</td>
</tr>
<tr>
<td>short</td>
<td>基本数据类型，短整型</td>
</tr>
<tr>
<td>static</td>
<td>静态修饰符</td>
</tr>
<tr>
<td>super</td>
<td>表示父类的成员</td>
</tr>
<tr>
<td>switch</td>
<td>流程控制，和case组合使用</td>
</tr>
<tr>
<td>synchronized</td>
<td>线程同步</td>
</tr>
<tr>
<td>this</td>
<td>表示调用当前实例对象的成员</td>
</tr>
<tr>
<td>throw</td>
<td>抛出异常，与 try、catch、finally 组合使用</td>
</tr>
<tr>
<td>throws</td>
<td>标识方法中可能抛出的异常</td>
</tr>
<tr>
<td>try</td>
<td>异常处理，与 catch、throw、finally 组合使用</td>
</tr>
<tr>
<td>void</td>
<td>表示当前方法没有返回值</td>
</tr>
<tr>
<td>volatile</td>
<td>确保主内存对所有线程可见</td>
</tr>
<tr>
<td>while</td>
<td>循环结构</td>
</tr>
</tbody></table>
<p>byte 和 bit 的区别？</p>
<p>1 byte（字节）  = 8 bit（一位二进制数 0/1）</p>
<p>100 Kb/s</p>
<p>1KB = 1024 byte</p>
<p>1MB = 1024 KB</p>
<p>1GB = 1024 MB</p>
<p>1TB = 1024 GB</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>使用多线程可以让程序充分利用 CPU 的资源，提高 CPU 的使用效率，从而解决高并发带来的负载均衡问题。</p>
<p>缺点：</p>
<p>1、需要更多的内存空间来支持多线程的运行。</p>
<p>2、多线程并发访问可能会影响数据的准确性。</p>
<p>3、数据被多线程共享，可能出现死锁的情况。</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>计算机<strong>正在运行</strong>的一个独立的应用程序，就是一个进程。</p>
<p>线程是组成进程的基本单位，一个进程是由一个或多个线程组成的，每个线程都可以完成特定的功能。</p>
<p>应用程序是静态概念，进程和线程是动态概念，有创建有销毁，存在也是暂时的，不是永久的。</p>
<p>进程和线程的区别在于运行时是否拥有独立的内存空间，每个进程所占用的内存空间都是独立的。</p>
<p>但是多个线程是共享内存空间的，执行相互独立。</p>
<p>线程的执行必须依赖于进程，单独的线程是无法执行的，由进程控制线程的执行。</p>
<p>多线程是指在一个进程中，多个线程<strong>同时执行</strong>，这里的同时执行并不是真正意义上的同时执行，而是交替执行，系统资源按照时间段分别分配给不同的线程，多个线程是交替执行的，但是因为执行速度太快，感觉是同时执行的。</p>
<a id="more"></a>

<blockquote>
<p>单线程</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.southwind.test;</span><br><span class="line"></span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">            System.out.println(&quot;------------------------MyTest&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Test++++++++++++++++++++++++++"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MyTest myTest = <span class="keyword">new</span> MyTest();</span><br><span class="line">        myTest.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.png" alt="1611041286349"></p>
<p>两个循环按顺序排队执行，循环就是任务，现在只有一个线程来执行这些任务，那么必然是排队执行。</p>
<blockquote>
<p>多线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"------------------------MyTest"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Test++++++++++++++++++++++++++"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.png" alt="1611041302182"></p>
<p>两个循环交替执行，两个线程同时跑两个任务，一个线程跑一个。</p>
<p>如何判断程序是单线程还是多线程？只需要分析程序有几条分支即可。</p>
<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/3.png" alt="1611041328435"></p>
<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/4.png" alt="1611041341960"></p>
<h1 id="Java-中线程的使用"><a href="#Java-中线程的使用" class="headerlink" title="Java 中线程的使用"></a>Java 中线程的使用</h1><h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h2><p>1、创建自定义类继承 Thread 类。</p>
<p>2、重写 Thread 类中的 run 方法，完成线程的业务逻辑代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程类1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;MyThread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程类2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"+++++++++++++++++++++++MyThread2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread2 thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run方法和start方法的区别</p>
<p>run方法相当于普通方法调用，不会产生多线程的效果</p>
<p>start方法是开启线程争夺 CPU 资源，才会产生多线程的效果</p>
<h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><p>1、创建自定义类并实现 Runnable 接口。</p>
<p>2、实现 run 方法，编写该线程的业务逻辑。</p>
<p>3、实例化 Runnable 对象和 Thread 对象，同时将 Runnable 对象赋给 Thread 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"@@@@@@@MyRunnable@@@@@@"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"$$$$$$$$$$$$$$$$$$$$$$MyRunnable2$$$$$$$$$"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable runnable1 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable1);</span><br><span class="line">        MyRunnable2 runnable2 = <span class="keyword">new</span> MyRunnable2();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable2);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际开发中推荐使用实现的方式来完成，因为可以做到解耦合。</p>
<p>Runnable 是专门用来描述任务的接口，Runnable 的实现类就是各种任务的具体实现。</p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>线程有 5 种状态，在特定的情况下，线程可以在不同的状态之间切换。</p>
<p>1、创建状态：实例化一个新的线程对象，未启动。</p>
<p>2、就绪状态：创建好的线程对象调用 start 方法完成启动，进入线程池等待抢占 CPU 资源。</p>
<p>3、运行状态：线程对象获取了 CPU 资源，在分配给它的时间片段内执行任务。</p>
<p>4、阻塞状态：正在运行状态的线程暂停任务的执行，释放所占用的 CPU 资源。</p>
<p>5、终止状态：线程运行完毕或者因为异常导致该线程意外终止运行。</p>
<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/5.png" alt="1611041646841"></p>
<h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><h2 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h2><p>让当前线程暂停执行，从运行状态进入阻塞状态，将 CPU 资源让给其他线程的一种调度方式，通过 sleep 来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"+++++++++++++++++++main"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程合并"><a href="#线程合并" class="headerlink" title="线程合并"></a>线程合并</h2><p>合并的意思是将指定的线程加入到当前线程中，合并成一个线程，由两个线程交替执行变成一个线程中的两个子线程顺序执行。</p>
<p><strong>join()</strong> 实现合并，线程甲和线程乙，甲执行到某个时间节点的时候调用乙的 join 方法，则表示从当前时间开始 CPU 资源被线程乙独占，线程甲进入阻塞状态，直到线程乙执行完毕，线程甲进入就绪状态，等待获取 CPU 资源，进行执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JoinRunnable joinRunnable = <span class="keyword">new</span> JoinRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(joinRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thread.join();<span class="comment">//线程join到main主线程</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"+++++++++++++++++main"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">"----------------JoinRunnable"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>join 方法有重载，区别在于是否传入时间参数，重载的区别？</p>
<p>1、没有时间参数的 join，当子线程合并到主线程之后，子线程会独占 CPU 资源，释放的节点是子线程的任务全部执行完毕。</p>
<p>2、有时间参数的 join，传入的时间参数是 x，当子线程合并到主线程之后，子线程会独占 CPU 资源，释放的节点<strong>从合并的那一刻起到 x 时间结束</strong>，无论子线程是否执行完毕，都会释放 CPU 资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JoinRunnable joinRunnable = <span class="keyword">new</span> JoinRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(joinRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thread.join(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"+++++++++++++++++main"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i + <span class="string">"----------------JoinRunnable"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h2><p>线程礼让是指在某个特定的时间点，<strong>让线程暂停</strong>抢占 CPU 资源的行为，从运行状态或就绪状态来到阻塞状态，从而讲 CPU 资源让给其他线程来使用。</p>
<p><strong>只是在某个时间点去礼让，过了这个时间点，依然会争夺 CPU 资源。</strong></p>
<p>yield()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        YieldThread1 yieldThread1 = <span class="keyword">new</span> YieldThread1();</span><br><span class="line">        yieldThread1.setName(<span class="string">"线程甲"</span>);</span><br><span class="line">        YieldThread2 yieldThread2 = <span class="keyword">new</span> YieldThread2();</span><br><span class="line">        yieldThread2.setName(<span class="string">"线程乙"</span>);</span><br><span class="line">        yieldThread1.start();</span><br><span class="line">        yieldThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YieldThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                Thread.currentThread().yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"------"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YieldThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"------"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>同步和异步的区别</p>
<p>同步是指排队按顺序，依次执行，第一步执行完毕，才能执行第二步，等。</p>
<p>异步是指没有顺序不排队，同时执行，第一步没有执行，就可以执行第二步，不用等。</p>
<p>线程同步是对资源的一种保护，当多个线程同时访问某个资源时，多个线程必须排队使用，而不能一起使用。</p>
<p>多个线程同时操作一个共享数据，可能会导致<strong>数据不准确</strong>的情况。</p>
<p>要解决这个问题，如何解决？使用线程同步。</p>
<p><strong>synchronized</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(account);</span><br><span class="line">        thread1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(account);</span><br><span class="line">        thread2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer num = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test2<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"是当前的第"</span> + num + <span class="string">"位访客"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(account);</span><br><span class="line">        thread1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(account);</span><br><span class="line">        thread2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer num = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"是当前的第"</span> + num + <span class="string">"位访客"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 可以修饰实例方法，也可以修饰静态方法，两者在使用上是有区别的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    SynchronizedTest.test();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是否同步关键看多个线程对象使用的是否是同一个资源，如果是同一个资源（共享），加锁，就会实现同步，如果不是同一个资源，数据不共享，加锁，也不会实现同步。</p>
<h1 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h1><p>单例模式是 Java 设计模式中的一种，确保对象只有一份。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建了单例对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多线程场景下，需要使用线程同步来确保单例模式的正确性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建了单例对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建了单例对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//必须是一个唯一的对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SingletonDemo<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>JMM Java Memory Model</p>
<p><strong>volatile</strong> 的作用是可以使内存中的数据对线程可见</p>
<p>分为主内存和工作内存，数据是存在主内存中，要操作数据的时候，首先会将数据从主内存中<strong>复制一份</strong>到工作内存中，在工作内存中来操作该数据。</p>
<p>主内存中的数据对线程不可见，线程访问的都是副本。</p>
<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/6.png" alt="1611042870649"></p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁是一种互斥状态，多个线程同时执行，并且需要获取多个资源，但是每个线程都不愿意释放自己的资源，都在渴望其他线程释放资源为己所用，导致所有线程全程处于阻塞状态，谁都无法往下运行。</p>
<p>如何破解死锁？率先有一个线程愿意让出资源，让其他线程先执行，只要有一个线程执行完任务，就会释放它所占用的资源，其他线程的问题迎刃而解。</p>
<p>死锁演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Data data1 = <span class="keyword">new</span> Data();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Data data2 = <span class="keyword">new</span> Data();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;<span class="comment">//第一个人</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"获取到了data1，等待获取data2"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (data1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (data2)&#123;<span class="comment">//能拿到两根筷子，可以吃饭</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"用餐完毕！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">2</span>)&#123;<span class="comment">//第二个人</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"获取到了data2，等待获取data1"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (data2)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (data1)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"用餐完毕！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeadLockRunnable runnable1 = <span class="keyword">new</span> DeadLockRunnable();</span><br><span class="line">        runnable1.num = <span class="number">1</span>;</span><br><span class="line">        DeadLockRunnable runnable2 = <span class="keyword">new</span> DeadLockRunnable();</span><br><span class="line">        runnable2.num = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable1,<span class="string">"张三"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable2,<span class="string">"李四"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时发生死锁，进入死循环</p>
<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/7.png" alt="1611044862338"></p>
<p>想要破解死锁，就需要有人做出牺牲</p>
<p>例如将进程睡眠两秒，直接释放出一个人所持资源</p>
<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/8.png" alt="1611045172224"></p>
<p>但要尽量不让多个线程竞争同一资源</p>
<h1 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h1><p><strong>ReentrantLock</strong> 是对 synchronzied 的升级，synchronized 是通过 JVM 实现的（关键字），ReentrantLock 是通过 JDK 实现的（通过 API 操作，调对象的方法）。</p>
<p>重入锁可以给同一个资源添<strong>加多把锁</strong>，解锁方式也是有区别的。</p>
<p>synchronized 是自动解锁（当线程执行完任务之后会自动释放锁）</p>
<p>ReentrantLock 必须<strong>手动释放锁</strong></p>
<p>lock()和unlock()必须成对出现，上多少把锁就得解多少把锁，也不能多解锁，否则都会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"是当前的第"</span> + num + <span class="string">"位访客"</span>);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        <span class="keyword">new</span> Thread(account,<span class="string">"张三"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(account,<span class="string">"李四"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 还具备<strong>限时性</strong>的特点，是指某个线程在一定时间内能否获取到锁</p>
<p>tryLock(long time,TimeUnit unit) boolean</p>
<p>//枚举 也是一种类，类的对象值数量是固定，有限的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3s之内要获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"拿到了锁"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"没有拿到锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;<span class="comment">//判断当前线程是否拥有该锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeLock timeLock = <span class="keyword">new</span> TimeLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(timeLock,<span class="string">"线程1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(timeLock,<span class="string">"线程2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>多线程模式下的 Java 网络编程</title>
    <url>/2021/01/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84-Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>多线程模式下的 Java 网络编程</p>
<p>总体过程：</p>
<p>​    对于服务端：先创建出服务端ServerSocket，服务端一直等待接收客户端的socket，一旦接收到了，传入到写好的ServerRunnable中，通过多线程的方式将服务端接收的信息跑起来</p>
<p>​    对于客户端：直接创建多个ClientRunnable以多线程形式跑起来，在run()中实现对服务端的发送消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">            System.out.println(<span class="string">"服务器已启动..."</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                <span class="comment">//开启子线程完成操作</span></span><br><span class="line">                ServerRunnable serverRunnable = <span class="keyword">new</span> ServerRunnable(socket);</span><br><span class="line">                <span class="keyword">new</span> Thread(serverRunnable).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerRunnable</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        DataInputStream dataInputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">this</span>.socket.getInputStream();</span><br><span class="line">            dataInputStream = <span class="keyword">new</span> DataInputStream(inputStream);</span><br><span class="line">            String message = dataInputStream.readUTF();</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">                dataInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ClientRunnable clientRunnable = <span class="keyword">new</span> ClientRunnable(i);</span><br><span class="line">            <span class="keyword">new</span> Thread(clientRunnable).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientRunnable</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        DataOutputStream dataOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8080</span>);</span><br><span class="line">            String message = <span class="string">"我是客户端"</span>+<span class="keyword">this</span>.num;</span><br><span class="line">            outputStream = socket.getOutputStream();</span><br><span class="line">            dataOutputStream = <span class="keyword">new</span> DataOutputStream(outputStream);</span><br><span class="line">            dataOutputStream.writeUTF(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">                dataOutputStream.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>文本标签、图片、超链接</title>
    <url>/2021/01/21/%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE%E3%80%81%E5%9B%BE%E7%89%87%E3%80%81%E8%B6%85%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h1><p>HTML+CSS+JavaScript+jQuery</p>
<p>HTML：搭建网页的基本元素</p>
<p>CSS：对网页进行美化</p>
<p>HTML 是盖房子，CSS 就是装修，HTML + CSS 写出来的代码是静态页面</p>
<p>JavaScript JS 是一种脚本语言，JS 让静态页面变成动态页面</p>
<p>HTML：超文本标记语言 文本 图片 视频 音频</p>
<p>HTML 语法很简单，用 tag 标签对的形式来组装程序，后缀 html,htm</p>
<p>HTML 支持单标签和标签对</p>
<p>单标签是指只需要一个标签 <br></p>
<p>标签对 <html></html> </p><h1></h1><p></p>
<p>当标签需要包裹某些内容的时候，使用标签对，如果不需要包裹内容，直接用单标签即可</p>
<a id="more"></a>

<h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h1  h6</span><br></pre></td></tr></table></figure>

<p>段落</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p</span><br></pre></td></tr></table></figure>

<p>换行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">br</span><br></pre></td></tr></table></figure>

<p>注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 注释内容 --&gt;</span><br></pre></td></tr></table></figure>

<p>字体加粗</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;strong&gt;&lt;&#x2F;strong&gt; &lt;b&gt;&lt;&#x2F;b&gt;</span><br></pre></td></tr></table></figure>

<p>常用文本格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;i&gt;&lt;&#x2F;i&gt;  斜体</span><br><span class="line">&lt;em&gt;&lt;&#x2F;em&gt; 斜体</span><br><span class="line">&lt;del&gt;&lt;&#x2F;del&gt; 横线</span><br><span class="line">&lt;ins&gt;&lt;&#x2F;ins&gt; 下划线</span><br><span class="line">&lt;sub&gt;&lt;&#x2F;sub&gt; 下浮</span><br><span class="line">&lt;sup&gt;&lt;&#x2F;sup&gt; 上浮</span><br></pre></td></tr></table></figure>



<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><img>

<p>属性</p>
<p>src：图片路径</p>
<p>alt：当图片不显示的时候，用来替代图片的文字</p>
<p>title：鼠标悬停到图片上之后，显示的文字</p>
<p>width：图片的宽度，自适应进行缩放，当宽度改变的时候，高度会跟着等比例缩放</p>
<p>height：图片的高度，自适应进行缩放，当宽度改变的时候，高度会跟着等比例缩放</p>
<p>width 和 height 单独使用，会等比例缩放，如果同时使用，就会拉伸或压缩图片</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/1.png"</span> <span class="attr">alt</span>=<span class="string">"服务器开小差了..."</span> <span class="attr">title</span>=<span class="string">"这是一张图片"</span> <span class="attr">width</span>=<span class="string">"100px"</span> <span class="attr">height</span>=<span class="string">"600px"</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a></a></p>
<p>属性：</p>
<p>href：跳转的目标路径、</p>
<p>title：鼠标悬停显示的文字</p>
<p>target：跳转的形式</p>
<p>​    1、_self 默认值，在当前页面刷新</p>
<p>​    2、_blank，打开新的页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.bilibili.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/b.png"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>HTML常用标签、CSS</title>
    <url>/2021/01/21/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E3%80%81CSS/</url>
    <content><![CDATA[<h1 id="HTML-常用标签"><a href="#HTML-常用标签" class="headerlink" title="HTML 常用标签"></a>HTML 常用标签</h1><blockquote>
<p>table</p>
</blockquote>
<p>table 构建表格的基本标签</p>
<p>tr 构建行元素</p>
<p>td 构建列元素</p>
<p>colspan    列合并  colspan=”3”合并三列</p>
<p>rowspan   行合并  rowspan=”2”合并两行</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>6<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>7<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>8<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>9<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">width</span>=<span class="string">"500px"</span> <span class="attr">style</span>=<span class="string">"text-align: center;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"3"</span>&gt;</span>学生成绩<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>语文<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>98<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>95<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>语文<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>88<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>91<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>form 表单</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;要提交的后台url&quot;&gt;</span><br><span class="line">	各种标签</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>input</p>
</blockquote>
<p>最常用的一个表单标签，用来让用户输入信息的</p>
<p>用 type 属性来区分不同的输入框，</p>
<p>text 普通的文本输入框</p>
<p>password 密码输入框</p>
<p>radio 单选框</p>
<p>checkbox 复选框</p>
<p>file 文件上传</p>
<p>submit 提交表单</p>
<p>reset 重置表单</p>
<p><img src="/2021/01/21/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E3%80%81CSS/1.png" alt="1611212421711"></p>
<blockquote>
<p>select</p>
</blockquote>
<blockquote>
<p>option</p>
</blockquote>
<blockquote>
<p>textarea</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pwd"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>男 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>兴趣:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> <span class="attr">value</span>=<span class="string">"code"</span>&gt;</span>撸代码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> <span class="attr">value</span>=<span class="string">"game"</span>&gt;</span>打游戏<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"movie"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>&gt;</span>看电影<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>头像:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"img"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>城市:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>简介:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"重置"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>样式层叠表，定义如何显示 HTML 元素，给 HTML 元素设置字体，宽度，高度，背景色等等样式信息。</p>
<p>装修 HTML ，让它更好看。</p>
<p>使用有 3 种方式：</p>
<p>1、行内样式，直接在 HTML 标签内部添加 style 属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 500px;height: 500px;background-color: red;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、内部样式，在 head 种添加 style 代码块</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、外部样式，单独创建一个 css 文件，引入到 HTML 中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"index.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 和 html 可以在不同的目录下，只需要通过相对路径来引用即可。</p>
<p>基本语法</p>
<p>选择器+声明</p>
<p>selector{</p>
<p>​    //declaration1</p>
<p>​    //declaration2</p>
<p>​    //declaration3</p>
<p>}</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见的选择器：</p>
<p>1、标签选择器，直接通过 HTML 标签选中元素，会直接选中所有的标签</p>
<p>2、类选择器，通过 class 属性选中元素，多个元素可以公用同一个 class</p>
<p>3、ID 选择器，通过 id 属性选中元素，每个元素的 id 都是唯一的</p>
<p>优先级：标签选择器 &lt; 类选择器 &lt; ID 选择器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>这是我的第一个HTML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"index.css"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"t1"</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"t1"</span>&gt;</span>C++<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"t1"</span> <span class="attr">id</span>=<span class="string">"d1"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.t1</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#d1</span>&#123;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">63px</span>;</span><br><span class="line">	<span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见的声明：</p>
<blockquote>
<p>文字属性</p>
</blockquote>
<p>font-size 设置字体大小</p>
<p>font-family 设置字体类型</p>
<p>font-weight 设置字体加粗</p>
<p>text-indent 文本缩进</p>
<p>text-align 水平方向位置</p>
<p>word-spacing 单词间隔（只针对英文单词，中文无效）</p>
<p>letter-spacing 字母间隔（对中文有效）</p>
<p>text-transform 英文大小写转换</p>
<p>normal（不转换） uppercase（转大写） lowercase（转小写） capitalize（单词首字母大写）</p>
<p>text-decoration </p>
<p>underline overline line-through</p>
<p>line-height 设置行高</p>
<blockquote>
<p>边框属性</p>
</blockquote>
<p>border-color 边框颜色</p>
<p>border-width 边框宽度</p>
<p>border-style 边框样式 </p>
<ul>
<li>solid 实线</li>
<li>dashed 虚线</li>
<li>dotted 点线</li>
<li>double 双线</li>
<li>ridge 菱形</li>
</ul>
<p>border: 10px solid yellow;</p>
<p>border-top 上边框</p>
<p>border-bottom 下边框</p>
<p>border-left 左边框</p>
<p>border-right 右边框</p>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>1.JVM与Java体系结构</title>
    <url>/2021/02/12/1-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="JVM与Java体系结构"><a href="#JVM与Java体系结构" class="headerlink" title="JVM与Java体系结构"></a>JVM与Java体系结构</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为Java工程师的你曾被伤害过吗？你是否也遇到过这些问题？</p>
<p>运行着的线上系统突然卡死，系统无法访问，甚至直接OOMM！</p>
<ul>
<li>想解决线上JVM GC问题，但却无从下手。</li>
<li>新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了</li>
<li>每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</li>
</ul>
<p><img src="/2021/02/12/1-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/1.png" alt="image-20200704111417472"></p>
<p>大部分Java开发人员，除会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。</p>
<a id="more"></a>

<p>一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。</p>
<p>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言</p>
<p><img src="/2021/02/12/1-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2.png" alt="image-20200704112119729"></p>
<h2 id="架构师每天都在思考什么？"><a href="#架构师每天都在思考什么？" class="headerlink" title="架构师每天都在思考什么？"></a>架构师每天都在思考什么？</h2><ul>
<li>应该如何让我的系统更快？</li>
<li>如何避免系统出现瓶颈？</li>
</ul>
<p>知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？</p>
<ul>
<li>参与现有系统的性能优化，重构，保证平台性能和稳定性</li>
<li>根据业务场景和需求，决定技术方向，做技术选型</li>
<li>能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求</li>
<li>解决各类潜在系统风险，核心功能的架构与代码编写</li>
<li>分析系统瓶颈，解决各种疑难杂症，性能调优等</li>
</ul>
<h2 id="为什么要学习JVM"><a href="#为什么要学习JVM" class="headerlink" title="为什么要学习JVM"></a>为什么要学习JVM</h2><ul>
<li><p>面试的需要（BATJ、TMD，PKQ等面试都爱问）</p>
</li>
<li><p>中高级程序员必备技能</p>
<ul>
<li>项目管理、调优的需求</li>
</ul>
</li>
<li><p>追求极客的精神</p>
<ul>
<li>比如：垃圾回收算法、JIT（及时编译器）、底层原理</li>
</ul>
</li>
</ul>
<h2 id="Java-vs-C"><a href="#Java-vs-C" class="headerlink" title="Java vs C++"></a>Java vs C++</h2><p>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</p>
<p><img src="/2021/02/12/1-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/3.png" alt="image-20200704112700211"></p>
<p>C语言需要自己来分配内存和回收内存，Java全部交给JVM进行分配和回收。</p>
<h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p><img src="/2021/02/12/1-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4.png" alt="image-20200704145340513"></p>
<h2 id="Java生态圈"><a href="#Java生态圈" class="headerlink" title="Java生态圈"></a>Java生态圈</h2><p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p>
<ul>
<li><p>作为一个平台，Java虚拟机扮演着举足轻重的作用</p>
<ul>
<li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li>
</ul>
</li>
<li><p>作为灯种文化，Java几乎成为了“开源”的代名词。</p>
<ul>
<li>第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。</li>
<li>就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。</li>
</ul>
</li>
<li><p>作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</p>
</li>
</ul>
<p><img src="/2021/02/12/1-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/5.png" alt="image-20200704151731216"></p>
<p>每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理</p>
<p><img src="/2021/02/12/1-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6.png" alt="image-20200704152052489"></p>
<p>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。</p>
<p>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p>
<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。</p>
<p><strong>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</strong></p>
<p>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式—Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</p>
<h2 id="多语言混合编程"><a href="#多语言混合编程" class="headerlink" title="多语言混合编程"></a>多语言混合编程</h2><p>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</p>
<p>试想一下，在一个项目之中，并行处理用clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</p>
<p>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</p>
<h2 id="Java发展的重大事件"><a href="#Java发展的重大事件" class="headerlink" title="Java发展的重大事件"></a>Java发展的重大事件</h2><ul>
<li><p>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为oak，后期命名为Java</p>
</li>
<li><p>1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。</p>
</li>
<li><p>1996年1月23日sun Microsystems发布了JDK 1.0。</p>
</li>
<li><p>1998年，JDK1.2版本发布。同时，sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。</p>
</li>
<li><p>2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。</p>
</li>
<li><p>2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。</p>
</li>
<li><p>2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。</p>
</li>
<li><p>2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。</p>
</li>
<li><p>2006年，JDK6发布。同年，Java开源并建立了openJDK。顺理成章，Hotspot虚拟机也成为了openJDK中的默认虚拟机。</p>
</li>
<li><p>2007年，Java平台迎来了新伙伴Clojure。</p>
</li>
<li><p>2008年，oracle收购了BEA，得到了JRockit虚拟机。</p>
</li>
<li><p>2009年，Twitter宣布把后台大部分程序从Ruby迁移到scala，这是Java平台的又一次大规模应用。</p>
</li>
<li><p>2010年，oracle收购了sun，获得Java商标和最真价值的HotSpot虚拟机。此时，oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit</p>
</li>
<li><p>2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。</p>
</li>
<li><p>2017年，JDK9发布。将G1设置为默认Gc，替代CMS</p>
</li>
<li><p>同年，IBM的J9开源，形成了现在的open J9社区</p>
</li>
<li><p>2018年，Android的Java侵权案判决，Google赔偿oracle计88亿美元</p>
</li>
<li><p>同年，oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会</p>
</li>
<li><p>同年，JDK11发布，LTS版本的JDK，发布革命性的zGc，调整JDK授权许可</p>
</li>
<li><p>2019年，JDK12发布，加入RedHat领导开发的shenandoah GC</p>
</li>
</ul>
<p><img src="/2021/02/12/1-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/7.png" alt="image-20200704182035810"></p>
<p>在JDK11之前，oracleJDK中还会存在一些openJDK中没有的、闭源的功能。但在JDK11中，我们可以认为openJDK和oracleJDK代码实质上已经完全一致的程度。</p>
<h2 id="虚拟机与Java虚拟机"><a href="#虚拟机与Java虚拟机" class="headerlink" title="虚拟机与Java虚拟机"></a>虚拟机与Java虚拟机</h2><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p>
<ul>
<li>大名鼎鼎的Visual Box，Mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</li>
<li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li>
</ul>
<p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
<h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><p>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</p>
<p>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p>
<p>Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</p>
<p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<p>特点：</p>
<ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<h2 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h2><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互</p>
<p><img src="/2021/02/12/1-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/8.png" alt="image-20200704183048061"></p>
<p>Java的体系结构</p>
<p><img src="/2021/02/12/1-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/9.png" alt="image-20200704183236169"></p>
<h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><ul>
<li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li>
<li>它采用解释器与即时编译器并存的架构。</li>
<li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</li>
</ul>
<p><img src="/2021/02/12/1-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/10.png" alt="image-20200704183436495"></p>
<p>执行引擎包含三部分：解释器，及时编译器，垃圾回收器</p>
<h2 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h2><p><img src="/2021/02/12/1-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20200704210429535.png" alt="image-20200704210429535"></p>
<p>只是能生成被Java虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了</p>
<h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：</p>
<p>基于栈式架构的特点</p>
<ul>
<li>设计和实现更简单，适用于资源受限的系统；</li>
<li>避开了寄存器的分配难题：使用零地址指令方式分配。</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
<p>基于寄存器架构的特点</p>
<ul>
<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li>
<li>指令集架构则完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令去完成一项操作。</li>
<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>同样执行2+3这种逻辑操作，其指令分别如下：</p>
<p>基于栈的计算流程（以Java虚拟机为例）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iconst_2 //常量2入栈</span><br><span class="line">istore_1</span><br><span class="line">iconst_3 // 常量3入栈</span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd //常量2/3出栈，执行相加</span><br><span class="line">istore_0 // 结果5入栈</span><br></pre></td></tr></table></figure>

<p>而基于寄存器的计算流程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mov eax,2 //将eax寄存器的值设为1</span><br><span class="line">add eax,3 //使eax寄存器的值加3</span><br></pre></td></tr></table></figure>

<h3 id="字节码反编译"><a href="#字节码反编译" class="headerlink" title="字节码反编译"></a>字节码反编译</h3><p>我们编写一个简单的代码，然后查看一下字节码的反编译后的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackStruTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们找到编译后的 class文件，使用下列命令进行反编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javap -v StackStruTest.class</span><br></pre></td></tr></table></figure>

<p>得到的文件为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack&#x3D;2, locals&#x3D;4, args_size&#x3D;1</span><br><span class="line">       0: iconst_2</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_3</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iload_1</span><br><span class="line">       5: iload_2</span><br><span class="line">       6: iadd</span><br><span class="line">       7: istore_3</span><br><span class="line">       8: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 9: 0</span><br><span class="line">      line 10: 2</span><br><span class="line">      line 11: 4</span><br><span class="line">      line 12: 8</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0       9     0  args   [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">          2       7     1     i   I</span><br><span class="line">          4       5     2     j   I</span><br><span class="line">          8       1     3     k   I</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>跨平台性</li>
<li>指令集小</li>
<li>指令多</li>
<li>执行性能比寄存器差</li>
</ul>
<h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p>
<h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li>
<li>程序开始执行时他才运行，程序结束时他就停止。</li>
<li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li>
</ul>
<h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下的几种情况：</p>
<ul>
<li><p>程序正常执行结束</p>
</li>
<li><p>程序在执行过程中遇到了异常或错误而异常终止</p>
</li>
<li><p>由于操作系统用现错误而导致Java虚拟机进程终止</p>
</li>
<li><p>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</p>
</li>
<li><p>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</p>
</li>
</ul>
<h2 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul>
<li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。</li>
<li>这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。</li>
<li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li>
<li>现在hotspot内置了此虚拟机。</li>
</ul>
<h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><p>为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。<br>Exact Memory Management：准确式内存管理</p>
<ul>
<li>也可以叫Non-Conservative/Accurate Memory Management</li>
<li>虚拟机可以知道内存中某个位置的数据具体是什么类型。|</li>
</ul>
<p>具备现代高性能虚拟机的维形</p>
<ul>
<li>热点探测（寻找出热点代码进行缓存）</li>
<li>编译器与解释器混合工作模式</li>
</ul>
<p>只在solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</p>
<h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><p>HotSpot历史</p>
<ul>
<li>最初由一家名为“Longview Technologies”的小公司设计</li>
<li>1997年，此公司被sun收购；2009年，Sun公司被甲骨文收购。</li>
<li>JDK1.3时，HotSpot VM成为默认虚拟机</li>
</ul>
<p>目前Hotspot占有绝对的市场地位，称霸武林。</p>
<ul>
<li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li>
<li>Sun/oracle JDK和openJDK的默认虚拟机</li>
<li>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的Gc机制。（比如其他两个商用虚机都没有方法区的概念）</li>
</ul>
<p>从服务器、桌面到移动端、嵌入式都有应用。</p>
<p>名称中的HotSpot指的就是它的热点代码探测技术。</p>
<ul>
<li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li>
<li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li>
</ul>
<h3 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h3><p>专注于服务器端应用</p>
<ul>
<li>它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li>
</ul>
<p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</p>
<ul>
<li>使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li>
</ul>
<p>优势：全面的Java运行时解决方案组合</p>
<ul>
<li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li>
<li>MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li>
</ul>
<p>2008年，JRockit被oracle收购。</p>
<p>oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p>
<p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p>
<h3 id="IBM的J9"><a href="#IBM的J9" class="headerlink" title="IBM的J9"></a>IBM的J9</h3><p>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</p>
<p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</p>
<p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</p>
<p>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给EClipse基金会管理，也称为Eclipse OpenJ9</p>
<p>OpenJDK   -&gt; 是JDK开源了，包括了虚拟机</p>
<h3 id="KVM和CDC-CLDC-Hotspot"><a href="#KVM和CDC-CLDC-Hotspot" class="headerlink" title="KVM和CDC / CLDC  Hotspot"></a>KVM和CDC / CLDC  Hotspot</h3><p>oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Angroid和ioS二分天下。</p>
<p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p>
<ul>
<li>智能控制器、传感器</li>
<li>老人手机、经济欠发达地区的功能手机</li>
</ul>
<p>所有的虚拟机的原则：一次编译，到处运行。</p>
<h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><p>前面三大“高性能Java虚拟机”使用在通用硬件平台上这里Azu1VW和BEALiquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机I</p>
<ul>
<li>高性能Java虚拟机中的战斗机。</li>
</ul>
<p>Azul VM是Azu1Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的ava虚拟机。</p>
<p>每个Azu1VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</p>
<p>2010年，AzulSystems公司开始从硬件转向软件，发布了自己的zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</p>
<h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><p>高性能Java虚拟机中的战斗机。</p>
<p>BEA公司开发的，直接运行在自家Hypervisor系统上Liquid VM即是现在的JRockit VE（Virtual Edition），</p>
<p>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</p>
<p>随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</p>
<h3 id="Apache-Marmony"><a href="#Apache-Marmony" class="headerlink" title="Apache Marmony"></a>Apache Marmony</h3><p>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</p>
<p>它是IElf和Inte1联合开发的开源JVM，受到同样开源的openJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</p>
<p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p>
<h3 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h3><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p>
<p>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</p>
<p>1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软windowsXPSP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。</p>
<h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><p>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p>
<p>基于openJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。</p>
<p>基于openJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</p>
<ul>
<li>创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且Gc不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。</li>
<li>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</li>
<li>使用crc32指令实现JvM intrinsic降低JNI的调用开销</li>
<li>PMU hardware的Java profiling tool和诊断协助功能</li>
<li>针对大数据场景的ZenGc </li>
</ul>
<p>taobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能</p>
<p>目前已经在淘宝、天猫上线，把oracle官方JvM版本全部替换了。</p>
<h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><p>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</p>
<p>Dalvik y只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范</p>
<p>不能直接执行Java的Class文件</p>
<p>基于寄存器架构，不是jvm的栈架构。</p>
<p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p>
<ul>
<li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li>
</ul>
<p>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</p>
<h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><p>2018年4月，oracle Labs公开了GraalvM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</p>
<p>GraalVM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”<br>的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</p>
<p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p>
<p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p>
<p>如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以oracle HotSpot VM为默认虚拟机。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>2.类加载子系统</title>
    <url>/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200705080719531.png" alt="image-20200705080719531"></p>
<p>完整图如下</p>
<p><img src="/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200705080911284.png" alt="image-20200705080911284"></p>
<p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p>
<ul>
<li><p>类加载器</p>
</li>
<li><p>执行引擎</p>
<a id="more"></a>

</li>
</ul>
<h2 id="类加载器子系统作用"><a href="#类加载器子系统作用" class="headerlink" title="类加载器子系统作用"></a>类加载器子系统作用</h2><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有<strong>特定的文件标识</strong>。</p>
<p>ClassLoader<strong>只负责class文件的加载</strong>，至于它<strong>是否可以运行，则由执行引擎决定</strong>。</p>
<p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p>
<p><img src="/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200705081813409.png" alt="image-20200705081813409"></p>
<ul>
<li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li>
<li>class file加载到JVM中，被称为DNA元数据模板，<strong>放在方法区</strong>。</li>
<li>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li>
</ul>
<p><img src="/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200705081913538.png" alt="image-20200705081913538"></p>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p>例如下面的一段简单的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我已经被加载啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的加载过程是怎么样的呢?<strong>(加载、链接、初始化)</strong></p>
<p><img src="/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200705082255746.png" alt="image-20200705082255746"></p>
<p>完整的流程图如下所示</p>
<p><img src="/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200705082601441.png" alt="image-20200705082601441"></p>
<h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p>通过一个<strong>全类名</strong>获取定义此类的<strong>二进制字节流</strong></p>
<p>将这个字节流所代表的<strong>静态存储结构转化为方法区的运行时数据结构</strong></p>
<p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<h4 id="加载class文件的方式"><a href="#加载class文件的方式" class="headerlink" title="加载class文件的方式"></a>加载class文件的方式</h4><ul>
<li>从本地系统中直接加载</li>
<li>通过网络获取，典型场景：Web Applet</li>
<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>
<li>运行时计算生成，使用最多的是：动态代理技术</li>
<li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li>
<li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li>
</ul>
<h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证 Verify"></a>验证 Verify</h4><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。例如<strong>Class文件开头的特定的文件标识可用于验证</strong></p>
<p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
<blockquote>
<p>工具：Binary Viewer查看</p>
</blockquote>
<p><img src="/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200705084038680.png" alt="image-20200705084038680"></p>
<p>如果出现<strong>不合法的字节码文件，那么将会验证不通过</strong></p>
<p>同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p>
<p><img src="/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200705090237078.png" alt="image-20200705090237078"></p>
<p>安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了</p>
<p><img src="/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200705090328171.png" alt="image-20200705090328171"></p>
<h4 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备 Prepare"></a>准备 Prepare</h4><p>为类变量分配内存并且<strong>设置该类变量的默认初始值，即零值</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的变量a在准备阶段会赋初始值，但不是1，而是0。</p>
<p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</p>
<p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p>
<p>例如下面这段代码</p>
<h4 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析 Resolve"></a>解析 Resolve</h4><p>将常量池内的<strong>符号引用转换为直接引用</strong>的过程。</p>
<p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p>
<p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>初始化阶段就是<strong>执行类构造器法<clinit>（）的过程</clinit></strong>。</p>
<p>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p>
<ul>
<li>也就是说，<strong>当我们代码中包含static变量或静态代码块的时候，就会有clinit方法</strong></li>
</ul>
<p>构造器方法中指令按语句在源文件中出现的顺序执行。</p>
<p><clinit>（）不同于类的构造器。（关联：<strong>构造器是虚拟机视角下的<init>（）</init></strong>）若该类具有父类，JVM会保证子类的<clinit>（）执行前，父类的<clinit>（）已经执行完毕。</clinit></clinit></clinit></p>
<ul>
<li>任何一个类在声明后，都有生成一个构造器，默认是空参构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;<span class="comment">//在这里num被初始化了，下面就不会报错</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        number = <span class="number">20</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(number);  <span class="comment">//报错，非法的前向引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;<span class="comment">//在prepare阶段会被初始化为0 接着再--&gt;20 --&gt;10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassInitTest.num); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(ClassInitTest.number); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于涉及到父类时候的变量赋值过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Son.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iconst_1</span><br><span class="line">putstatic <span class="comment">#2 &lt;com/xzs/java/chapter02/ClinitTest1$Father.A&gt;</span></span><br><span class="line">iconst_2</span><br><span class="line">putstatic <span class="comment">#2 &lt;com/xzs/java/chapter02/ClinitTest1$Father.A&gt;</span></span><br><span class="line"><span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<p>虚拟机必须保证一个类的<clinit>（）方法<strong>在多线程下被同步加锁</strong>。</clinit></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 线程t1开始"</span>);</span><br><span class="line">            <span class="keyword">new</span> DeadThread();</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 线程t2开始"</span>);</span><br><span class="line">            <span class="keyword">new</span> DeadThread();</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 初始化当前类"</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程t1开始</span><br><span class="line">线程t2开始</span><br><span class="line">线程t2 初始化当前类</span><br></pre></td></tr></table></figure>

<p>从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程</p>
<h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p>JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将<strong>所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>。</p>
<p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p>
<p><img src="/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200705094149223.png" alt="image-20200705094149223"></p>
<p><strong>这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系</strong>。</p>
<p>我们通过一个类，获取它不同的加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器(就是AppClassLoader)</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取其上层的：扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 试图获取：根加载器</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取自定义加载器</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取String类型的加载器</span></span><br><span class="line">        ClassLoader classLoader1 = String<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(classLoader1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的结果，从结果可以看出<strong>Bootstrap加载器无法直接通过代码获取</strong>，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说<strong>Java的核心类库都是使用根加载器进行加载的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul>
<li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li>
<li>它<strong>用来加载Java的核心库</strong>（JAVAHOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>
<li>并不继承自ava.lang.ClassLoader，没有父加载器。</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li>
</ul>
<h3 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h3><ul>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>
<li><strong>加载Java的扩展库</strong></li>
</ul>
<h3 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h3><ul>
<li>javI语言编写，由sun.misc.LaunchersAppClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li><strong>该类加载是程序中默认的类加载器</strong>，一般来说，Java应用的类都是由它来完成加载</li>
<li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li>
</ul>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。<br>为什么要自定义类加载器？</p>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄漏</li>
</ul>
<p>用户自定义类加载器实现步骤：</p>
<ul>
<li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>
</ul>
<h3 id="查看根加载器所能加载的目录"><a href="#查看根加载器所能加载的目录" class="headerlink" title="查看根加载器所能加载的目录"></a>查看根加载器所能加载的目录</h3><p>刚刚我们通过概念了解到了，根加载器只能够加载 java /lib目录下的class，我们通过下面代码验证一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*********启动类加载器************"</span>);</span><br><span class="line">        <span class="comment">// 获取BootstrapClassLoader 能够加载的API的路径</span></span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            System.out.println(url.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器</span></span><br><span class="line">        ClassLoader classLoader = Provider<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*********启动类加载器************</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;lib&#x2F;resources.jar</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;lib&#x2F;rt.jar</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;lib&#x2F;sunrsasign.jar</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;lib&#x2F;jsse.jar</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;lib&#x2F;jce.jar</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;lib&#x2F;charsets.jar</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;lib&#x2F;jfr.jar</span><br><span class="line">file:&#x2F;E:&#x2F;Software&#x2F;JDK1.8&#x2F;Java&#x2F;jre&#x2F;classes</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>
<p><img src="/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200705103516138.png" alt="image-20200705103516138"></p>
<p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p>
<p><img src="/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200705103636003.png" alt="image-20200705103636003"></p>
<p>获取ClassLoader的途径</p>
<ul>
<li>获取当前ClassLoader：clazz.getClassLoader()</li>
<li>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</li>
<li>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</li>
<li>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</li>
</ul>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul>
<li><strong>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</strong>；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ul>
<p><img src="/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200705105151258.png" alt="image-20200705105151258"></p>
<h3 id="双亲委派机制举例"><a href="#双亲委派机制举例" class="headerlink" title="双亲委派机制举例"></a>双亲委派机制举例</h3><p>当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。</p>
<p><img src="/2021/02/13/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200705105810107.png" alt="image-20200705105810107"></p>
<h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中<strong>会先加载jdk自带的文件</strong>（rt.jar包中java\lang\String.class），报错信息说String没有main方法，就是因为加载的是JDK中rt.jar包中的string类。这样<strong>可以保证对java核心源代码的保护，这就是沙箱安全机制</strong>。</p>
<h3 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p>
<ul>
<li><strong>避免类的重复加载</strong></li>
<li>保护程序安全，<strong>防止核心API被随意篡改</strong><ul>
<li>自定义类：java.lang.String</li>
<li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li>
</ul>
</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="如何判断两个class对象是否相同"><a href="#如何判断两个class对象是否相同" class="headerlink" title="如何判断两个class对象是否相同"></a>如何判断两个class对象是否相同</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的<strong>完整类名必须一致</strong>，包括包名。</li>
<li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong>。</li>
</ul>
<p>换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p>
<p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
<h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为：主动使用和被动使用。<br>主动使用，又分为七种情况：</p>
<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（比如：Class.forName（”com.xzs.Test”））</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始提供的动态语言支持：</li>
<li>java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li>
</ul>
<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>10.对象实例化内存布局与访问定位</title>
    <url>/2021/02/13/10-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="对象实例化内存布局与访问定位"><a href="#对象实例化内存布局与访问定位" class="headerlink" title="对象实例化内存布局与访问定位"></a>对象实例化内存布局与访问定位</h1><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>美团：</p>
<ul>
<li>对象在JVM中是怎么存储的？</li>
<li>对象头信息里面有哪些东西？</li>
</ul>
<p>蚂蚁金服：</p>
<ul>
<li>Java对象头有什么？</li>
</ul>
<p>从对象创建的方式 和 步骤开始说</p>
<p><img src="/2021/02/13/10-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20200709095356247.png" alt="image-20200709095356247"></p>
<h3 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h3><ul>
<li><p>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</p>
</li>
<li><p>Class的newInstance方法：被标记为过时的方法，因为只能调用空参构造器,权限必须是public</p>
</li>
<li><p>Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器，权限没有要求</p>
</li>
<li><p>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</p>
</li>
<li><p>使用反序列化：从文件中、从网络中获取一个对象的二进制流</p>
</li>
<li><p>第三方库 Objenesis</p>
<a id="more"></a>

</li>
</ul>
<h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><h4 id="判断对象对应的类是否加载、链接、初始化"><a href="#判断对象对应的类是否加载、链接、初始化" class="headerlink" title="判断对象对应的类是否加载、链接、初始化"></a>判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，链接和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p>
<h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p>
<ul>
<li><p>如果内存规整：指针碰撞</p>
</li>
<li><p>如果内存不规整：空闲列表法</p>
<ul>
<li>虚拟表需要维护一个列表</li>
<li>空闲列表分配</li>
</ul>
</li>
</ul>
<p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p>
<p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是<strong>把指针指向空闲那边挪动一段与对象大小相等的距离罢了</strong>。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p>
<p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机<strong>维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。</strong>这种分配方式成为了 “空闲列表（Free List）”</p>
<p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<h4 id="处理并发问题"><a href="#处理并发问题" class="headerlink" title="处理并发问题"></a>处理并发问题</h4><ul>
<li>采用<strong>CAS配上失败重试</strong>保证更新的原子性</li>
<li>每个线程<strong>预先分配TLAB</strong> - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）<ul>
<li>在Eden区给每个线程分配一块区域</li>
</ul>
</li>
</ul>
<h4 id="初始化分配到的内存"><a href="#初始化分配到的内存" class="headerlink" title="初始化分配到的内存"></a>初始化分配到的内存</h4><p>给对象属性赋值的操作</p>
<ul>
<li><p>属性的默认初始化</p>
</li>
<li><p>显示初始化</p>
</li>
<li><p>代码块中的初始化</p>
</li>
<li><p>构造器初始化</p>
</li>
<li><p>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p>
</li>
</ul>
<h4 id="设置对象的对象头"><a href="#设置对象的对象头" class="headerlink" title="设置对象的对象头"></a>设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
<h4 id="执行init方法进行初始化"><a href="#执行init方法进行初始化" class="headerlink" title="执行init方法进行初始化"></a>执行init方法进行初始化</h4><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p>
<p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p>
<h3 id="对象实例化的过程总结"><a href="#对象实例化的过程总结" class="headerlink" title="对象实例化的过程总结"></a>对象实例化的过程总结</h3><ul>
<li>加载类元信息</li>
<li>为对象分配内存</li>
<li>处理并发问题</li>
<li>属性的默认初始化（零值初始化）</li>
<li>设置对象头信息</li>
<li>属性的显示初始化、代码块中初始化、构造器中初始化</li>
</ul>
<h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><img src="/2021/02/13/10-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20200709151033237.png" alt="image-20200709151033237"></p>
<h3 id="对象头-面试重点"><a href="#对象头-面试重点" class="headerlink" title="对象头(面试重点)"></a>对象头(面试重点)</h3><p>对象头包含了两部分，分别是 运行时元数据（Mark Word）和 类型指针</p>
<blockquote>
<p>如果是数组，还需要记录数组的长度</p>
</blockquote>
<h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><ul>
<li>哈希值（HashCode）</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳</li>
</ul>
<h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据InstanceKlass，确定该对象所属的类型。<strong>指向的其实是方法区中存放的类元信息</strong></p>
<h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>它是对象真正存储的有效信息，包括<strong>程序代码中定义的各种类型的字段</strong>(包括从父类继承下来的和本身拥有的字段)。</p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul>
<li>相同宽度的字段总是被分配在一起</li>
<li>父类中定义的变量会出现在子类之前</li>
<li>如果CompactFields参数为True(默认为true)，子类的窄变量可能插入到父类变量的空隙</li>
</ul>
<h3 id="对齐填充-Padding"><a href="#对齐填充-Padding" class="headerlink" title="对齐填充(Padding)"></a>对齐填充(Padding)</h3><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/2021/02/13/10-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20200709152801713.png" alt="image-20200709152801713"></p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p>
<p><img src="/2021/02/13/10-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20200709164149920.png" alt="image-20200709164149920"></p>
<h3 id="对象访问的两种方式-面试题"><a href="#对象访问的两种方式-面试题" class="headerlink" title="对象访问的两种方式(面试题)"></a>对象访问的两种方式(面试题)</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p><img src="/2021/02/13/10-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20200709164342002.png" alt="image-20200709164342002"></p>
<p>句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>reference中存储稳定句柄地址，<strong>对象被移动</strong>（垃圾收集时移动对象很普遍）时<strong>只会改变句柄中</strong>实例数据指针即可，<strong>reference本身不需要被修改</strong></p>
<h4 id="直接指针（HotSpot采用）"><a href="#直接指针（HotSpot采用）" class="headerlink" title="直接指针（HotSpot采用）"></a>直接指针（HotSpot采用）</h4><p><img src="/2021/02/13/10-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20200709164350466.png" alt="image-20200709164350466"></p>
<p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>3.运行时数据区概述及线程</title>
    <url>/2021/02/13/3-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="运行时数据区概述及线程"><a href="#运行时数据区概述及线程" class="headerlink" title="运行时数据区概述及线程"></a>运行时数据区概述及线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p>
<p><img src="/2021/02/13/3-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/image-20200705111640511.png" alt="image-20200705111640511"></p>
<p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p>
<p><img src="/2021/02/13/3-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/image-20200705111843003.png" alt="image-20200705111843003"></p>
<a id="more"></a>

<p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p>
<p><img src="/2021/02/13/3-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/image-20200705112036630.png" alt="image-20200705112036630"></p>
<p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>
<blockquote>
<p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p>
</blockquote>
<p>运行时数据区的完整图</p>
<p><img src="/2021/02/13/3-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/image-20200705112416101.png" alt="image-20200705112416101"></p>
<p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>
<p>灰色的为单独线程私有的，红色的(堆和方法区是进程的，所以由多个线程共享)为多个线程共享的。即：</p>
<ul>
<li>每个线程：独立包括程序计数器、栈、本地栈。</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
<p><img src="/2021/02/13/3-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/image-20200705112601211.png" alt="image-20200705112601211"></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。<br>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p>
<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li>
</ul>
<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</p>
<h3 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h3><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。|<br>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p>
<ul>
<li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li>
<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li>
<li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li>
<li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li>
<li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>4.程序计数器</title>
    <url>/2021/02/13/4-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</strong></p>
<p><img src="/2021/02/13/4-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/image-20200705155551919.png" alt="image-20200705155551919"></p>
<p>它是一块<strong>很小的内存空间</strong>，几乎可以忽略不记。也是<strong>运行速度最快</strong>的存储区域。</p>
<p><strong>唯一不会出现OOM</strong>的空间</p>
<p>在JVM规范中，每个线程都有它自己的程序计数器，是<strong>线程私有的</strong>，生命周期与线程的生命周期保持一致。</p>
<p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会<strong>存储当前线程正在执行的Java方法的JVM指令地址</strong>；或者，<strong>如果是在执行native方法，则是未指定值</strong>（undefned）。</p>
<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。</p>
<p>可把PC寄存器当作游标、集合的迭代器</p>
<a id="more"></a>

<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>PC寄存器<strong>用来存储指向下一条指令的地址</strong>，也即将要执行的指令代码。<strong>由执行引擎读取下一条指令</strong>。</p>
<p><img src="/2021/02/13/4-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/image-20200705155728557.png" alt="image-20200705155728557"></p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>我们首先写一个简单的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0: bipush        10</span><br><span class="line">2: istore_1</span><br><span class="line">3: bipush        20</span><br><span class="line">5: istore_2</span><br><span class="line">6: iload_1</span><br><span class="line">7: iload_2</span><br><span class="line">8: iadd</span><br><span class="line">9: istore_3</span><br><span class="line">10: <span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<p>通过PC寄存器，我们就可以知道当前程序执行到哪一步了 <img src="/2021/02/13/4-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/image-20200705161007423.png" alt="image-20200705161007423"></p>
<h2 id="使用PC寄存器存储字节码指令地址有什么用呢？-面试题"><a href="#使用PC寄存器存储字节码指令地址有什么用呢？-面试题" class="headerlink" title="使用PC寄存器存储字节码指令地址有什么用呢？(面试题)"></a>使用PC寄存器存储字节码指令地址有什么用呢？(面试题)</h2><p>因为<strong>CPU需要不停的切换各个线程</strong>，这时候<strong>切换回来以后，就得知道接着从哪开始继续执行</strong>。</p>
<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p><img src="/2021/02/13/4-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/image-20200705161409533.png" alt="image-20200705161409533"></p>
<h2 id="PC寄存器为什么被设定为私有的？-面试题"><a href="#PC寄存器为什么被设定为私有的？-面试题" class="headerlink" title="PC寄存器为什么被设定为私有的？(面试题)"></a>PC寄存器为什么被设定为私有的？(面试题)</h2><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然<strong>导致经常中断或恢复</strong>，如何保证分毫无差呢？为<strong>了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>
<p><strong>一个线程过来执行，接下来要切换了，他记录了下一条要执行的是5，接下来另一个进程过来，执行了一会，又要被切换了，如果PC是共享的，他就把5改为7，又走了，接下来线程1回来就不知道他原来运行到哪里了。</strong></p>
<p><img src="/2021/02/13/4-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/image-20200705161812542.png" alt="image-20200705161812542"></p>
<h2 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>
<p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>
<p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>
<p><img src="/2021/02/13/4-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/image-20200705161849557.png" alt="image-20200705161849557"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>5.虚拟机栈</title>
    <url>/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
    <content><![CDATA[<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。<br>        <strong>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</strong></p>
<p>有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆（heap）和Java栈（stack）？为什么？</p>
<p>首先栈是运行时的单位，而堆是存储的单位</p>
<ul>
<li><strong>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</strong></li>
<li><strong>堆解决的是数据存储的问题，即数据怎么放，放哪里</strong></li>
</ul>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200705163928652.png" alt="image-20200705163928652"></p>
<a id="more"></a>

<h3 id="Java虚拟机栈是什么"><a href="#Java虚拟机栈是什么" class="headerlink" title="Java虚拟机栈是什么"></a>Java虚拟机栈是什么</h3><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存<strong>一个个的栈帧（Stack Frame），对应着一次次的Java方法调用</strong>。</p>
<blockquote>
<p>是线程私有的</p>
</blockquote>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200705164722033.png" alt="image-20200705164722033"></p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<blockquote>
<p>局部变量，它是相比于成员变量来说的（或属性）</p>
<p>基本数据类型变量 VS  引用类型变量（类、数组、接口）</p>
</blockquote>
<h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><p>栈是一种快速有效的分配存储方式，访问速度仅次于罹序计数器。JVM直接对Java栈的操作只有两个：</p>
<ul>
<li>每个方法执行，伴随着进栈（入栈、压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
<p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200705165025382.png" alt="image-20200705165025382"></p>
<h3 id="开发中遇到哪些异常？-面试题"><a href="#开发中遇到哪些异常？-面试题" class="headerlink" title="开发中遇到哪些异常？(面试题)"></a>开发中遇到哪些异常？(面试题)</h3><p>栈中可能出现的异常</p>
<p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p>
<p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果<strong>线程请求分配的栈容量超过Java虚拟机栈允许的最大容量</strong>，Java虚拟机将会抛出一个<strong>StackoverflowError(栈溢出) 异常</strong>。</p>
<p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展S的时候无法申请到足够的内存，或者在创建新的线程时<strong>没有足够的内存去创建对应的虚拟机栈</strong>，那Java虚拟机将会抛出一个 <strong>OutOfMemoryError(OOM) 异常</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;S</span><br><span class="line">        System.out.println(count++);</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当栈深度达到9803的时候，就出现栈内存空间不足</p>
<h3 id="设置栈内存大小-调优"><a href="#设置栈内存大小-调优" class="headerlink" title="设置栈内存大小(调优)"></a>设置栈内存大小(调优)</h3><p>可<strong>参数调优</strong></p>
<p>我们可以<strong>使用参数 -Xss选项来设置线程的最大栈空间</strong>，栈的大小直接决定了<strong>函数调用的最大可达深度</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1k</span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/1611833851664.png" alt="1611833851664"></p>
<h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</p>
<p>在这个线程上正在执行的<strong>每个方法都各自对应一个栈帧</strong>（Stack Frame）。</p>
<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
<h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。在这个线程上正在执行的每个方法都各自对应一个栈颜（Stack Frame）。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
<blockquote>
<p>OOP的基本概念：类和对象</p>
<p>类中基本结构：field（属性、字段、域）、method</p>
</blockquote>
<p>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循“先进后出”/“后进先出”原则。</p>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有<strong>当前正在执行的方法的栈帧（栈顶栈帧）是有效的</strong>，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧相对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）。</p>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
<p>如果在该方法中<strong>调用了其他方法</strong>，对应的<strong>新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧</strong>。</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200705203142545.png" alt="image-20200705203142545"></p>
<p>下面写一个简单的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackFrameTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法1的开始"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = method02();</span><br><span class="line">        System.out.println(<span class="string">"方法1的结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法2的开始"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = method03();;</span><br><span class="line">        System.out.println(<span class="string">"方法2的结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法3的开始"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">30</span>;</span><br><span class="line">        System.out.println(<span class="string">"方法3的结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">方法1的开始</span><br><span class="line">方法2的开始</span><br><span class="line">方法3的开始</span><br><span class="line">方法3的结束</span><br><span class="line">方法2的结束</span><br><span class="line">方法1的结束</span><br></pre></td></tr></table></figure>

<p>满足栈先进后出的概念，通过Idea的 DEBUG，能够看到栈信息</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200705203916023.png" alt="image-20200705203916023"></p>
<h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
<p>Java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</strong></p>
<h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p><strong>每个栈帧中又分为：</strong></p>
<ul>
<li><strong>局部变量表</strong>（Local Variables）</li>
<li><strong>操作数栈</strong>（operand Stack）（或表达式栈）</li>
<li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200705204836977.png" alt="image-20200705204836977"></p>
<p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200705205443993.png" alt="image-20200705205443993"></p>
<h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>局部变量表：Local Variables，被称之为局部变量数组或本地变量表</p>
<p><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>。这些数据类型包括八种基本数据类型、对象引用（reference），以及returnAddress类型。</p>
<p>由于局部变量表是建立在线程的栈上，是线程的<strong>私有数据，因此不存在数据安全问题</strong></p>
<p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。<strong>在方法运行期间是不会改变局部变量表的大小的</strong>。</p>
<p><strong>方法嵌套调用的次数由栈的大小决定</strong>。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p>
<p><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</strong>。</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/1611843432405.png" alt="1611843432405"></p>
<h3 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h3><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p>
<p>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p>
<p>在局部变量表里，<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（1ong和double）占用两个slot。</strong></p>
<blockquote>
<p>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。<br>long和double则占据两个slot。</p>
</blockquote>
<p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
<p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的<strong>局部变量将会按照顺序被复制到局部变量表中的每一个slot上</strong></p>
<p>如果需要访问局部变量表中一个64bit的局部变量值时，<strong>只需要使用前一个索引即可</strong>。（比如：访问1ong或doub1e类型变量）</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200705212454445.png" alt="image-20200705212454445"></p>
<p>如果当前帧是由构造方法或者实例方法(非静态方法)创建的，那么<strong>该对象引用this将会存放在index为0的s1ot处</strong>，其余的参数按照参数表顺序继续排列。<strong>所以静态方法里不能使用this，就是因为局部变量表里没有this</strong></p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/1611844541368.png" alt="1611844541368"></p>
<p>​                    double占据两个slot 3和4，引用他用开始索引3</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/1611844644534.png" alt="1611844644534"></p>
<h3 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/1611844738584.png" alt="1611844738584"></p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/1611844839189.png" alt="1611844839189"></p>
<p>b出了方法块就挂掉了，接下来c继续复用b的slot</p>
<h3 id="静态变量与局部变量的对比-面试题"><a href="#静态变量与局部变量的对比-面试题" class="headerlink" title="静态变量与局部变量的对比(面试题)"></a>静态变量与局部变量的对比(面试题)</h3><p>变量的分类：</p>
<ul>
<li>按数据类型分：基本数据类型、引用数据类型</li>
<li>按类中声明的位置分：成员变量（类变量，实例变量）、局部变量<ul>
<li>类变量：linking的prepare阶段，给类变量<strong>默认赋值</strong>，init阶段给类变量显示赋值即静态代码块</li>
<li>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行<strong>默认赋值</strong></li>
<li>局部变量：在使用前<strong>必须进行显式赋值</strong>，不然编译不通过。</li>
</ul>
</li>
</ul>
<p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p>
<p>我们知道<strong>类变量表有两次初始化</strong>的机会，第一次是在“<strong>准备阶段</strong>”，执行系统初始化，对类变量设置零值，另一次则是在“<strong>初始化</strong>”阶段，赋予程序员在代码中定义的初始值。</p>
<p>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化</strong>的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。<strong>所以方法里面的变量必须手动赋初始值</strong></p>
<p>在栈帧中，与<strong>性能调优</strong>关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
<p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</strong></p>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>操作数栈：Operand Stack</p>
<p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 <strong>操作数栈</strong>，也可以称之为 <strong>表达式栈</strong>（Expression Stack）</p>
<p>操作数栈，在方法执行过程中，根据字节码指令，往栈中<strong>写入数据或提取数据，即入栈（push）和 出栈（pop）</strong></p>
<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706090618332.png" alt="image-20200706090618332"></p>
<p>代码举例</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706090833697.png" alt="image-20200706090833697"></p>
<p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></p>
<p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈是空的</strong>。.</p>
<blockquote>
<p>这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的</p>
</blockquote>
<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。</p>
<p>栈中的任何一个元素都是可以任意的Java数据类型</p>
<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
<p>操作数栈<strong>并非采用访问索引的方式来进行数据访问的</strong>，而是<strong>只能通过标准的入栈和出栈操作</strong>来完成一次数据访问</p>
<p><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令。</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|</p>
<p>另外，我们说Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈。</p>
<h3 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h3><p>我们给定代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> k = i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javap 命令反编译class文件： javap -v 类名.class</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706092610730.png" alt="image-20200706092610730"></p>
<blockquote>
<p>byte、short、char、boolean 内部都是使用int型来进行保存的</p>
<p>从上面的代码我们可以知道，我们都是通过bipush对操作数 15 和  8进行入栈操作</p>
<p>同时使用的是 iadd方法进行相加操作，i -&gt; 代表的就是 int，也就是int类型的加法操作</p>
</blockquote>
<p>执行流程如下所示：</p>
<p>首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入栈。</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706093131621.png" alt="image-20200706093131621"></p>
<p>执行完后，让PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706093251302.png" alt="image-20200706093251302"></p>
<blockquote>
<p>为什么局部变量表不是从0开始的呢？</p>
<p>其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了~</p>
</blockquote>
<p>然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706093646406.png" alt="image-20200706093646406"></p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706093751711.png" alt="image-20200706093751711"></p>
<p>然后从局部变量表中，依次将数据放在操作数栈中</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706093859191.png" alt="image-20200706093859191"></p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706093921573.png" alt="image-20200706093921573"></p>
<p>然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706094046782.png" alt="image-20200706094046782"></p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706094109629.png" alt="image-20200706094109629"></p>
<p>最后PC寄存器的位置指向10，也就是return方法，则直接退出方法</p>
<p>i++和++i的区别</p>
<h2 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h2><p>栈顶缓存技术：Top Of Stack Cashing</p>
<p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</strong>。</p>
<blockquote>
<p>寄存器：指令更少，执行速度快</p>
</blockquote>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>动态链接：Dynamic Linking</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706100311886.png" alt="image-20200706100311886"></p>
<blockquote>
<p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p>
</blockquote>
<p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</p>
<p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。</p>
<p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706101251847.png" alt="image-20200706101251847"></p>
<blockquote>
<p>为什么需要运行时常量池？</p>
<p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</p>
<p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p>
</blockquote>
<h2 id="方法调用：解析与分配"><a href="#方法调用：解析与分配" class="headerlink" title="方法调用：解析与分配"></a>方法调用：解析与分配</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法<strong>在编译期可知</strong>，且运行期保持不变时，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接</p>
<h4 id="动态链接-1"><a href="#动态链接-1" class="headerlink" title="动态链接"></a>动态链接</h4><p>如果被调用的方法<strong>在编译期无法被确定下来</strong>，也就是说，只能够在程序<strong>运行期</strong>将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p>
<h3 id="绑定机制"><a href="#绑定机制" class="headerlink" title="绑定机制"></a>绑定机制</h3><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<h4 id="早期绑定"><a href="#早期绑定" class="headerlink" title="早期绑定"></a>早期绑定</h4><p>早期绑定就是指被调用的目标方法如果<strong>在编译期可知</strong>，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
<h4 id="晚期绑定"><a href="#晚期绑定" class="headerlink" title="晚期绑定"></a>晚期绑定</h4><p>如果被调用的方法<strong>在编译期无法被确定下来</strong>，只能够在程序<strong>运行期</strong>根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p>
<h3 id="早晚期绑定的发展历史"><a href="#早晚期绑定的发展历史" class="headerlink" title="早晚期绑定的发展历史"></a>早晚期绑定的发展历史</h3><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p>
<p><strong>Java中任何一个普通的方法其实都具备虚函数的特征</strong>，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中<strong>不希望某个方法拥有虚函数</strong>的特征时，则可以使用关键字<strong>final</strong>来标记这个方法。</p>
<h3 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h3><ul>
<li>如果方法在编译期就确定了具体的调用版本，这个版本在<strong>运行时是不可变的</strong>。这样的方法称为<strong>非虚方法</strong>。</li>
<li><strong>静态方法、私有方法、fina1方法、实例构造器、父类方法都是非虚方法。</strong></li>
<li><strong>其他方法称为虚方法</strong>。</li>
</ul>
<blockquote>
<p>子类对象的多态的使用前提</p>
<ul>
<li>类的继承关系</li>
<li>方法的重写</li>
</ul>
</blockquote>
<p>虚拟机中提供了以下几条方法调用指令：</p>
<h4 id="普通调用指令："><a href="#普通调用指令：" class="headerlink" title="普通调用指令："></a>普通调用指令：</h4><ul>
<li><strong>invokestatic：调用静态方法，解析阶段确定唯一方法版本</strong></li>
<li><strong>invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本</init></strong></li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ul>
<h4 id="动态调用指令："><a href="#动态调用指令：" class="headerlink" title="动态调用指令："></a>动态调用指令：</h4><ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。</p>
<h3 id="invokednamic指令"><a href="#invokednamic指令" class="headerlink" title="invokednamic指令"></a>invokednamic指令</h3><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java<strong>为了实现动态类型语言支持(因为Java是静态类型语言)</strong>而做的一种改进。</p>
<p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p>
<p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p>
<h3 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h3><p>动态类型语言和静态类型语言两者的<strong>区别就在于对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
<blockquote>
<p>Java：String info = “mogu blog”;     (Java是静态类型语言的，会先编译就进行类型检查)</p>
<p>JS：var name = “shkstart”;    var name = 10;    （运行时才进行检查，动态的）</p>
</blockquote>
<h3 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h3><h4 id="Java-语言中方法重写的本质："><a href="#Java-语言中方法重写的本质：" class="headerlink" title="Java 语言中方法重写的本质："></a>Java 语言中方法重写的本质：</h4><ul>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError 异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodsrror异常。</li>
</ul>
<p><strong>依次往上找他所重写调用的方法</strong></p>
<h4 id="IllegalAccessError介绍"><a href="#IllegalAccessError介绍" class="headerlink" title="IllegalAccessError介绍"></a>IllegalAccessError介绍</h4><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
<h3 id="方法的调用：虚方法表"><a href="#方法的调用：虚方法表" class="headerlink" title="方法的调用：虚方法表"></a>方法的调用：虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表<br>（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</p>
<p>每个类中都有一个虚方法表，<strong>表中存放着各个方法的实际入口</strong>。</p>
<p>虚方法表是什么时候被创建的呢？</p>
<p>虚方法表会<strong>在类加载的链接阶段</strong>被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706144954070.png" alt="image-20200706144954070"></p>
<p>如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中。</p>
<h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p><strong>存放调用该方法的pc寄存器的值，就交给执行引擎执行接下来的指令。</strong>一个方法的结束，有两种方式：</p>
<ul>
<li><p>正常执行完成</p>
</li>
<li><p>出现未处理的异常，非正常退出</p>
</li>
</ul>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。<strong>方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</strong>而通过<strong>异常退出</strong>的，返回地址是要<strong>通过异常表</strong>来确定，<strong>栈帧中一般不会保存这部分信息</strong>。</p>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p>
<ul>
<li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</li>
</ul>
<p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p>
<p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p>
<p><img src="/2021/02/13/5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20200706154554604.png" alt="image-20200706154554604"></p>
<p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p>
<h2 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h2><p>栈帧中还允许携带<strong>与Java虚拟机实现相关的一些附加信息</strong>。例如：对程序调试提供支持的信息。</p>
<h2 id="虚拟机栈的相关面试题"><a href="#虚拟机栈的相关面试题" class="headerlink" title="虚拟机栈的相关面试题"></a>虚拟机栈的相关面试题</h2><ul>
<li>举例栈溢出的情况？（StackOverflowError）<ul>
<li>通过 -Xss设置栈的大小</li>
</ul>
</li>
<li>调整栈大小，就能保证不出现溢出么？<ul>
<li>不能保证不溢出</li>
</ul>
</li>
<li>分配的栈内存越大越好么？<ul>
<li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li>
</ul>
</li>
<li>垃圾回收是否涉及到虚拟机栈？<ul>
<li>不会</li>
</ul>
</li>
<li>方法中定义的局部变量是否线程安全？<ul>
<li>具体问题具体分析</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题</span></span><br><span class="line"><span class="comment"> * 方法中定义局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> * 何为线程安全？</span></span><br><span class="line"><span class="comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的</span></span><br><span class="line"><span class="comment"> *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s1的声明方式是线程安全的，没被其他线程使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程内部创建的，属于局部变量</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// stringBuilder 是线程不安全的，操作的是共享数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">(StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时并发的执行，会出现线程不安全的问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">            stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        method02(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StringBuilder是线程安全的，因为他在方法内部就消亡了</span></span><br><span class="line">    <span class="comment">// 但是String是线程不安全的，因为将他返回了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一句话就是：<strong>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</strong></p>
<p>运行时数据区，是否存在Error和GC？</p>
<table>
<thead>
<tr>
<th>运行时数据区</th>
<th>是否存在Error</th>
<th>是否存在GC</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>方法区</td>
<td>是（OOM）</td>
<td>是</td>
</tr>
<tr>
<td>堆</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>8.堆</title>
    <url>/2021/02/13/8-%E5%A0%86/</url>
    <content><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的核心概念"><a href="#堆的核心概念" class="headerlink" title="堆的核心概念"></a>堆的核心概念</h2><p><strong>栈管运行，堆管存储！</strong></p>
<p><strong>一个Java程序运行起来就是一个进程，一个进程对应一个JVM实例，一个JVM实例当中就有一个运行时数据区，所以堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM</strong>，但是进程包含多个线程，他们是共享同一堆空间的。</p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200706195127740.png" alt="image-20200706195127740"></p>
<p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>
<p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的<strong>最大一块内存空间</strong>。</p>
<ul>
<li>堆内存的大小是可以调节的。</li>
</ul>
<p>《Java虚拟机规范》规定，堆<strong>可以处于物理上不连续</strong>的内存空间中，但在<strong>逻辑上</strong>它应该被视为<strong>连续</strong>的。</p>
<p>所有的线程共享Java堆，在这里<strong>还可以划分线程私有的缓冲区</strong>（Thread Local Allocation Buffer，<strong>TLAB</strong>）。</p>
<blockquote>
<p>-Xms10m：最小堆内存</p>
<p>-Xmx10m：最大堆内存</p>
</blockquote>
<a id="more"></a>

<p>下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk bin提供的插件</p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200706200739392.png" alt="image-20200706200739392"></p>
<p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p>
<p>我要说的是：<strong>“几乎”所有的对象实例都在堆分配内存。</strong>—从实际使用角度看的。</p>
<ul>
<li>因为<strong>还有一些对象是在栈上分配的</strong></li>
</ul>
<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
<p><strong>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</strong></p>
<ul>
<li>也就是触发了GC的时候，才会进行回收</li>
<li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li>
</ul>
<p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200706201904057.png" alt="image-20200706201904057"></p>
<h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p>
<ul>
<li>Young Generation Space 新生区  Young/New   又被划分为Eden区和Survivor区</li>
<li>Tenure generation space 养老区 Old/Tenure</li>
<li>Permanent Space永久区   Perm</li>
</ul>
<p>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间(方法区的具体实现)</p>
<ul>
<li>Young Generation Space新生区  Young/New  又被划分为Eden区和Survivor区</li>
<li>Tenure generation space 养老区  Old/Tenure</li>
<li>Meta Space  元空间   Meta</li>
</ul>
<p>约定：新生区 -&gt; 新生代 -&gt; 年轻代   、  养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200706203419496.png" alt="image-20200706203419496"></p>
<p>堆空间内部结构，<strong>JDK1.8之前从永久代  替换成 元空间</strong></p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200706203835403.png" alt="image-20200706203835403"></p>
<h2 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p>
<ul>
<li>“-Xms”用于表示堆区的<strong>起始内存</strong>，等价于-xx:InitialHeapSize</li>
<li>“-Xmx”则用于表示堆区的<strong>最大内存</strong>，等价于-XX:MaxHeapSize</li>
</ul>
<p>一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。</p>
<p><strong>开发中建议将-Xms和-Xmx两个参数配置相同的值</strong>，其目的是<strong>为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p>
<p>默认情况下</p>
<ul>
<li><p>初始内存大小：物理电脑内存大小/64</p>
</li>
<li><p>最大内存大小：物理电脑内存大小/4</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *  -X：是jvm运行参数</span></span><br><span class="line"><span class="comment"> *  ms：memory start</span></span><br><span class="line"><span class="comment"> * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机试图使用的最大堆内存</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        System.out.println(<span class="string">"-Xms:"</span> + initialMemory + <span class="string">"M"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-Xmx:"</span> + maxMemory + <span class="string">"M"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms:245M</span><br><span class="line">-Xmx:3614M</span><br></pre></td></tr></table></figure>

<p>如何查看堆内存的内存分配情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jps  -&gt;  jstat -gc 进程id</span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/13/8-%E5%A0%86/image-20200706205756045.png" alt="image-20200706205756045"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/13/8-%E5%A0%86/image-20200706205821919.png" alt="image-20200706205821919"></p>
<p>新生代的from区和to区只算一个的内存加上去</p>
<h3 id="OutOfMemory举例"><a href="#OutOfMemory举例" class="headerlink" title="OutOfMemory举例"></a>OutOfMemory举例</h3><p><img src="/2021/02/13/8-%E5%A0%86/image-20200706205947535.png" alt="image-20200706205947535"></p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200706210000461.png" alt="image-20200706210000461"></p>
<p>我们简单的写一个OOM例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OOM测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="number">999999999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后设置启动参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms10m -Xmx:10m</span><br></pre></td></tr></table></figure>

<p>运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM</p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200706211652779.png" alt="image-20200706211652779"></p>
<h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul>
<li>生命周期短的，及时回收即可</li>
</ul>
</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>
</ul>
<p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p>
<p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200707075847954.png" alt="image-20200707075847954"></p>
<p>下面这参数开发中一般不会调：</p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200707080154039.png" alt="image-20200707080154039"></p>
<ul>
<li>Eden：From：to -&gt;  8:1:1</li>
<li>新生代：老年代  - &gt;  1 : 2</li>
</ul>
<p>配置新生代与老年代在堆结构的占比。</p>
<ul>
<li><p>默认<strong>-XX:NewRatio</strong>=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p>
</li>
<li><p>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</p>
</li>
</ul>
<blockquote>
<p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p>
</blockquote>
<p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如<strong>-xx:SurvivorRatio</strong>=8</p>
<p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p>
<blockquote>
<p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p>
<p>可以使用选项”-Xmn”设置新生代最大内存大小</p>
<p>这个参数一般使用默认值就可以了。</p>
</blockquote>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200707084208115.png" alt="image-20200707084208115"></p>
<h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ul>
<li>new的对象先放伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>
<li>然后将伊甸园中的剩余对象移动到幸存者0区。</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>
<li>啥时候能去养老区呢？可以设置次数。默认是15次。</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li>
<li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li>
</ul>
<p>可以设置参数：-Xx:MaxTenuringThreshold= N进行设置</p>
<h3 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h3><p>我们创建的对象，一般都是存放在Eden区的，当我们<strong>Eden区满了后，就会触发GC操作</strong>，一般被称为 YGC / Minor GC操作</p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200707084714886.png" alt="image-20200707084714886"></p>
<p>当我们进行一次垃圾收集后，<strong>红色的将会被回收，而绿色的还会被占用着</strong>，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p>
<p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200707085232646.png" alt="image-20200707085232646"></p>
<p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的<strong>年龄达到15的时候，将会触发一次 Promotion晋升的操作</strong>，也就是将年轻代中的对象  晋升到 老年代中</p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200707085737207.png" alt="image-20200707085737207"></p>
<h3 id="思考：幸存区区满了后？"><a href="#思考：幸存区区满了后？" class="headerlink" title="思考：幸存区区满了后？"></a>思考：幸存区区满了后？</h3><p>特别注意，<strong>在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</strong></p>
<p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代，就相当于年龄没到15就去了老年代。</p>
<blockquote>
<p>举例：以当兵为例，正常人的晋升可能是 ：  新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长</p>
<p>但是也有可能有些人因为做了非常大的贡献，直接从  新兵 -&gt; 排长</p>
</blockquote>
<h3 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h3><p><img src="/2021/02/13/8-%E5%A0%86/image-20200707091058346.png" alt="image-20200707091058346"></p>
<ul>
<li><p><strong>Eden区放不下后，进行YGC，此时Eden区就清空了，但如果是超大对象，整个空的Eden区还是放不下，就直接看Old区放不放得下，放得下就直接放到Old区，放不下对Old区进行FGC(Major GC)，还放不下就报OOM错误</strong></p>
</li>
<li><p><strong>而Servivor区的YGC是随着Eden区的YGC发生而发生的，然后再对S0/S1区域进行存放，如果放不下或者年龄达到15，就直接晋升老年代。</strong></p>
</li>
</ul>
<h3 id="代码演示对象分配过程"><a href="#代码演示对象分配过程" class="headerlink" title="代码演示对象分配过程"></a>代码演示对象分配过程</h3><p>我们不断的创建大对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码演示对象创建过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapInstanceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">200</span>)];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayList&lt;HeapInstanceTest&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> HeapInstanceTest());</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后设置JVM参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xms600m -Xmx600m</span><br></pre></td></tr></table></figure>

<p>然后cmd输入下面命令，打开VisualVM图形化界面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jvisualvm</span><br></pre></td></tr></table></figure>

<p>然后通过执行上面代码，通过VisualGC进行动态化查看</p>
<p><img src="/2021/02/13/8-%E5%A0%86/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.gif" alt="垃圾回收"></p>
<p>最终，在老年代和新生代都满了，就出现OOM</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.atguigu.java.chapter08.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:13)</span><br><span class="line">	at com.atguigu.java.chapter08.HeapInstanceTest.main(HeapInstanceTest.java:17)</span><br></pre></td></tr></table></figure>

<h3 id="常用的调优工具"><a href="#常用的调优工具" class="headerlink" title="常用的调优工具"></a>常用的调优工具</h3><ul>
<li>JDK命令行</li>
<li>Eclipse：Memory Analyzer Tool</li>
<li>Jconsole</li>
<li>Visual VM（实时监控  推荐~）</li>
<li>Jprofiler（推荐~）</li>
<li>Java Flight Recorder（实时监控）</li>
<li>GCViewer</li>
<li>GCEasy</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li>
<li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li>
<li>新生代采用复制算法的目的：是为了减少内碎片</li>
</ul>
<h2 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a>Minor GC，MajorGC、Full GC</h2><ul>
<li>Minor GC：新生代的GC，部分收集</li>
<li>Major GC：老年代的GC，部分收集</li>
<li>Full GC：<strong>整堆收集</strong>，收集整个Java堆和方法区的垃圾收集</li>
</ul>
<blockquote>
<p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW(导致用户线程暂停，降低线程效率)的问题</p>
<p>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</p>
</blockquote>
<p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>
<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集</li>
<li>老年代收集（MajorGC/OldGC）：只是老年代的圾收集。<ul>
<li>目前，只有CMSGC会有单独收集老年代的行为。</li>
<li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>
</ul>
</li>
<li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
<p>整堆收集（FullGC）：<strong>收集整个java堆和方法区的垃圾收集。</strong></p>
<h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，<strong>Survivor满不会引发GC</strong>。（每次Minor GC会清理年轻代的内存。）</p>
<p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p>
<p><strong>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</strong></p>
<blockquote>
<p>STW：stop the word</p>
</blockquote>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200707095606813.png" alt="image-20200707095606813"></p>
<h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p>
<p>出现了MajorGC，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p>
<ul>
<li>也就是在<strong>老年代空间不足时，会先尝试触发MinorGC。如果之后空间还不足，则触发Major GC</strong></li>
</ul>
<p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>触发Full GC执行的情况有如下五种：</p>
<ul>
<li>调用System.gc（）时，系统建议执行Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ul>
<p>说明：<strong>Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</strong></p>
<h3 id="GC-举例"><a href="#GC-举例" class="headerlink" title="GC 举例"></a>GC 举例</h3><p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GC测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String a = <span class="string">"mogu blog"</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.getStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置JVM启动参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>打印出的日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2038K-&gt;500K(2560K)] 2038K-&gt;797K(9728K), 0.3532002 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.36 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2108K-&gt;480K(2560K)] 2405K-&gt;1565K(9728K), 0.0014069 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2288K-&gt;0K(2560K)] [ParOldGen: 6845K-&gt;5281K(7168K)] 9133K-&gt;5281K(9728K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0058675 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 5281K-&gt;5281K(9728K), 0.0002857 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 5281K-&gt;5263K(7168K)] 5281K-&gt;5263K(9728K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0058564 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 60K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0f138,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 7168K, used 5263K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 73% used [0x00000000ff600000,0x00000000ffb23cf0,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3514K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 388K, capacity 390K, committed 512K, reserved 1048576K</span><br><span class="line">  </span><br><span class="line">  Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOfRange(Arrays.java:3664)</span><br><span class="line">	at java.lang.String.&lt;init&gt;(String.java:207)</span><br><span class="line">	at java.lang.StringBuilder.toString(StringBuilder.java:407)</span><br><span class="line">	at com.atguigu.java.chapter08.GCTest.main(GCTest.java:20)</span><br></pre></td></tr></table></figure>

<p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p>
<h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p> 为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<blockquote>
<p>新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。<br>老年代：存放新生代中经历多次GC仍然存活的对象。</p>
</blockquote>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200707101511025.png" alt="image-20200707101511025"></p>
<p>其实不分代完全可以，<strong>分代的唯一理由就是优化GC性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<p><strong>即高频地回收Eden区，而低频回收Old区，优化GC性能</strong></p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200707101543871.png" alt="image-20200707101543871"></p>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p>
<p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p>
<p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到Eden<ul>
<li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li>
</ul>
</li>
<li><strong>大对象</strong>直接分配到老年代<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li><strong>长期存活</strong>的对象分配到老年代</li>
<li>动态对象<strong>年龄判断</strong><ul>
<li>如果survivor区中<strong>相同年龄的所有对象大小的总和大于Survivor空间的一半</strong>，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li>
</ul>
</li>
</ul>
<p>空间分配担保： -Xx:HandlePromotionFailure</p>
<ul>
<li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li>
</ul>
<h2 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h2><h3 id="问题：堆空间都是共享的么？"><a href="#问题：堆空间都是共享的么？" class="headerlink" title="问题：堆空间都是共享的么？"></a>问题：堆空间都是共享的么？</h3><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，<strong>为每个线程所独占</strong></p>
<h3 id="为什么有TLAB？"><a href="#为什么有TLAB？" class="headerlink" title="为什么有TLAB？"></a>为什么有TLAB？</h3><p>TLAB：<strong>Thread Local</strong> Allocation Buffer，也就是<strong>为每个线程单独分配了一个缓冲区</strong></p>
<p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p>
<p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>
<p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
<h3 id="什么是TLAB"><a href="#什么是TLAB" class="headerlink" title="什么是TLAB"></a>什么是TLAB</h3><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个<strong>私有缓存区域</strong>，<strong>它包含在Eden空间内</strong>。</p>
<p>多线程同时分配内存时，使用TLAB可以<strong>避免一系列的非线程安全问题</strong>，同时还能够<strong>提升内存分配的吞吐量</strong>，因此我们可以将这种内存分配方式称之为快速分配策略。</p>
<p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200707103547712.png" alt="image-20200707103547712"></p>
<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。</p>
<p>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p>
<p>默认情况下，TLAB空间的内存非常小，<strong>仅占有整个Eden空间的1%</strong>，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p>
<p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配内存。</p>
<h3 id="TLAB分配过程"><a href="#TLAB分配过程" class="headerlink" title="TLAB分配过程"></a>TLAB分配过程</h3><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200707104253530.png" alt="image-20200707104253530"></p>
<h2 id="小结：堆空间的参数设置"><a href="#小结：堆空间的参数设置" class="headerlink" title="小结：堆空间的参数设置"></a>小结：堆空间的参数设置</h2><ul>
<li><p>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</p>
</li>
<li><p>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p>
</li>
<li><p>-Xms：初始堆空间内存（默认为物理内存的1/64）</p>
</li>
<li><p>-Xmx：最大堆空间内存（默认为物理内存的1/4）</p>
</li>
<li><p>-Xmn：设置新生代的大小。（初始值及最大值）</p>
</li>
<li><p>-XX:NewRatio：配置新生代与老年代在堆结构的占比</p>
</li>
<li><p>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</p>
</li>
<li><p>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</p>
</li>
<li><p>-XX：+PrintGCDetails：输出详细的GC处理日志</p>
<ul>
<li>打印gc简要信息：①-Xx：+PrintGC  ② - verbose:gc</li>
</ul>
</li>
<li><p>-XX:HandlePromotionFalilure：是否设置空间分配担保</p>
</li>
</ul>
<p>在发生Minor GC之前，虚拟机会<strong>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong>。</p>
<ul>
<li>如果大于，则此次Minor GC是安全的</li>
<li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul>
<li>如果HandlePromotionFailure=true，那么会继续<strong>检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</strong></li>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li>
<li>如果小于，则改为进行一次FullGC。</li>
<li>如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。</li>
</ul>
</li>
</ul>
<p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</strong></p>
<h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>
<p>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。</strong>这样就无需在堆上分配内存，<strong>也无须进行垃圾回收了(因为这些对象会随着栈帧的弹出而直接消亡)</strong>。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于openJDk深度定制的<strong>TaoBaovm</strong>，其中创新的GCIH（GC invisible heap）技术实现off-heap，<strong>将生命周期较长的Java对象从heap中移至heap外</strong>，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
<p><strong>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</strong></p>
<p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
<h4 id="逃逸分析举例"><a href="#逃逸分析举例" class="headerlink" title="逃逸分析举例"></a>逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">my_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要StringBuffer sb不发生逃逸，可以这样写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的逃逸分析代码举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span> ? <span class="keyword">new</span> EscapeAnalysis():obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">        <span class="comment">// getInstance().XXX  发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p>
<p>如果使用的是较早的版本，开发人员则可以通过：</p>
<ul>
<li>选项“-xx：+DoEscapeAnalysis”显式开启逃逸分析</li>
<li>通过选项“-xx：+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><strong>开发中能使用局部变量的，就不要使用在方法外定义。</strong></p>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ul>
<li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>
<li><strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>
</ul>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>JIT编译器在编译期间根据逃逸分析的结果，发现<strong>如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。</strong>分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>
<p>常见的栈上分配的场景</p>
<blockquote>
<p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p>
</blockquote>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配</span></span><br><span class="line"><span class="comment"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"花费的时间为："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 未发生逃逸</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置JVM参数，表示未开启逃逸分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>运行结果，同时还触发了GC操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">花费的时间为：664 ms</span><br></pre></td></tr></table></figure>

<p>然后查看内存的情况，发现有大量的User存储在堆中</p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200707203038615.png" alt="image-20200707203038615"></p>
<p>我们在开启逃逸分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">花费的时间为：5 ms</span><br></pre></td></tr></table></figure>

<p>在看内存情况，我们发现只有很少的User对象，说明User未发生逃逸，因为它存储在栈中，随着栈的销毁而消失</p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200707203441718.png" alt="image-20200707203441718"></p>
<h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
<p>在动态编译同步块的时候，JIT编译器可以<strong>借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。如果没有，那么JIT编译器在编译这个同步块的时候就会<strong>取消对这部分代码的同步锁</strong>。这样就能大大提高并发性和性能。这个取消同步锁的过程就叫同步省略，也叫锁消除。</p>
<p>例如下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hellis) &#123;</span><br><span class="line">        System.out.println(hellis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">	System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将其转换成字节码，<strong>字节码还是看得到synchronized的身影，因为同步锁是在运行的时候才消除的</strong></p>
<p><img src="/2021/02/13/8-%E5%A0%86/image-20200707205634266.png" alt="image-20200707205634266"></p>
<h3 id="分离对象和标量替换"><a href="#分离对象和标量替换" class="headerlink" title="分离对象和标量替换"></a>分离对象和标量替换</h3><p><strong>标量</strong>（scalar）是<strong>指一个无法再分解成更小的数据的数据</strong>。<strong>Java中的原始数据类型就是标量</strong>。</p>
<p>相对的，那些<strong>还可以分解的数据叫做聚合量</strong>（Aggregate），<strong>Java中的对象就是聚合量</strong>，因为他可以分解成其他聚合量和标量。</p>
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会<strong>把这个对象拆解成若干个其中包含的若干个成员变量来代替。</strong>这个过程就是标量替换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">"point.x"</span> + point.x + <span class="string">";point.y"</span> + point.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，经过标量替换后，就会变成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"point.x = "</span> + x + <span class="string">"; point.y="</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Point这个聚合量经过逃逸分析后，<strong>发现他并没有逃逸，就被替换成两个标量了</strong>。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p>
<h3 id="代码优化之标量替换"><a href="#代码优化之标量替换" class="headerlink" title="代码优化之标量替换"></a>代码优化之标量替换</h3><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br></pre></td></tr></table></figure>

<p>这里设置参数如下：</p>
<ul>
<li>参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li>
<li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li>
<li>参数-Xmx10m：指定了堆空间最大为10MB</li>
<li>参数-XX:+PrintGC：将打印Gc日志</li>
<li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li>
</ul>
<h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p>
<p>其根本原因就是<strong>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong><br>        一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是它<strong>也是即时编译器优化技术中一个十分重要的手段</strong>。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p>
<p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而<strong>永久代已经被元数据区取代</strong>。但是，<strong>intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配</strong>，所以这一点同样符合前面一点的结论：<strong>对象实例都是分配在堆上</strong>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>年轻代</strong>是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
<p><strong>老年代</strong>放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为<strong>MinorGC</strong>。</p>
<p>当GC发生在老年代时则被称为<strong>MajorGC或者FullGC</strong>。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>7.本地方法栈</title>
    <url>/2021/02/13/7-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</url>
    <content><![CDATA[<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>Java虚拟机栈于管理Java方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong>。</p>
<p>本地方法栈，也是线程私有的。</p>
<p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li>
</ul>
<p>本地方法是使用C语言实现的。</p>
<p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p>
<p><img src="/2021/02/13/7-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/image-20200706174708418.png" alt="image-20200706174708418"></p>
<p><strong>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</strong></p>
<ul>
<li>本地方法可以通过本地方法接口来<strong>访问虚拟机内部的运行时数据区。</strong></li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存。</li>
</ul>
<p><strong>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</strong></p>
<p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>6.本地方法接口</title>
    <url>/2021/02/13/6-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h2><p>简单地讲，<strong>一个Native Method就是一个Java调用非Java代码的接囗。</strong>一个Native Method是这样一个Java方法：<strong>该方法的实现由非Java语言实现，比如C。</strong>这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。</p>
<p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p>
<p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p>
<p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p>
<p><img src="/2021/02/13/6-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/image-20200706164139252.png" alt="image-20200706164139252"></p>
<p>代码举例说明Native方法是如何编写的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IhaveNatives</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Natives</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外，因为native方法其实有方法体，只不过是非java的实现，而abstract没有方法体</p>
</blockquote>
<a id="more"></a>

<h2 id="为什么使用Native-Method？"><a href="#为什么使用Native-Method？" class="headerlink" title="为什么使用Native Method？"></a>为什么使用Native Method？</h2><p>Java使用起来非常方便，然而<strong>有些层次的任务用Java实现起来不容易</strong>，或者我们对程序的效率很在意时，问题就来了。</p>
<h3 id="与Java环境外的交互"><a href="#与Java环境外的交互" class="headerlink" title="与Java环境外的交互"></a>与Java环境外的交互</h3><p><strong>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。</strong>你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p>
<h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。<strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。</strong>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p>
<h3 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s Java"></a>Sun’s Java</h3><p><strong>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。</strong>jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setpriorityo（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority（）ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。</p>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>目前<strong>该方法使用的越来越少了，除非是与硬件有关的应用</strong>，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>9.方法区</title>
    <url>/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次所讲述的是运行时数据区的最后一个部分</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708093918121.png" alt="image-20200708093918121"></p>
<p>从线程共享与否的角度来看</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708094507624.png" alt="image-20200708094507624"></p>
<p>方法区JDK8后叫元空间</p>
<p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理</p>
<h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p>下面就涉及了对象的访问定位</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708094747667.png" alt="image-20200708094747667"></p>
<ul>
<li>Person：存放在元空间，也可以说方法区</li>
<li>person：存放在Java栈的局部变量表中</li>
<li>new Person()：存放在Java堆中</li>
</ul>
<h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p>
<p>所以，<strong>方法区看作是一块独立于Java堆的内存空间</strong>。</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708095853544.png" alt="image-20200708095853544"></p>
<p>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p>
<ul>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：<strong>PermGen space</strong> 或者java.lang.OutOfMemoryError:<strong>Metaspace</strong><ul>
<li><strong>加载大量的第三方的jar包</strong></li>
<li><strong>Tomcat部署的工程过多（30~50个）</strong></li>
<li><strong>大量动态的生成反射类</strong></li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ul>
<h3 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h3><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p>
<ul>
<li>JDK 1.8后，元空间存放在堆外内存中</li>
</ul>
<p>本质上，<strong>方法区和永久代并不等价。仅是对hotspot而言的。</strong>《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。            </p>
<blockquote>
<p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限）</p>
</blockquote>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708102919149.png" alt="image-20200708102919149"></p>
<p>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708103055914.png" alt="image-20200708103055914"></p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong></p>
<p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p>
<p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p>
<h2 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。 </p>
<h3 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h3><ul>
<li>通过<strong>-xx:Permsize</strong>来设置永久代<strong>初始分配空间</strong>。默认值是<strong>20.75M</strong></li>
<li><strong>-XX:MaxPermsize</strong>来设定永久代<strong>最大可分配空间</strong>。32位机器默认是64M，64位机器模式是<strong>82M</strong></li>
<li><strong>当JVM加载的类信息容量超过了这个值，会报异常</strong>OutofMemoryError:PermGen space。</li>
</ul>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708111756800.png" alt="image-20200708111756800"></p>
<h3 id="JDK8以后"><a href="#JDK8以后" class="headerlink" title="JDK8以后"></a>JDK8以后</h3><p>元数据区大小可以使用参数 <strong>-XX:MetaspaceSize</strong> 和 <strong>-XX:MaxMetaspaceSize</strong>指定</p>
<p>默认值依赖于平台。windows下，-XX:MetaspaceSize是<strong>21M</strong>，-XX:MaxMetaspaceSize的值是<strong>-1，即没有限制</strong>。</p>
<p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p>
<p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，<strong>一旦触及这个水位线，Full GC将会被触发并卸载没用的类</strong>（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果<strong>释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值</strong>。如果<strong>释放空间过多，则适当降低该值。</strong></p>
<p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。<strong>为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</strong></p>
<h3 id="如何解决这些OOM"><a href="#如何解决这些OOM" class="headerlink" title="如何解决这些OOM"></a>如何解决这些OOM</h3><ul>
<li><p>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要<strong>先分清楚到底是出现了内存泄漏</strong>（Memory Leak）<strong>还是内存溢出</strong>（Memory Overflow）</p>
<ul>
<li>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li>
</ul>
</li>
<li><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p>
</li>
<li><p>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
</li>
</ul>
<h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708161728320.png" alt="image-20200708161728320"></p>
<p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存等</strong>。</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708161856504.png" alt="image-20200708161856504"></p>
<h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p>
<ul>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<h3 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h3><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
<p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p>
<h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型（或void）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li>
<li>异常表（abstract和native方法除外）</li>
</ul>
<blockquote>
<p>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p>
</blockquote>
<h3 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h3><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p>
<p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * non-final的类变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码所示，即使我们把order设置为null，也不会出现空指针异常</p>
<h3 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h3><p>全局常量就是使用 <strong>static final 进行修饰</strong></p>
<p>被声明为final的类变量的处理方法则不同，每个全局常量<strong>在编译的时候就会被分配了</strong>。 </p>
<h3 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h3><p>运行时常量池，就是运行时常量池</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708171151384.png" alt="image-20200708171151384"></p>
<ul>
<li><strong>方法区</strong>，内部包含了<strong>运行时常量池</strong></li>
<li><strong>字节码文件</strong>，内部包含了<strong>常量池</strong></li>
<li>要弄清楚方法区，需要理解清楚Class File，因为加载类的信息都在方法区。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚Class File中的常量池。</li>
</ul>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708172357052.png" alt="image-20200708172357052"></p>
<p>一个有效的<strong>字节码文件中</strong>除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是<strong>常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</strong></p>
<h4 id="为什么需要常量池"><a href="#为什么需要常量池" class="headerlink" title="为什么需要常量池"></a>为什么需要常量池</h4><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。</p>
<p>比如：如下的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p>
<h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么"></a>常量池中有什么</h4><ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<p>例如下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将会被翻译成如下字节码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">new <span class="comment">#2  </span></span><br><span class="line">dup</span><br><span class="line">invokespecial</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</strong></p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
<p>常量池表（Constant Pool Table）是Class文件的一部分，<strong>用于存放编译期生成的各种字面量与符号引用</strong>，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中。</strong></p>
<p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p>
<p><strong>就是说放在常量池中的各种字面量和符号引用，实际中在方法区中被使用的就是运行时常量池。</strong></p>
<p><strong>eg.味精没用的时候就只是味精，用了才是真实使用的</strong></p>
<p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p>
<p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址。</strong></p>
<p>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性</strong>。</p>
<p>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</p>
<p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。</p>
<h2 id="方法区使用举例"><a href="#方法区使用举例" class="headerlink" title="方法区使用举例"></a>方法区使用举例</h2><p>如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x / y;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码执行过程展示</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708204750374.png" alt="image-20200708204750374"></p>
<p>首先现将操作数500放入到操作数栈中</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708204953552.png" alt="image-20200708204953552"></p>
<p>然后存储到局部变量表中</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708205029376.png" alt="image-20200708205029376"></p>
<p>然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708205221737.png" alt="image-20200708205221737"></p>
<p>将500 和 100 进行一个除法运算，在把结果入栈</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708205413721.png" alt="image-20200708205413721"></p>
<p>在最后就是输出流，需要调用运行时常量池的常量</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708205708057.png" alt="image-20200708205708057"></p>
<p>最后调用invokevirtual（虚方法调用），然后返回</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708205909176.png" alt="image-20200708205909176"></p>
<p>返回时</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708210540696.png" alt="image-20200708210540696"></p>
<p>程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。</p>
<h2 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h2><p>首先明确：<strong>只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。</strong>原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p>
<p>Hotspot中方法区的变化：</p>
<table>
<thead>
<tr>
<th>JDK1.6及以前</th>
<th>有永久代，静态变量、字符串常量池还存储在永久代上</th>
</tr>
</thead>
<tbody><tr>
<td>JDK1.7</td>
<td>有永久代，但已经逐步 “去永久代”，<strong>字符串常量池，静态变量移除，保存在堆中</strong></td>
</tr>
<tr>
<td>JDK1.8</td>
<td><strong>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间</strong>，<strong>但字符串常量池、静态变量仍然在堆中。</strong></td>
</tr>
</tbody></table>
<p>JDK6的时候</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708211541300.png" alt="image-20200708211541300"></p>
<p>JDK7的时候</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708211609911.png" alt="image-20200708211609911"></p>
<p>JDK8的时候，元空间大小只受物理内存影响</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708211637952.png" alt="image-20200708211637952"></p>
<h3 id="为什么永久代要被元空间替代？"><a href="#为什么永久代要被元空间替代？" class="headerlink" title="为什么永久代要被元空间替代？"></a>为什么永久代要被元空间替代？</h3><p><strong>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</strong></p>
<p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了<strong>一个与堆不相连的本地内存区域，这个区域叫做元空间</strong>（Metaspace）。</p>
<p>由于类的元数据<strong>分配在本地内存中</strong>，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p>
<ul>
<li><strong>为永久代设置空间大小是很难确定的。</strong></li>
</ul>
<p>在某些场景下，如果<strong>动态加载类过多</strong>，容易产生Perm区的<strong>OOM</strong>。比如某个实际Web工<br>程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。<strong>分配少了就容易GC</strong></p>
<p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p>
<p>而元空间和永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存。</strong><br>因此，默认情况下，元空间的大小仅受本地内存限制。</p>
<ul>
<li><strong>对永久代进行调优是很困难的。</strong><ul>
<li><strong>主要是为了降低Full GC</strong></li>
</ul>
</li>
</ul>
<p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。<br>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p>
<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p>
<h3 id="StringTable为什么要调整位置"><a href="#StringTable为什么要调整位置" class="headerlink" title="StringTable为什么要调整位置"></a>StringTable为什么要调整位置</h3><p>jdk7中将StringTable放到了堆空间中。因为<strong>永久代的回收效率很低，在Full GC的时候才会触发</strong>。而Full GC是老年代的空间不足、永久代不足时才会触发。</p>
<p>这就<strong>导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。</strong>放到堆里，能及时回收内存。</p>
<h3 id="静态变量存放在那里？"><a href="#静态变量存放在那里？" class="headerlink" title="静态变量存放在那里？"></a>静态变量存放在那里？</h3><p><strong>静态引用对应的对象实体始终都存在堆空间</strong></p>
<p>可以使用 jhsdb.ext，需要在jdk9的时候才引入的</p>
<p>staticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/JVM/LearningNotes/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708215025527.png" alt="image-20200708215025527"></p>
<p>测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。</p>
<p>接着，找到了一个引用该staticobj对象的地方，是在一个java.1ang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p>
<p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708215218078.png" alt="image-20200708215218078"></p>
<p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的<strong>HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中</strong>，从我们的实验中也明确验证了这一点</p>
<h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过<strong>可以不要求虚拟机在方法区中实现垃圾收集</strong>。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</p>
<p>一般来说<strong>这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻</strong>。但是这部分区域的回收<strong>有时又确实是必要</strong>的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
<p><strong>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型(类)。</strong></p>
<p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>HotSpot虚拟机<strong>对常量池的回收</strong>策略是很明确的，<strong>只要常量池中的常量没有被任何地方引用，就可以被回收。</strong></p>
<p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p>
<p><strong>回收常量好办，回收类就比较苛刻了</strong></p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li><strong>该类所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li><strong>加载该类的类加载器已经被回收</strong>，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li>
<li><strong>该类对应的java.lang.Class对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li>
</ul>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/02/13/9-%E6%96%B9%E6%B3%95%E5%8C%BA/image-20200708220303243.png" alt="image-20200708220303243"></p>
<h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><p>百度：<br>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p>
<p>蚂蚁金服：<br>Java8的内存分代改进<br>JVM内存分哪几个区，每个区的作用是什么？<br>一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？<br>二面：Eden和survior的比例分配</p>
<p>小米：<br>jvm内存分区，为什么要有新生代和老年代</p>
<p>字节跳动：<br>二面：Java的内存分区<br>二面：讲讲jvm运行时数据区<br>什么时候对象会进入老年代？</p>
<p>京东：<br>JVM的内存结构，Eden和Survivor比例。<br>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</p>
<p>天猫：<br>一面：Jvm内存模型以及分区，需要详细到每个区放什么。<br>一面：JVM的内存模型，Java8做了什么改动</p>
<p>拼多多：<br>JVM内存分哪几个区，每个区的作用是什么？</p>
<p>美团：<br>java内存分配<br>jvm的永久代中会发生垃圾回收吗？<br>一面：jvm内存分区，为什么要有新生代和老年代？</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
