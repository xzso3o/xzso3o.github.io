<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>反射</title>
    <url>/2021/01/20/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射非常重要，它是<strong>动态</strong>语言的关键。</p>
<p>动态语言就是<strong>不写死</strong>，而是根据程序的具体执行情况做出不同的变化。</p>
<p>反射概念很抽象</p>
<p>日常生活中的反射：照镜子可以反射物体的形态</p>
<p>都是通过一个虚像可以映射到一个事物，可以直接获取实物的某些特征。</p>
<p>程序中的反射是通过某些信息（对象、类名 “java.lang.String”）可以映射到类，在程序运行期间获取类的相关信息。</p>
<p>反射的工作都是在程序运行期间进行的</p>
<p>反射具体操作简单来说就是在程序运行期间，<strong>动态获取类的信息</strong>，从而完成某些操作。</p>
<p>常规情况下，是通过类创建对象，反射就是将其进行反转，通过对象来获取类的信息。</p>
<a id="more"></a>

<h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><p>Class 类是反射的源头，反射就是获取某些类的信息，<strong>抽象出一个对象来表示类的信息</strong>，Class 就是用来创建这些对象的类。</p>
<p>Class 的实例化对象是专门用来描述其他类，Class 是专门用来描述其他类的类。</p>
<p>Class构造器是私有的，不能new出实例化对象。因为实例化对象需要描述一个其他类，这是必须给定的，不可能让你随便new出来，这样子根本不知道他用来描述哪一个类</p>
<p>如何获取 Class 的实例化对象？一共有 3 种方式，都跟目标类有关系。</p>
<p><strong>1、通过类名获取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class aClass = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">        System.out.println(aClass);</span><br><span class="line">        Class&lt;?&gt; aClass1 = Class.forName(<span class="string">"java.io.Serializable"</span>);</span><br><span class="line">        System.out.println(aClass1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、通过类字面量获取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class class2 = String<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>3、通过类的实例化对象获取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class class3 = str.getClass();</span><br></pre></td></tr></table></figure>

<p>无论通过哪种方式获取的 Class 对象都是同一个，为什么呢？</p>
<p>Java 中的类只会加载一次，加载到 JVM 内存中类叫做“<strong>运行时类</strong>”，Class 对象就是运行时类映射出来的一个对象。</p>
<h2 id="获取类的结构"><a href="#获取类的结构" class="headerlink" title="获取类的结构"></a>获取类的结构</h2><p>类的结构包括：成员变量、方法、构造函数、继承的父类、实现的接口等等。</p>
<p>Constructor 是 Java 反射包提供的一个类，它的作用是专门用来描述其他类的构造器的，一个 Constructor 实例化对象映射的就是某个类的某个构造函数。</p>
<blockquote>
<p>构造器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor[] constructors = clazz.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"*****************************************"</span>);</span><br><span class="line">Constructor constructor = clazz.getConstructor();</span><br><span class="line">System.out.println(constructor);</span><br><span class="line">constructor = clazz.getConstructor(Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(constructor);</span><br><span class="line">constructor = clazz.getConstructor(Integer<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(constructor);</span><br><span class="line">System.out.println(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"a"</span>));</span><br><span class="line">System.out.println(constructor.newInstance(<span class="number">1</span>,<span class="string">"a"</span>));</span><br></pre></td></tr></table></figure>

<p>你并不知道其他人要用哪个类，通过反射即可实现动态的让别人使用，下面是反射的一个应用，动态地创建各类对象，用户传什么全类名就创建该类对象</p>
<p><img src="/2021/01/20/%E5%8F%8D%E5%B0%84/1.png" alt="1611142446180"></p>
<p><img src="/2021/01/20/%E5%8F%8D%E5%B0%84/2.png" alt="1611142486849"></p>
<blockquote>
<p>接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class clazz = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class anInterface : interfaces) &#123;</span><br><span class="line">            System.out.println(anInterface);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态代理（Proxy）</strong>机制，给目标类找一个代理去完成工作，代理类不是提前写好的，而是程序运行时动态生成的，动态生成的代理类和目标类肯定是有关联的，代理类必须具备目标类的功能。</p>
<p>Java 中如何描述功能？用接口描述，在动态生成类的时候，需要参照目标类的接口来生成这个动态代理类。</p>
<blockquote>
<p>属性（成员变量）</p>
</blockquote>
<p>getFields() 方法获取的是类中的<strong>公有成员变量</strong>（包括从父类继承过来的公有成员变量），public 修饰的</p>
<p>getDeclaredFields() 方法获取的是类中<strong>全部成员变量</strong>（跟修饰无关，但是不包含父类中的成员变量）</p>
<p>getField(String name) <strong>根据名称</strong>获取公有成员变量（包含父类继承过来的）</p>
<p>getDeclaredField(String name) 根据名称获取成员变量（不包含父类继承过来的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常规方式</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.id = <span class="number">1</span>;</span><br><span class="line">System.out.println(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射方式</span></span><br><span class="line">Field id = clazz.getField(<span class="string">"id"</span>);</span><br><span class="line">id.set(user, <span class="number">2</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>

<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Field id = clazz.getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        <span class="comment">//赋值 取值</span></span><br><span class="line">        Constructor&lt;User&gt; constructor = clazz.getConstructor(<span class="keyword">null</span>);</span><br><span class="line">        User user = constructor.newInstance(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//暴力反射</span></span><br><span class="line">        id.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        id.set(user, <span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Field id = clazz.getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        <span class="comment">//赋值 取值</span></span><br><span class="line">        Constructor&lt;User&gt; constructor = clazz.getConstructor(<span class="keyword">null</span>);</span><br><span class="line">        User user = constructor.newInstance(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//暴力反射</span></span><br><span class="line">        id.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object o = id.get(user);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class clazz = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getMethods 方法获取目标类中的所有公有方法，<strong>包含从父类继承过来的公有方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">    System.out.println(declaredMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getDeclaredMethods 方法获取目标类中的所有方法，<strong>不包含</strong>从父类继承过来的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//        Method[] methods = clazz.getMethods();</span></span><br><span class="line"><span class="comment">//        for (Method method : methods) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(method);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        Method[] declaredMethods = clazz.getDeclaredMethods();</span></span><br><span class="line"><span class="comment">//        for (Method declaredMethod : declaredMethods) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(declaredMethod);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        Method getId = clazz.getDeclaredMethod(<span class="string">"getId"</span>, <span class="keyword">null</span>);<span class="comment">//方法存在重载，所以要传参数</span></span><br><span class="line">        User user = (User) clazz.getConstructor(<span class="keyword">null</span>).newInstance(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        Method setId = clazz.getMethod(<span class="string">"setId"</span>, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        setId.invoke(user, <span class="number">22</span>);<span class="comment">//invoke让方法去执行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//取值</span></span><br><span class="line">        System.out.println(getId.invoke(user, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射机制在实际开发中最主要的三个应用构造器、方法、成员变量。</p>
<p>Spring 框架，IoC 容器，自动创建对象，不需要开发者手动创建对象，程序根据配置文件自动生成程序需要的各种对象。</p>
<p>1、通过构造器创建对象</p>
<p>2、给对象的属性赋值</p>
<h2 id="反射应用之—动态代理"><a href="#反射应用之—动态代理" class="headerlink" title="反射应用之—动态代理"></a>反射应用之—动态代理</h2><p>代理(Proxy)模式是一种常用的 Java 设计模式，代理模式是指处理一个业务逻辑时，通过代理的方式完成。</p>
<p>代理模式中包含被代理方（委托方），和代理方，委托方委托代理帮助他完成某些工作。</p>
<p>在所有的代理模式中，委托方和代理方都有一个共性，即双方都具备完成需求的能力。</p>
<p>Java 程序中如何描述这个关系？将类所具备的能力封装成接口，<strong>Java 委托类和代理类需要实现同一个接口</strong>。</p>
<p>代理类和委托类是通过依赖注入进行关联，在设计程序时需要将委托类定义为代理类的成员变量，</p>
<p>1、所有的操作全部在代理类中完成</p>
<p>2、核心业务操作还是由委托类本身完成</p>
<p>3、代理类完成其他非核心工作</p>
<p>4、委托类需要作为成员变量注入到代理类中</p>
<p>代理模式又可以分为静态代理和动态代理，两者的区别在于静态代理需要提前编写好代理类的代码，在编译期间代理类的 class 文件就已经生成了，代码是写死的。</p>
<p>动态代理是指编译期间代理类的代码不确定，而是在程序运行期间根据代码的指示动态生成的，代码不是写死的，而是灵活变通的。</p>
<p>静态代理和反射没有任何关系，动态代理是需要通过反射机制来实现灵活性的。</p>
<p>静态代理代码如下：</p>
<p>1、创建接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">salePhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建委托类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">salePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"销售iPhone手机"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWei</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">salePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"销售华为手机"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneProxy</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Phone phone;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhoneProxy</span><span class="params">(Phone phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">salePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打广告、宣传等其他代理业务操作"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.phone.salePhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PhoneProxy phoneProxy = <span class="keyword">new</span> PhoneProxy(<span class="keyword">new</span> Apple());</span><br><span class="line">        System.out.println(phoneProxy.salePhone());</span><br><span class="line">        phoneProxy = <span class="keyword">new</span> PhoneProxy(<span class="keyword">new</span> HuaWei());</span><br><span class="line">        System.out.println(phoneProxy.salePhone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个厂商，既可以卖代理卖手机，也可以代理卖汽车，未来还可能代理卖别的东西。</p>
<p><strong>动态代理：</strong></p>
<p>需求：</p>
<p>要求提供这样一种机制，可以为各种委托类实现代理机制。</p>
<p>1、肯定需要包含目前项目中已经存在的委托类（销售手机、销售汽车）</p>
<p>2、同时还要具备非常好的扩展性，这套程序写好之后，如果后期有新的委托类（销售房子）</p>
<p>代码完全不需要修改，还可以完成代理机制。</p>
<p>动态代理机制可以实现上述需求，简单理解就是代理类不是提前写好的，根本就不存在，而是程序运行期间动态生成的，（JDK 动态代理）</p>
<p>开发程序的时候只需要写一个辅助类，辅助动态代理机制动态生成真正的代理类。</p>
<p>就是动态生成代理类的功能，<strong>Java 中如何让一个类具备某种功能？</strong></p>
<p>Java 中用接口定义功能，只需要让目标类实现该接口，目标类就具备了相应的功能。</p>
<p>java.lang.reflect.InvocationHandler</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassLoader loader,</span><br><span class="line">Class&lt;?&gt;[] interfaces,</span><br><span class="line">InvocationHandler h &#x2F;&#x2F;InvocationHandler实例</span><br></pre></td></tr></table></figure>

<p>借助于辅助对象 MyInvocationHandler 动态创建代理类，进而创建代理对象</p>
<p>动态创建一个类，代理类，替代委托类完成某些工作的，这个代理类就需要实现委托类的接口。</p>
<p>动态创建代理类的时候，必须结合委托类的接口来创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录委托对象</span></span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入委托对象</span></span><br><span class="line">    <span class="comment">//返回动态创建的代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                MyInvocationHandler<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),//类加载器</span></span><br><span class="line"><span class="class">                <span class="title">object</span>.<span class="title">getClass</span>().<span class="title">getInterfaces</span>(),//委托对象接口</span></span><br><span class="line"><span class="class">                <span class="title">this</span>)</span>;<span class="comment">//InvocationHandler实例，就可以用当前对象this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//invoke通过反射机制来完成方法调用的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start proxy model"</span>);</span><br><span class="line">        <span class="comment">//委托对象调用核心业务方法</span></span><br><span class="line">        Object result = method.invoke(<span class="keyword">this</span>.object, args);<span class="comment">//通过反射传入委托对象调用核心业务</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        //委托对象</span></span><br><span class="line"><span class="comment">//        Phone phone = new HuaWei();</span></span><br><span class="line"><span class="comment">//        //获取代理</span></span><br><span class="line"><span class="comment">//        MyInvocationHandler handler = new MyInvocationHandler();</span></span><br><span class="line"><span class="comment">//        Phone proxy = (Phone) handler.bind(phone);</span></span><br><span class="line"><span class="comment">//        System.out.println(proxy.salePhone());</span></span><br><span class="line"></span><br><span class="line">        Car car = <span class="keyword">new</span> BMW();</span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line">        Car proxy = (Car) handler.bind(car);</span><br><span class="line">        System.out.println(proxy.saleCar());<span class="comment">//调用代理对象方法时会自动地通过反射机制来获取到proxy里的方法，然后自动进到invoke方法中</span></span><br><span class="line">        System.out.println(proxy.add(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体流程：</p>
<p>1.创建各个实例化对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Phone phone = <span class="keyword">new</span> HuaWei();</span><br><span class="line">MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br></pre></td></tr></table></figure>

<p>2.通过bind()方法创建代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Car proxy = (Car) handler.bind(car);</span><br></pre></td></tr></table></figure>

<p>3.调用代理对象的方法，会自动地通过反射机制来获取到proxy里的方法，然后自动进到invoke方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">proxy.saleCar()</span><br><span class="line">然后跳到invoke方法</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"start proxy model"</span>);</span><br><span class="line">    <span class="comment">//委托对象调用核心业务方法</span></span><br><span class="line">    Object result = method.invoke(<span class="keyword">this</span>.object, args);<span class="comment">//通过反射传入委托对象调用核心业务</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>IO流</title>
    <url>/2021/01/20/IO%E6%B5%81/</url>
    <content><![CDATA[<h1 id="IO-流（输入输出流）"><a href="#IO-流（输入输出流）" class="headerlink" title="IO 流（输入输出流）"></a>IO 流（输入输出流）</h1><p>使用 Java 程序完成输入输出操作，输入 Input，输出 Output</p>
<p>输入是指将文件以数据流的形式读取到 Java 程序中</p>
<p>输出是指通过 Java 程序将数据流写入到文件中</p>
<h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><p>java.lang.File</p>
<p>常用方法</p>
<p>注：目录是指文件夹，文件是指图片、txt、word等等</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public File(String pathname)</td>
<td>根据路径创建文件对象</td>
</tr>
<tr>
<td>public String getName()</td>
<td>获取文件名</td>
</tr>
<tr>
<td>public String getParent()</td>
<td>获取文件所在目录</td>
</tr>
<tr>
<td>public File getParentFile()</td>
<td>获取文件所在目录对应的对象</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>获取文件路径</td>
</tr>
<tr>
<td>public boolean exists()</td>
<td>判断文件是否存在</td>
</tr>
<tr>
<td>public boolean isDirectory()</td>
<td>判断对象是否为目录</td>
</tr>
<tr>
<td>public boolean isFile()</td>
<td>判断对象是否为文件</td>
</tr>
<tr>
<td>public long length()</td>
<td>获取文件大小，以byte为单位</td>
</tr>
<tr>
<td>public boolean createNewFile()</td>
<td>根据当前File创建新的文件</td>
</tr>
<tr>
<td>public boolean delete()</td>
<td>删除文件</td>
</tr>
<tr>
<td>public boolean mkdir()</td>
<td>根据当前对象创建新目录</td>
</tr>
<tr>
<td>public boolean renameTo(File file)</td>
<td>为已存在的对象重命名</td>
</tr>
</tbody></table>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:\\java\\image\\123.png"</span>);</span><br><span class="line">        <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">            System.out.println(file.getName());</span><br><span class="line">            System.out.println(file.length());</span><br><span class="line">            System.out.println(file.getParent());</span><br><span class="line">            System.out.println(file.getPath());</span><br><span class="line">            File parentFile = file.getParentFile();</span><br><span class="line">            System.out.println(parentFile.getName());</span><br><span class="line">            System.out.println(parentFile.isDirectory());</span><br><span class="line">            System.out.println(file.isDirectory());</span><br><span class="line">            System.out.println(parentFile.isFile());</span><br><span class="line">            System.out.println(file.isFile());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file2 = <span class="keyword">new</span> File(<span class="string">"D:\\java\\image\\123.png"</span>);</span><br><span class="line">            System.out.println(file2.createNewFile());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="File-类详解"><a href="#File-类详解" class="headerlink" title="File 类详解"></a>File 类详解</h1><p>流是一种以<strong>先进先出</strong>的方式传输数据的序列，Java 中的流有很多不同的分类。</p>
<ul>
<li>按照方向分，可以分为<strong>输入流</strong>和<strong>输出流</strong>。</li>
<li>按照单位分，可以分为<strong>字节流</strong>和<strong>字符流</strong>，字节流是指每次处理的数据以字节为单位，字符流是指每次处理的数据以字符为单位。</li>
<li>按照功能分，可以分为<strong>节点流</strong>和<strong>处理流</strong>。</li>
</ul>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>以字节为单位处理数据，字节流又可以分为输入字节流（InputStream）和输出字节流（OutputStream）。</p>
<blockquote>
<p>InputStream</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((temp = inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>英文/数字/符号 这些格式的内容，一个字母对应一个字节 byte。</p>
<p>一个汉字对应三个字节 byte（在 UTF-8 编码格式下）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">            <span class="keyword">int</span> length = inputStream.read(bytes);</span><br><span class="line">            <span class="comment">//增强型for循环</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> aByte : bytes) &#123;</span><br><span class="line">                System.out.println(aByte);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">            <span class="comment">//截取流中的部分数据，从下标2开始，截取6个字符</span></span><br><span class="line">            <span class="keyword">int</span> length = inputStream.read(bytes,<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">            <span class="comment">//增强型for循环</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> aByte : bytes) &#123;</span><br><span class="line">                System.out.println(aByte);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>OutputStream</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\java\\image\\copy.txt"</span>);</span><br><span class="line">            outputStream.write(<span class="number">72</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\java\\image\\copy.txt"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = &#123;<span class="number">72</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>&#125;;</span><br><span class="line">            outputStream.write(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\java\\image\\copy.txt"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = &#123;<span class="number">72</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>&#125;;</span><br><span class="line">            outputStream.write(bytes,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 实现文件复制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\javahome\\test\\copy.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((temp = inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                outputStream.write(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>字符一定不小于字节，大于等于字节</p>
<p>字符流又分为输入字符流（Reader）和输出字符流（Writer）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Reader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((temp = reader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Reader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">            reader.read(chars);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">                System.out.println(aChar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Reader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">            reader.read(chars,<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">                System.out.println(aChar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节流是最基础的流，IO 流的基本单位，字符流是基于字节流，字符流是字节流经过处理之后的数据流。</p>
<blockquote>
<p>字符输入流</p>
</blockquote>
<p>Reader -&gt; InputStreamReader -&gt; FileReader</p>
<p>UTF-8 编码下，一个英文字符就是一个字节，在这种情况下，使用字符流和字节流是一样的，没有区别，一个汉字是三个字节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Reader reader = <span class="keyword">null</span>;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"使用字符流读取"</span>);</span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((temp = reader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"使用字节流读取"</span>);</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">while</span> ((temp = inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>read() 将文件中的数据以字符为单位依次读取出来</p>
<p>read(char[] chars)将文件中的数据复制到数组中，并返回数组的有效长度，数组长度要大于文件本身，否则数据读不完。</p>
<p>read(char[] chars,int off,int len)将文件中的数据复制到数组中，并返回数组的有效长度，但是数据会进行截取，len 指截取的文件长度（从 0 开始截取），off 是指数组中的偏移量，不是从 0 开始存数据，而是从 数组下标为off 的位置开始存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Reader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//父类引用指向子类（多态）</span></span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">            <span class="keyword">int</span> length = reader.read(chars,<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">            System.out.println(length);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">                System.out.println(aChar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符输出流</p>
</blockquote>
<p>OutputStream -&gt; OutputStreamWriter -&gt; Writer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Writer writer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writer = <span class="keyword">new</span> FileWriter(<span class="string">"D:\\java\\image\\copy.txt"</span>);</span><br><span class="line">            <span class="keyword">char</span>[] chars = &#123;<span class="string">'你'</span>,<span class="string">'好'</span>,<span class="string">'世'</span>,<span class="string">'界'</span>&#125;;</span><br><span class="line">            writer.write(chars,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>write(int a) 以字符对应的 ACS 码来进行文件数据的输出，需要把字符转为对应的 ASC 码</p>
<p>write(String str) 以字符串为单位进行输出，比较方便</p>
<p>write(String str,int off,int len) 以字符串为单位进行输出，进行截取，从 off 开始，截取长度为 len</p>
<p>write(char[] str) 以字符数组为单位进行输出</p>
<p>write(char[] str,int off,int len) 以字符数组为单位进行输出，进行截取，从 off 开始，截取长度为 len</p>
<p>如果要进行追加操作而不是覆盖的话，只需要在构造 FileWriter 的时候添加一个 boolean 类型参数即可，true 表示追加，false 表示覆盖。</p>
<h2 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h2><blockquote>
<p>处理流</p>
</blockquote>
<p>输入转换流 InputStreamReader</p>
<p>输出转换流 OutputStreamWriter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream,<span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理流和节点流（字节流和字符流）的区别</p>
<p>1、节点流可以直接连接到文件对象本身（看构造器能否直接传文件路径），处理流不能直接连接到文件对象本身，必须基于节点流（处理流的构造器只能将节点流作为参数传入）</p>
<p>2、节点流不能设置数据流的编码，文件本身是什么编码，数据流就是对应的编码，处理流可以通过构造器来设置编码，如果开发中遇到中文乱码的情况，可以使用处理流来进行设置。</p>
<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><blockquote>
<p>缓冲流</p>
</blockquote>
<p>实际开发中，无论使用哪种流（字节流或字符流），都会对硬盘造成损伤，为了解决这个问题，引入了缓冲流，自带缓冲区，可以一次性从硬盘中读取一部分数据存入缓冲区，减少对硬盘的访问次数。</p>
<p>缓冲流也属于处理流，不能直接连接文件对象进行操作，而是对已存在的节点流进行包装，基于节点流。</p>
<blockquote>
<p>字节输入缓冲流</p>
</blockquote>
<p>BufferedInputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        BufferedInputStream bufferedInputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//节点流</span></span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            <span class="comment">//缓冲流</span></span><br><span class="line">            bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(inputStream);</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((temp = bufferedInputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">                bufferedInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符输入缓冲流</p>
</blockquote>
<p>BufferedReader，提供了一个 <strong>readLine</strong> 方法，该方法可以按行读取文件中的数据，可以极大提升读取效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Reader reader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"D:\\java\\image\\test.txt"</span>);</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">            String s = bufferedReader.readLine();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字节输出缓冲流</p>
</blockquote>
<p>BufferedOutputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        BufferedOutputStream bufferedOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\java\\image\\copy.txt"</span>);</span><br><span class="line">            bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(outputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符输出缓冲流</p>
</blockquote>
<p>BufferedWriter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Writer writer = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writer = <span class="keyword">new</span> FileWriter(<span class="string">"D:\\java\\image\\copy.txt"</span>);</span><br><span class="line">            bufferedWriter = <span class="keyword">new</span> BufferedWriter(writer);</span><br><span class="line">            bufferedWriter.write(<span class="string">"Java是世界上最好的语言"</span>);</span><br><span class="line">            bufferedWriter.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">                bufferedWriter.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用缓冲流之后，一定要注意：在 close 之前必须先 flush，强制把数据输出，缓冲区就清空了，确保缓冲区中的数据已经全部传到了文件中，再来关闭流。否则会抛出 Stream closed 异常。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>HashMap底层数据结构</title>
    <url>/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="HashMap-的底层数据结构"><a href="#HashMap-的底层数据结构" class="headerlink" title="HashMap 的底层数据结构"></a>HashMap 的底层数据结构</h1><p>HashMap 底层是数组，称为哈希桶，JDK7 和 JDK8 版本的变动是比较大的。</p>
<p>存储结构：JDK7 是<strong>数组+链表</strong>，JDK8 是<strong>数组+链表+红黑树</strong>。</p>
<p><strong>本质就是为了存数据，改进是为了查询效率越来越高</strong></p>
<p><strong>为什么要使用数组+链表的形式？</strong></p>
<p>HashMap 底层数组的默认大小是 16，最大索引是 15，数组是可以<strong>扩容</strong>的。</p>
<p>HashMap 以 key-value 的形式进行存储，key+value 会以一个 Entry 对象的形式来存储，把 Entry 存入数组中，具体存入的下标不是按顺序存入，而是通过 key 获取对应的 hash 值，再根据 <strong>hash 值与数组最大索引进行按位与运算</strong>（将操作数转换为二进制，分别对比各位上的值，都为 1 则该位返回 1，否则返回 0，得到的结果就是按位与运算结果）</p>
<p>与数组最大索引进行按位与运算是为了保证数组下标不越界</p>
<p>A &amp; B 结果一定是小于等于 B</p>
<p>很有可能出现两个 Entry 下标一样，hash 冲突，我们应该尽量避免，如果一旦一样怎么处理？意味着需要将两个 Entry 存入数组中的同一个位置，所以就形成了链表。</p>
<p>数组中存储的是第一个 Entry 的地址，第二个 Entry 就往后排。</p>
<p><img src="/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.png" alt="1611106695027"></p>
<a id="more"></a>

<p><strong>为什么要使用红黑树呢？</strong></p>
<p>链表的缺点是查询效率低，因为查询链表中的任意一个元素，都需要从头开始遍历。</p>
<p>这种方式会导致 HashMap 取数据很慢，而取数据又是 HashMap 最常用的一个操作，所以 JDK 8 引入了红黑树来解决这个问题。</p>
<p>红黑树可以解决链表查询效率低的问题</p>
<p>红黑树是一种数据结构，其实是一个<strong>平衡二叉树</strong>，二叉树的查询效率很高。</p>
<blockquote>
<p>什么是二叉排序树？</p>
</blockquote>
<p>1、左子树上所有节点的值都小于等于它的根节点的值。</p>
<p>2、右子树上所有节点的值都大于等于它的根节点的值。</p>
<p>3、左、右子树分别为一个新的二叉排序树。</p>
<p><img src="/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.png" alt="1611106717976"></p>
<p>二叉排序树相比较于链表，查询效率很高出很多，所以选择使用二叉排序树来替代链表，但是纯二叉排序树有个缺点，有可能出现不平衡的二叉排序树，查询效率不会比链表高出多少。</p>
<p>所以二叉排序树必须要保证一定是一个平衡二叉树，因为不平衡二叉树其实和链表差不多。</p>
<p><img src="/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.png" alt="1611106741891"></p>
<p><strong>如何让二叉排序树保持平衡？</strong>这就是红黑树的作用。</p>
<p>1、节点是红色或者黑色。</p>
<p>2、根节点是黑色。</p>
<p>3、每个叶子节点都是黑色的空节点。</p>
<p>4、每个红色节点的两个子节点都是黑色（从每个叶子节点到根的路径上不能有两连续的红色节点）</p>
<p>5、从任一节点到它每个叶子节点的路径所包含的黑色节点的数目一致。</p>
<p><img src="/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.png" alt="1611106758744"></p>
<blockquote>
<p>HashMap 构造函数</p>
</blockquote>
<p><img src="/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.png" alt="1611106769184"></p>
<p>构造器中没有创建数组，HashMap 的数组是按需创建，<strong>只有在添加数据调用put的时候才会创建这个数组</strong>，如果不添加数据，则不会创建数组，避免空间浪费。</p>
<p><img src="/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.png" alt="1611110571610"></p>
<blockquote>
<p>HashMap 有两个重要的参数：容量（capacity）和负载因子（loadFactor）</p>
</blockquote>
<ul>
<li>容量：是指 HashMap 中桶的数量，默认值是 16</li>
<li>负载因子：判断 HashMap 是否需要扩容，默认值是 0.75</li>
</ul>
<p>HashMap 存放的元素总数量 / 容量，当该值等于 0.75 的时候，HashMap 就需要进行扩容</p>
<p>16*0.75 = 12</p>
<p>当 HashMap 中元素个数超过 12 的时候，数组就需要进行扩容，成倍扩容 32</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;初始默认值</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line">&#x2F;&#x2F;数组最大容量</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">&#x2F;&#x2F;默认加载因子</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">&#x2F;&#x2F;判断链表是否要转为红黑树，链表长度&gt;&#x3D;8就转换为红黑树了</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">&#x2F;&#x2F;判断红黑树是否转为链表，红黑树的深度&lt;&#x3D;6就转换为链表了</span><br><span class="line">static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">&#x2F;&#x2F;用来判断到底是链表转红黑树还是数组扩容，数组小于64只会发生扩容，不会进行转红黑树</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/20/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.png" alt="1611106782856"></p>
<p>当 key = null 直接返回 0，否则返回 key 的 hashCode 值与自己的高 16 位进行异或运算，</p>
<p>h &gt;&gt;&gt; 16 是用来取出 h 的高 16 位，&gt;&gt;&gt; 无符号右移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000 0100 1011 0011 1101 1111 1110 0001</span><br><span class="line">&gt;&gt;&gt; 16</span><br><span class="line">0000 0000 0000 0000 0000 0100 1011 0011</span><br></pre></td></tr></table></figure>

<p>因为 int 的取值范围是 -21 亿到 21 亿，40 亿种可能，长度为 40 亿的数组内存肯定是存不下的，HashMap 默认长度是 16。</p>
<p>所以需要跟自己的高 16 位进行异或运算（相同为 0，不同为 1），这样可以混合原始 hash 码的高位和低位，以此来加大低位的随机性，而且混合之后的低位同样会包含高位的信息，所以高位信息也被保留下来，散列分别更均匀，冲突的概率更小。</p>
<p>可能性太多，内存无法承载，所以需要想办法降低可能性，降低的同时还要保证其随机性，冲突概率更小，所以采用的是跟自己高 16 按位异或的做法。</p>
<p>拿到 key 的 hash 值之后，还要跟数组最大索引进行按位与运算（都为 1 返回 1，否则返回 0），最终的值才是正在的数组下标。</p>
<p>具体步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h&#x3D;hashCode:1111 1111 1111 1111 1111 0000 1110 1010</span><br><span class="line">h&gt;&gt;&gt;16:    0000 0000 0000 0000 1111 1111 1111 1111</span><br><span class="line"></span><br><span class="line">^:		   1111	1111 1111 1111 0000 1111 0001 0101</span><br><span class="line">15:		   0000	0000 0000 0000 0000 0000 0000 1111</span><br><span class="line"></span><br><span class="line">&amp;		   0000 0000 0000 0000 0000 0000 0000 0101</span><br></pre></td></tr></table></figure>

<p>得出下标index = 5</p>
<p>接下来看看putVal源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//创建一个Node数组（哈希桶）</span></span><br><span class="line">    	<span class="comment">//创建一个Node节点p，两个int变量 n，i</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    	<span class="comment">//判断数组是否为空，如果为空就创建数组</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//resize是创建数组和数组扩容的方法，默认创建长度为16的数组</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    		<span class="comment">//计算索引（数组最大索引&amp;hash），取出数组元素，判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果为null，直接创建Node存入</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//如果不为null，判断key是否相同</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//如果相同，则将已经存在的p赋给e</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//如果key不相同，需要在原Node基础上添加新的Node，这就形成了链表</span></span><br><span class="line">            <span class="comment">//判断该位置是链表还是红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//如果是红黑树，将Node存入红黑树</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是链表，就遍历链表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//遍历到最后一位</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//将Node存入</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//判断链表长度是否超过8</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st									    //将链表转为红黑树</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果链表中存在重复的key，则进行替换</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里的e是相同的值</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="comment">//将e的value记录下来</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="comment">//将被替换的值返回</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//哈希映射被修改的次数++</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            <span class="comment">//threshold=capacity*loadfactor=16*0.75=12</span></span><br><span class="line">            resize();<span class="comment">//数组扩容</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">    	<span class="comment">//如果key不重复，返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 底层是单向链表，只需要记录 next。</p>
<p>双向链表，每一个节点都会记录它的上一个节点和下一个节点。</p>
<p>转红黑树的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>如果数组的长度小于64，则不进行红黑树的转换，而是继续进行数组扩容，如果数组的长度大于64，再将链表转为红黑树。</p>
<p><strong>HashMap 存值总体过程：</strong></p>
<p>1、根据key计算hash值。</p>
<p>2、在put的时候判断数组是否存在，如果不存在则用 resize 方法创建默认长度为16的数组。</p>
<p>3、确定要存入的 Node 在数组中的位置，根据 hash 值与数组最大索引进行按位与运算得到索引位置。</p>
<p>4、判断该位置是否有元素，如果没有直接创建一个 Node 存入。</p>
<p>5、如果有元素，判断 key 是否相同，如果相同则覆盖，并且将原来的值直接返回。</p>
<p>6、如果 key 不相同，在原 Node 基础上添加新的 Node，判断该位置是链表还是红黑树。</p>
<p>7、如果是红黑树，将 Node 存入红黑树。</p>
<p>8、如果是链表，遍历链表，找到最后一位，将 Node 存入。</p>
<p>9、将 Node 存入链表之后，判断链表的结构是否要调整，判断链表长度是否超过 8，如果超过 8 需要将链表转为红黑树，这里还有一个条件，如果数组的容量小于 64，不转换红黑树，而是进行数组扩容，当数组的容量大于 64 的时候，再将链表转为红黑树。</p>
<p>10、存完之后，再次判断数组是否进行扩容，根据负载因子来判断。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2021/01/19/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>Generics （泛型）是指在类定义时<strong>不指定类中信息的具体数据类型</strong>，而是用一个标识符来替代，当外部实例化对象时来指定具体的数据类型。</p>
<p>有了泛型，就可以在定义类的时候不指定具体的类型信息，极大的提升程序的灵活性。</p>
<h2 id="泛型的应用"><a href="#泛型的应用" class="headerlink" title="泛型的应用"></a>泛型的应用</h2><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class 类名&lt;T,D,A...&gt;&#123;</span><br><span class="line">	private T param1;</span><br><span class="line">	private D param2;</span><br><span class="line">	private A param3;</span><br><span class="line">	</span><br><span class="line">	public T test()&#123;</span><br><span class="line">		return T;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Time</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Time&lt;Integer&gt; time = <span class="keyword">new</span> Time();</span><br><span class="line">        time.setValue(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"现在的时间是:"</span> + time.getValue());</span><br><span class="line">        Time&lt;String&gt; time1 = <span class="keyword">new</span> Time();</span><br><span class="line">        time1.setValue(<span class="string">"十点整"</span>);</span><br><span class="line">        System.out.println(<span class="string">"现在的时间是:"</span> + time1.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Time</span>&lt;<span class="title">H</span>,<span class="title">M</span>,<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> H hour;</span><br><span class="line">    <span class="keyword">private</span> M minute;</span><br><span class="line">    <span class="keyword">private</span> S second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> H <span class="title">getHour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHour</span><span class="params">(H hour)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hour = hour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> M <span class="title">getMinute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMinute</span><span class="params">(M minute)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.minute = minute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(S second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Time&lt;String,Integer,Float&gt; time = <span class="keyword">new</span> Time();</span><br><span class="line">        time.setHour(<span class="string">"十点"</span>);</span><br><span class="line">        time.setMinute(<span class="number">10</span>);</span><br><span class="line">        time.setSecond(<span class="number">10.0f</span>);</span><br><span class="line">        System.out.println(<span class="string">"现在时间是   "</span> + time.getHour() + <span class="string">":"</span> + time.getMinute() + <span class="string">":"</span> + time.getSecond());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>当方法的参数泛型不明确的时候，可以使用 ? 替代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list2.add(<span class="string">"a"</span>);</span><br><span class="line">        test(list1);</span><br><span class="line">        test(list2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ArrayList&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="泛型上限和下限"><a href="#泛型上限和下限" class="headerlink" title="泛型上限和下限"></a>泛型上限和下限</h2><p>泛型上限表示实例化的具体数据类型，可以是上限类型的子类或者上限类型本身，用 extends 关键字实现。</p>
<p>类名&lt;? extends 上限类名&gt;</p>
<p>泛型下限表示实例化的具体数据类型，可以是下限类型的父类或者下限类型本身，用 super 关键字实现。</p>
<p>类名&lt;? super 下限类型&gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1(<span class="keyword">new</span> Data&lt;Integer&gt;());</span><br><span class="line">        test1(<span class="keyword">new</span> Data&lt;Number&gt;());</span><br><span class="line">        test1(<span class="keyword">new</span> Data&lt;Double&gt;());</span><br><span class="line">        test2(<span class="keyword">new</span> Data&lt;String&gt;());</span><br><span class="line">        test2(<span class="keyword">new</span> Data&lt;Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Data&lt;? extends Number&gt; data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Data&lt;? <span class="keyword">super</span> String&gt; data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>集合框架</title>
    <url>/2021/01/19/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p>多个对象、多种类型，进行存储，数组</p>
<p>1、数组长度不可变</p>
<p>2、数组存入的数据类型必须是统一的</p>
<p>集合就是来解决问题的，替代数组来存储多个对象，多种数据类型</p>
<p>集合底层就是一个长度可变、类型可变的动态数组。</p>
<p>集合不是由一个类来完成的，而是由一组接口和类共同构成一个框架体系。</p>
<p>大致分为 3 层，最上层是接口，第二层是实现类，第三层是对集合进行操作的各种工具类。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>集合框架中最基础的父接口，可以存储一组无序、不唯一的对象。</p>
<p>迭代器 遍历集合</p>
<p>Collection 中的各种方法就组成了集合框架的基础</p>
<blockquote>
<p>Collection 的主要子接口</p>
</blockquote>
<ul>
<li>List：存放有序、不唯一的元素</li>
<li>Set：存放无序、唯一的元素</li>
<li>Queue：队列接口</li>
</ul>
<a id="more"></a>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 接口在继承 Collection 接口的基础上进行了 API 的扩展</p>
<p>get(int index)：通过下标找到元素</p>
<p>set(int index,Object o)：在指定下标处插入元素</p>
<p>indexOf(Object o)：找到元素在集合中的下标</p>
<blockquote>
<p>List 接口的实现类</p>
</blockquote>
<p>ArrayList 实现了长度可变的数组，底层是数组。</p>
<p>特点：查询快，增删慢</p>
<p>在内存中是一串连续的空间来存储数据。</p>
<p>LinkedList 底层是基于链表的结构，特点和 ArrayList 恰好相反</p>
<p>特点：查询慢、增删快</p>
<p>内存空间是不连续的，通过指针（前驱指针、后继指针）进行关联</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        arrayList.add(<span class="string">"Hello"</span>);</span><br><span class="line">        arrayList.add(<span class="string">"World"</span>);</span><br><span class="line">        arrayList.add(<span class="string">"JavaSE"</span>);</span><br><span class="line">        arrayList.add(<span class="string">"JavaME"</span>);</span><br><span class="line">        arrayList.add(<span class="string">"JavaEE"</span>);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        System.out.println(arrayList.contains(<span class="string">"Hello"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">            System.out.println(arrayList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line">        <span class="comment">//迭代器，也可以遍历集合</span></span><br><span class="line">        Iterator iterator = arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------"</span>);</span><br><span class="line">        iterator = arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------"</span>);</span><br><span class="line">        System.out.println(arrayList.remove(<span class="number">2</span>));</span><br><span class="line">        System.out.println(arrayList.size());</span><br><span class="line">        arrayList.add(<span class="number">1</span>, <span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        System.out.println(arrayList.indexOf(<span class="string">"abc"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector 是早期的一个 List 实现类，用法基本和 ArrayList 一致。</p>
<p>Vector 是线程安全的集合，Vector 都是用 synchronized 修饰的，</p>
<p>ArrayList 是线程不安全的集合。</p>
<p>线程安全的同时带来的缺陷是效率低、执行速度慢</p>
<p><strong>Vector、ArrayList、LinkedList 的区别？</strong></p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>Stack 是 Vector 的子类，Java 语言对栈这种数据结构的实现，后进先出</p>
<p>Java 借助于 List 容器来实现栈的特性</p>
<p>push 是入栈，将元素添加到栈中</p>
<p>peek 是取出栈顶元素的值，但是栈顶不出栈</p>
<p>pop 是直接让栈顶元素出栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        stack.push(<span class="string">"Hello"</span>);</span><br><span class="line">        stack.push(<span class="string">"JavaSE"</span>);</span><br><span class="line">        stack.push(<span class="string">"JavaME"</span>);</span><br><span class="line">        stack.push(<span class="string">"JavaEE"</span>);</span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; stack.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(stack.get(i));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 是 Collection 的子接口，Set 中存储的数据没有顺序，存储一组<strong>无序且唯一</strong>（数据不会重复）的数据。</p>
<p>List 存储一组有序（元素有下标）且不唯一（元素可以重复）的数据</p>
<p>Set 存储一组无序（元素没有下标）且唯一（元素不能重复）的数据</p>
<h3 id="Set常用的实现类"><a href="#Set常用的实现类" class="headerlink" title="Set常用的实现类"></a>Set常用的实现类</h3><p>HashSet 是开发中使用频率较高的 Set 的实现类，存储一组无序且唯一的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet hashSet = <span class="keyword">new</span> HashSet();</span><br><span class="line">        hashSet.add(<span class="string">"Hello"</span>);</span><br><span class="line">        hashSet.add(<span class="string">"World"</span>);</span><br><span class="line">        System.out.println(hashSet.add(<span class="string">"Java"</span>));</span><br><span class="line">        hashSet.add(<span class="string">"Python"</span>);</span><br><span class="line">        hashSet.add(<span class="string">"C++"</span>);</span><br><span class="line">        hashSet.add(<span class="string">"HTML"</span>);</span><br><span class="line">        System.out.println(hashSet.add(<span class="string">"Java"</span>));</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        System.out.println(hashSet.size());</span><br><span class="line">        System.out.println(<span class="string">"------------------------------------------------"</span>);</span><br><span class="line">        Iterator iterator = hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashSet 是 Set 另外一个实现类，可以存储一组有序且唯一的元素，这里的有序不是说元素有下标，这里的元素依然没有下标，有序是指元素存入的顺序和遍历的顺序是一致的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashSet linkedHashSet = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        linkedHashSet.add(<span class="string">"Hello"</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">"World"</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">"Java"</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">"Python"</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">"C++"</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">"HTML"</span>);</span><br><span class="line">        System.out.println(linkedHashSet);</span><br><span class="line">        Iterator iterator = linkedHashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(linkedHashSet.remove(<span class="string">"C++"</span>));</span><br><span class="line">        System.out.println(linkedHashSet.remove(<span class="string">"C++"</span>));</span><br><span class="line">        System.out.println(linkedHashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>hashCode 即使两个对象不一样，hashCode 的值也有可能相等</p>
<p>不能单纯用 hashCode 相等就来判断两个对象相等，如果 hashCode 值不相等，那么肯定是两个对象，但是 hashCode 值相等，不一定就是一个对象，进一步通过 eqauls 方法进行判断，如果 equals 方法返回 true，才能认为对象相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashSet linkedHashSet = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> A(<span class="number">1</span>));</span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> A(<span class="number">1</span>));</span><br><span class="line">        System.out.println(linkedHashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A&#123;"</span> +</span><br><span class="line">                <span class="string">"num="</span> + num +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>TreeSet 中也可以保存有序元素，这里的有序和 LinkedHashSet 不一样</p>
<p>LinkedHashSet 的有序是指元素的存入顺序和遍历顺序一致（怎么存怎么取）</p>
<p>TreeSet 的有序是指集合内部会<strong>自动给所有元素按照升序进行排队</strong>（大小个排队）</p>
<p>Java 中的接口是用来描述功能的，一个接口就表示某种功能 </p>
<p>java.lang.Comparable 的功能就是比较大小，哪个类实现了 Comparable 接口，就意味着该类的实例化具备比较大小的能力了。</p>
<p><strong>也就是说自动排序的功能依靠Comparable 实现，我们也可以自己写的类实现Comparable 接口自定义排序规则</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按大小排序</span></span><br><span class="line">        TreeSet treeSet = <span class="keyword">new</span> TreeSet();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> B(<span class="number">1</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> B(<span class="number">3</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> B(<span class="number">6</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> B(<span class="number">2</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> B(<span class="number">5</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> B(<span class="number">4</span>));</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B&#123;"</span> +</span><br><span class="line">                <span class="string">"num="</span> + num +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//自己定义排序规则</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A.compareTo(B)</span></span><br><span class="line"><span class="comment">         * 1:A &gt; B</span></span><br><span class="line"><span class="comment">         * 0:A = B</span></span><br><span class="line"><span class="comment">         * -1:A &lt; B</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        B b = (B)o;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.num &gt; b.num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.num == b.num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Set、List 都是 Collection 的子接口，Map 跟 Collection 是兄弟关系，平行的另外一套集合体系。</p>
<p>Set、List、Collection 只能操作单个元素，Map 可以操作一对元素（两个元素），这两个值是键值对的形式（key-value）</p>
<p>value 是真正的值，key 是 value 的别名</p>
<p>HashMap 是 Map 常用的实现类，存储一组无序，key 不可重复，value 可重复的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        hashMap.put(<span class="string">"h"</span>, <span class="string">"Hello"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"w"</span>, <span class="string">"World"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"j"</span>, <span class="string">"Java"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"s"</span>, <span class="string">"JavaSE"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"p"</span>,<span class="string">"Python"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"c"</span>, <span class="string">"C++"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"h2"</span>, <span class="string">"Hello"</span>);</span><br><span class="line">        System.out.println(hashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map 接口的实现类</p>
<ul>
<li>HashMap：存储一组无序，key 不能重复，value 可重复的数据</li>
<li>Hashtable：存储一组无序，key 不能重复，value 可重复的数据</li>
<li>TreeMap：存储一组有序，key 不能重复，value 可重复的数据</li>
</ul>
<p>Hashtable 是早期的一个 Map 实现类，线程安全，HashMap 是线程不安全的，所以</p>
<p>它的效率更高，实际开发中使用更多。</p>
<p>如果场景要求线程安全，则需要使用 Hashtable。</p>
<p>Map 无序，所有没有下标，不能用 for 循环遍历。</p>
<p>Map 没有继承 Iterable 接口，不能迭代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hashtable.put(<span class="string">"h"</span>, <span class="string">"Hello"</span>);</span><br><span class="line">        hashtable.put(<span class="string">"w"</span>, <span class="string">"World"</span>);</span><br><span class="line">        hashtable.put(<span class="string">"j"</span>, <span class="string">"Java"</span>);</span><br><span class="line">        hashtable.put(<span class="string">"p"</span>, <span class="string">"Python"</span>);</span><br><span class="line">        hashtable.put(<span class="string">"c"</span>, <span class="string">"C"</span>);</span><br><span class="line">        System.out.println(hashtable);</span><br><span class="line">        System.out.println(hashtable);</span><br><span class="line">        System.out.println(<span class="string">"----------------------------------------"</span>);</span><br><span class="line">        System.out.println(hashtable.containsKey(<span class="string">"c"</span>));</span><br><span class="line">        System.out.println(hashtable.containsValue(<span class="string">"TT"</span>));</span><br><span class="line">        System.out.println(hashtable.contains(<span class="string">"Hello"</span>));</span><br><span class="line">        <span class="comment">//迭代 Iterator</span></span><br><span class="line">        <span class="comment">//将Map中所有的key取出，返回一个Set</span></span><br><span class="line">        Set set = hashtable.keySet();</span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        Collection values = hashtable.values();</span><br><span class="line">        Iterator iterator1 = values.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator1.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        Set keySet = hashtable.keySet();</span><br><span class="line">        Iterator keyIter = keySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (keyIter.hasNext())&#123;</span><br><span class="line">            Object key = keyIter.next();</span><br><span class="line">            Object value = hashtable.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">"="</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeMap 中存储数据是有序的，有序指的是集合中的数据会按照 key 值进行升序排列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap treeMap = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> A(<span class="number">3</span>), <span class="string">"Java"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> A(<span class="number">1</span>), <span class="string">"JavaME"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> A(<span class="number">2</span>), <span class="string">"Hello"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> A(<span class="number">6</span>), <span class="string">"JavaEE"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> A(<span class="number">4</span>), <span class="string">"World"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> A(<span class="number">5</span>), <span class="string">"JavaSE"</span>);</span><br><span class="line">        System.out.println(treeMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A&#123;"</span> +</span><br><span class="line">                <span class="string">"num="</span> + num +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        A a = (A)o;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.num &lt; a.num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.num == a.num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>使用多线程可以让程序充分利用 CPU 的资源，提高 CPU 的使用效率，从而解决高并发带来的负载均衡问题。</p>
<p>缺点：</p>
<p>1、需要更多的内存空间来支持多线程的运行。</p>
<p>2、多线程并发访问可能会影响数据的准确性。</p>
<p>3、数据被多线程共享，可能出现死锁的情况。</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>计算机<strong>正在运行</strong>的一个独立的应用程序，就是一个进程。</p>
<p>线程是组成进程的基本单位，一个进程是由一个或多个线程组成的，每个线程都可以完成特定的功能。</p>
<p>应用程序是静态概念，进程和线程是动态概念，有创建有销毁，存在也是暂时的，不是永久的。</p>
<p>进程和线程的区别在于运行时是否拥有独立的内存空间，每个进程所占用的内存空间都是独立的。</p>
<p>但是多个线程是共享内存空间的，执行相互独立。</p>
<p>线程的执行必须依赖于进程，单独的线程是无法执行的，由进程控制线程的执行。</p>
<p>多线程是指在一个进程中，多个线程<strong>同时执行</strong>，这里的同时执行并不是真正意义上的同时执行，而是交替执行，系统资源按照时间段分别分配给不同的线程，多个线程是交替执行的，但是因为执行速度太快，感觉是同时执行的。</p>
<a id="more"></a>

<blockquote>
<p>单线程</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.southwind.test;</span><br><span class="line"></span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">            System.out.println(&quot;------------------------MyTest&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Test++++++++++++++++++++++++++"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MyTest myTest = <span class="keyword">new</span> MyTest();</span><br><span class="line">        myTest.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.png" alt="1611041286349"></p>
<p>两个循环按顺序排队执行，循环就是任务，现在只有一个线程来执行这些任务，那么必然是排队执行。</p>
<blockquote>
<p>多线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"------------------------MyTest"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Test++++++++++++++++++++++++++"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.png" alt="1611041302182"></p>
<p>两个循环交替执行，两个线程同时跑两个任务，一个线程跑一个。</p>
<p>如何判断程序是单线程还是多线程？只需要分析程序有几条分支即可。</p>
<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/3.png" alt="1611041328435"></p>
<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/4.png" alt="1611041341960"></p>
<h1 id="Java-中线程的使用"><a href="#Java-中线程的使用" class="headerlink" title="Java 中线程的使用"></a>Java 中线程的使用</h1><h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h2><p>1、创建自定义类继承 Thread 类。</p>
<p>2、重写 Thread 类中的 run 方法，完成线程的业务逻辑代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程类1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;MyThread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程类2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"+++++++++++++++++++++++MyThread2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread2 thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run方法和start方法的区别</p>
<p>run方法相当于普通方法调用，不会产生多线程的效果</p>
<p>start方法是开启线程争夺 CPU 资源，才会产生多线程的效果</p>
<h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><p>1、创建自定义类并实现 Runnable 接口。</p>
<p>2、实现 run 方法，编写该线程的业务逻辑。</p>
<p>3、实例化 Runnable 对象和 Thread 对象，同时将 Runnable 对象赋给 Thread 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"@@@@@@@MyRunnable@@@@@@"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"$$$$$$$$$$$$$$$$$$$$$$MyRunnable2$$$$$$$$$"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable runnable1 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable1);</span><br><span class="line">        MyRunnable2 runnable2 = <span class="keyword">new</span> MyRunnable2();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable2);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际开发中推荐使用实现的方式来完成，因为可以做到解耦合。</p>
<p>Runnable 是专门用来描述任务的接口，Runnable 的实现类就是各种任务的具体实现。</p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>线程有 5 种状态，在特定的情况下，线程可以在不同的状态之间切换。</p>
<p>1、创建状态：实例化一个新的线程对象，未启动。</p>
<p>2、就绪状态：创建好的线程对象调用 start 方法完成启动，进入线程池等待抢占 CPU 资源。</p>
<p>3、运行状态：线程对象获取了 CPU 资源，在分配给它的时间片段内执行任务。</p>
<p>4、阻塞状态：正在运行状态的线程暂停任务的执行，释放所占用的 CPU 资源。</p>
<p>5、终止状态：线程运行完毕或者因为异常导致该线程意外终止运行。</p>
<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/5.png" alt="1611041646841"></p>
<h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><h2 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h2><p>让当前线程暂停执行，从运行状态进入阻塞状态，将 CPU 资源让给其他线程的一种调度方式，通过 sleep 来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"+++++++++++++++++++main"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程合并"><a href="#线程合并" class="headerlink" title="线程合并"></a>线程合并</h2><p>合并的意思是将指定的线程加入到当前线程中，合并成一个线程，由两个线程交替执行变成一个线程中的两个子线程顺序执行。</p>
<p><strong>join()</strong> 实现合并，线程甲和线程乙，甲执行到某个时间节点的时候调用乙的 join 方法，则表示从当前时间开始 CPU 资源被线程乙独占，线程甲进入阻塞状态，直到线程乙执行完毕，线程甲进入就绪状态，等待获取 CPU 资源，进行执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JoinRunnable joinRunnable = <span class="keyword">new</span> JoinRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(joinRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thread.join();<span class="comment">//线程join到main主线程</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"+++++++++++++++++main"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">"----------------JoinRunnable"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>join 方法有重载，区别在于是否传入时间参数，重载的区别？</p>
<p>1、没有时间参数的 join，当子线程合并到主线程之后，子线程会独占 CPU 资源，释放的节点是子线程的任务全部执行完毕。</p>
<p>2、有时间参数的 join，传入的时间参数是 x，当子线程合并到主线程之后，子线程会独占 CPU 资源，释放的节点<strong>从合并的那一刻起到 x 时间结束</strong>，无论子线程是否执行完毕，都会释放 CPU 资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JoinRunnable joinRunnable = <span class="keyword">new</span> JoinRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(joinRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thread.join(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"+++++++++++++++++main"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i + <span class="string">"----------------JoinRunnable"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h2><p>线程礼让是指在某个特定的时间点，<strong>让线程暂停</strong>抢占 CPU 资源的行为，从运行状态或就绪状态来到阻塞状态，从而讲 CPU 资源让给其他线程来使用。</p>
<p><strong>只是在某个时间点去礼让，过了这个时间点，依然会争夺 CPU 资源。</strong></p>
<p>yield()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        YieldThread1 yieldThread1 = <span class="keyword">new</span> YieldThread1();</span><br><span class="line">        yieldThread1.setName(<span class="string">"线程甲"</span>);</span><br><span class="line">        YieldThread2 yieldThread2 = <span class="keyword">new</span> YieldThread2();</span><br><span class="line">        yieldThread2.setName(<span class="string">"线程乙"</span>);</span><br><span class="line">        yieldThread1.start();</span><br><span class="line">        yieldThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YieldThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                Thread.currentThread().yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"------"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YieldThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"------"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>同步和异步的区别</p>
<p>同步是指排队按顺序，依次执行，第一步执行完毕，才能执行第二步，等。</p>
<p>异步是指没有顺序不排队，同时执行，第一步没有执行，就可以执行第二步，不用等。</p>
<p>线程同步是对资源的一种保护，当多个线程同时访问某个资源时，多个线程必须排队使用，而不能一起使用。</p>
<p>多个线程同时操作一个共享数据，可能会导致<strong>数据不准确</strong>的情况。</p>
<p>要解决这个问题，如何解决？使用线程同步。</p>
<p><strong>synchronized</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(account);</span><br><span class="line">        thread1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(account);</span><br><span class="line">        thread2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer num = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test2<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"是当前的第"</span> + num + <span class="string">"位访客"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(account);</span><br><span class="line">        thread1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(account);</span><br><span class="line">        thread2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer num = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"是当前的第"</span> + num + <span class="string">"位访客"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 可以修饰实例方法，也可以修饰静态方法，两者在使用上是有区别的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    SynchronizedTest.test();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是否同步关键看多个线程对象使用的是否是同一个资源，如果是同一个资源（共享），加锁，就会实现同步，如果不是同一个资源，数据不共享，加锁，也不会实现同步。</p>
<h1 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h1><p>单例模式是 Java 设计模式中的一种，确保对象只有一份。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建了单例对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多线程场景下，需要使用线程同步来确保单例模式的正确性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建了单例对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建了单例对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//必须是一个唯一的对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SingletonDemo<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>JMM Java Memory Model</p>
<p><strong>volatile</strong> 的作用是可以使内存中的数据对线程可见</p>
<p>分为主内存和工作内存，数据是存在主内存中，要操作数据的时候，首先会将数据从主内存中<strong>复制一份</strong>到工作内存中，在工作内存中来操作该数据。</p>
<p>主内存中的数据对线程不可见，线程访问的都是副本。</p>
<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/6.png" alt="1611042870649"></p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁是一种互斥状态，多个线程同时执行，并且需要获取多个资源，但是每个线程都不愿意释放自己的资源，都在渴望其他线程释放资源为己所用，导致所有线程全程处于阻塞状态，谁都无法往下运行。</p>
<p>如何破解死锁？率先有一个线程愿意让出资源，让其他线程先执行，只要有一个线程执行完任务，就会释放它所占用的资源，其他线程的问题迎刃而解。</p>
<p>死锁演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Data data1 = <span class="keyword">new</span> Data();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Data data2 = <span class="keyword">new</span> Data();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;<span class="comment">//第一个人</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"获取到了data1，等待获取data2"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (data1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (data2)&#123;<span class="comment">//能拿到两根筷子，可以吃饭</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"用餐完毕！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">2</span>)&#123;<span class="comment">//第二个人</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"获取到了data2，等待获取data1"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (data2)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (data1)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"用餐完毕！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeadLockRunnable runnable1 = <span class="keyword">new</span> DeadLockRunnable();</span><br><span class="line">        runnable1.num = <span class="number">1</span>;</span><br><span class="line">        DeadLockRunnable runnable2 = <span class="keyword">new</span> DeadLockRunnable();</span><br><span class="line">        runnable2.num = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable1,<span class="string">"张三"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable2,<span class="string">"李四"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时发生死锁，进入死循环</p>
<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/7.png" alt="1611044862338"></p>
<p>想要破解死锁，就需要有人做出牺牲</p>
<p>例如将进程睡眠两秒，直接释放出一个人所持资源</p>
<p><img src="/2021/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/8.png" alt="1611045172224"></p>
<p>但要尽量不让多个线程竞争同一资源</p>
<h1 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h1><p><strong>ReentrantLock</strong> 是对 synchronzied 的升级，synchronized 是通过 JVM 实现的（关键字），ReentrantLock 是通过 JDK 实现的（通过 API 操作，调对象的方法）。</p>
<p>重入锁可以给同一个资源添<strong>加多把锁</strong>，解锁方式也是有区别的。</p>
<p>synchronized 是自动解锁（当线程执行完任务之后会自动释放锁）</p>
<p>ReentrantLock 必须<strong>手动释放锁</strong></p>
<p>lock()和unlock()必须成对出现，上多少把锁就得解多少把锁，也不能多解锁，否则都会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"是当前的第"</span> + num + <span class="string">"位访客"</span>);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        <span class="keyword">new</span> Thread(account,<span class="string">"张三"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(account,<span class="string">"李四"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 还具备<strong>限时性</strong>的特点，是指某个线程在一定时间内能否获取到锁</p>
<p>tryLock(long time,TimeUnit unit) boolean</p>
<p>//枚举 也是一种类，类的对象值数量是固定，有限的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3s之内要获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"拿到了锁"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"没有拿到锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;<span class="comment">//判断当前线程是否拥有该锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeLock timeLock = <span class="keyword">new</span> TimeLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(timeLock,<span class="string">"线程1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(timeLock,<span class="string">"线程2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2021/01/19/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="什么是异常？"><a href="#什么是异常？" class="headerlink" title="什么是异常？"></a>什么是异常？</h2><p>Java 中的错误大致分为两类：</p>
<p>1、<strong>编译时错误</strong>，语法错误</p>
<p>2、<strong>运行时错误</strong>，语法正确，逻辑错误</p>
<p>Java 中有一组类专门描述各种不同的运行时错误，叫做异常类，实例化对象就是各种异常对象。</p>
<p>1、程序出现错误时，会自动创建一个包含错误信息的异常对象。</p>
<p>2、将异常对象提交给系统。</p>
<p>3、由系统转交给能够处理这个异常的代码进行处理。</p>
<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>本质上分为两大类：</p>
<p>1、Error：指系统错误，由JVM生成，无法处理。</p>
<p>2、Exception：程序运行期间出现的错误，可以处理。</p>
<a id="more"></a>

<h2 id="异常的使用"><a href="#异常的使用" class="headerlink" title="异常的使用"></a>异常的使用</h2><p>try-catch</p>
<p>try（尝试运行） 包裹可能出现异常的代码，一旦出现异常，自动创建一个异常对象，交给系统，系统要分配下去，找到可以处理的代码进行处理。</p>
<p>catch（捕获异常）捕获系统抛出的异常，进行处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	&#x2F;&#x2F;可能抛出异常的代码</span><br><span class="line">&#125;catch(Exception exception)&#123;</span><br><span class="line">	&#x2F;&#x2F;处理异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论程序是否抛出异常，finally 代码块中的代码一定会执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	&#x2F;&#x2F;可能抛出异常的代码</span><br><span class="line">&#125;catch(Exception exception)&#123;</span><br><span class="line">	&#x2F;&#x2F;处理异常</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	&#x2F;&#x2F;一定要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"try..."</span>);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"finally..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h2><p>异常类的最顶端是 Throwable</p>
<p>Throwable 有两个直接子类：Error 和 Exception</p>
<p>Throwable、Error、Exception 三个类都存在于 java.lang 包中。</p>
<p>Error 常见的子类：VMError、AWTError、IOError。</p>
<p>VMError 常见子类：StackOverflowError、OutOfMemoryError。</p>
<p>Exception 常见子类：IOException 和 RuntimeException</p>
<p>IOException 的常见子类：FileLockInterruptionException、FileNotFoundException。</p>
<p>RuntimeException 的常见子类：</p>
<p>ArithmeticException 数学异常</p>
<p>ClassNotFoundException 类未定义异常</p>
<p>IllelgalArgumentException 参数格式异常</p>
<p>ArrayIndexOutOfBoundsException 数组下标越界异常</p>
<p>NullPointerException 空指针异常</p>
<p>NoSuchMethodException 方法未定义异常</p>
<p>NumberFormatException 将其他类型转为数字时报错，格式错误</p>
<p><img src="/2021/01/19/%E5%BC%82%E5%B8%B8/1.png" alt="1611040744372"></p>
<h2 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h2><p>都是 Java 处理异常时的关键字，都跟抛出异常有关系。</p>
<p>throws 是用来修饰方法的，表示该方法可能会抛出某个异常，告诉调用者使用的时候需要注意。</p>
<p><img src="/2021/01/19/%E5%BC%82%E5%B8%B8/2.png" alt="1611040797254"></p>
<p>throw 是抛出异常对象具体实现代码。</p>
<p><img src="/2021/01/19/%E5%BC%82%E5%B8%B8/3.png" alt="1611040817783"></p>
<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>++，参数必须是整数，不是整数就抛出异常（自定义异常）</p>
<p><img src="/2021/01/19/%E5%BC%82%E5%B8%B8/4.png" alt="1611041073624"></p>
<p>如果异常的父类是 RuntimeException，那么使用该异常的时候，可以不进行处理，叫做不检查异常。</p>
<p>如果异常的父类是 Exception，则该异常是受检查异常，使用该异常的时候，需要进行处理（1、try-catch自己解决，2、再次抛出 throws）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNumberException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNumberException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xzs.exception.MyNumberException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(add(<span class="keyword">new</span> Object()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Object object)</span> <span class="keyword">throws</span> MyNumberException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(object <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">            Integer num = (Integer)object;</span><br><span class="line">            <span class="keyword">return</span> ++num;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyNumberException(<span class="string">"操作数类型不是整数！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2021/01/19/%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口是由抽象类衍生出来的概念，抽象类是指类中至少存在一个抽象方法，抽象类是由抽象方法和非抽象方法组成的。</p>
<p>接口就是<strong>极度抽象的抽象类</strong>，类中所有方法都是抽象方法，没有非抽象方法。</p>
<p>接口主要用来实现解耦合。</p>
<p>面向接口编程的优点：</p>
<p>1、能够最大限度的解耦合，降低程序的耦合度。</p>
<p>2、使程序易于扩展。</p>
<p>3、有利于程序的后期维护。</p>
<h2 id="如何使用接口"><a href="#如何使用接口" class="headerlink" title="如何使用接口"></a>如何使用接口</h2><p>接口在 Java 中是独立存在的一种结构，和类相似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface 接口名&#123;</span><br><span class="line">	方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>接口中的方法全部都是抽象方法，同时接口中允许存在成员变量，有要求：</p>
<p>1、不能定义 private 和 protected 修饰的成员变量，只能定义 public 和默认成员变量。</p>
<p>2、接口中的成员变量在定义时必须初始化。</p>
<p>3、接口中的成员变量都是静态常量，可以通过接口之间访问，同时值不能修改。</p>
<p>使用接口，需要有实现类，实现类来实现接口中的抽象方法，把抽象的内容具体化。</p>
<p>1、用普通Java类实现接口，重写（实现）接口中的抽象方法。</p>
<p>2、如果实现类不希望重写方法，将实现类定义成抽象类即可。</p>
<p>3、接口不能实现接口。</p>
<p>4、接口可以继承接口。</p>
<p>接口其实是对继承的一种扩展，都是多态的体现。</p>
<p>扩展什么呢？</p>
<p>继承的原则是单继承，一个类只能有一个父类，但是接口是没有这个限制，一个实现类可以同时实现多个接口。</p>
<h2 id="面向接口编程的实际应用"><a href="#面向接口编程的实际应用" class="headerlink" title="面向接口编程的实际应用"></a>面向接口编程的实际应用</h2><p>面向对象编程 OOP 是一种思想，面向接口编程是一种具体的开发方式。</p>
<p>工厂生产产品A，需要用设备A来生产</p>
<p>Factory、EquipmentA</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.com.xzs.test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EquipmentA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"设备A运行，生产产品A..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.com.xzs.test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EquipmentA equipmentA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EquipmentA <span class="title">getEquipmentA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> equipmentA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEquipmentA</span><span class="params">(EquipmentA equipmentA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.equipmentA = equipmentA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始生产..."</span>);</span><br><span class="line">        <span class="keyword">this</span>.equipmentA.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.com.xzs.test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EquipmentA equipmentA = <span class="keyword">new</span> EquipmentA();</span><br><span class="line">        Factory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">        factory.setEquipmentA(equipmentA);</span><br><span class="line">        factory.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂接了新订单，生产产品B，必须由设备B来生产，工厂中只能有一台设备。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.com.xzs.test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Equiment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.com.xzs.test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Equiment equiment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Equiment <span class="title">getEquiment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> equiment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEquiment</span><span class="params">(Equiment equiment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.equiment = equiment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始生产..."</span>);</span><br><span class="line">        <span class="keyword">this</span>.equiment.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.com.xzs.test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EquipmentA equipmentA = <span class="keyword">new</span> EquipmentA();</span><br><span class="line">        EquipmentB equipmentB = <span class="keyword">new</span> EquipmentB();</span><br><span class="line">        EquipmentC equipmentC = <span class="keyword">new</span> EquipmentC();</span><br><span class="line">        Factory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">        factory.setEquiment(equipmentC);</span><br><span class="line">        factory.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Object、包装类</title>
    <url>/2021/01/19/Object%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>Java 类分三种：</p>
<p>1、JDK 提供的官方类库</p>
<p>2、第三方提供的类库（工具、框架）</p>
<p>3、开发自定义的类</p>
<p>Object 是 JDK 中的一个类，java.lang 包中，该类是所有类的直接父类或间接父类。</p>
<p>Java 程序中的每个类都是 Object 的后代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        hashCode();</span><br><span class="line">        getClass();</span><br><span class="line">        equals(<span class="keyword">null</span>);</span><br><span class="line">        clone();</span><br><span class="line">        toString();</span><br><span class="line">        notify();</span><br><span class="line">        notifyAll();</span><br><span class="line">        wait();</span><br><span class="line">        wait(<span class="number">100L</span>);</span><br><span class="line">        wait(<span class="number">100L</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="重写-Object-类的方法"><a href="#重写-Object-类的方法" class="headerlink" title="重写 Object 类的方法"></a>重写 Object 类的方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public String toString()</td>
<td>以字符串的形式返回对象的信息</td>
</tr>
<tr>
<td>public boolean equals(Object obj)</td>
<td>判断两个对象是否相等</td>
</tr>
<tr>
<td>public native int hashCode()</td>
<td>返回对象的hash值</td>
</tr>
</tbody></table>
<p><strong>== 比较的永远是变量的值</strong></p>
<p>变量的值就是变量中存储的数据</p>
<p>hashCode 方法用来获取对象的<strong>散列值</strong>，散列值是根据对象的内存地址和对象的信息映射出来的一个数值。</p>
<p>任何两个对象的内存地址肯定不一样，但是实际开发中如果两个对象的属性值完全一致，就认为是同一个对象，那么它们的散列值也是相等的。</p>
<p>eqauls 方法用来判断两个对象是否相等，hashCode 方法是返回对象的哈希值，实际开发中真正判断两个对象是否相等，需要结合 eqauls 和 hashCode 方法一同来判断。</p>
<p>为什么？为了提高效率。</p>
<p>判断两个对象是否相等</p>
<p>1、先判断两个对象的 hashCode 是否相等，如果不相等，则两个对象一定不是同一个对象，但是如果相等，则不能确定两个对象一定相等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2*6 &#x3D; 3*4</span><br></pre></td></tr></table></figure>

<p>2、再通过 equals 方法进行进一步的判断，最终得出两个对象是否相等的结论。</p>
<p>hashCode 执行效率高于 equals，优先使用 hashCode 进行判断，如果 hashCode 能确定结果，则不需要执行效率低的 equals，除非 hashCode 无法确定结果，不得不执行 equals 的时候再去执行 equals 得出结果。</p>
<p>表达式1 &amp; 表达式2 两个表达式都要执行</p>
<p>表达式1 &amp;&amp; 表达式2 表达式1 = false，表达式2 就不需要执行了，从而提升效率</p>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>包装类是 Java 提供的一组类，专门用来创建基本数据类型对应的对象，一共有 8 个，都保存在 java.lang 包中。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>包装类的体系结构</p>
<p><img src="/2021/01/19/Object%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB/1.png" alt="1611038838235"></p>
<h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>装箱：基本数据类型 —&gt; 包装类</p>
<p>public Type(type value) </p>
<p>public Type(String value)</p>
<p>以上两个方法不推荐使用</p>
<p>public static valueOf(type value) 静态工厂方法</p>
<p>静态工厂方法是专门用来创建对象的一个静态方法，功能上与构造器一样，都是用来创建对象的。</p>
<p>获取一个类的实例化对象，有两条路可以选择</p>
<p>1、构造器</p>
<p>2、静态工厂方法</p>
<p>区别：</p>
<p>1、静态工厂方法可以有自定义的名字。</p>
<p>2、静态工厂方法在需要的情况下可以保证单例模式。</p>
<p>拆箱：包装类 —&gt; 基本数据类型</p>
<p>*Value()</p>
<p>parse*(String value)</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>注解、多态的使用、 抽象方法和抽象类</title>
    <url>/2021/01/19/%E6%B3%A8%E8%A7%A3%E3%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>@Override 它告诉编译器这个方法是用来覆盖父类方法的。</p>
<p>@WebServlet Java Web 开发中表示某个类是一个 Servlet，Web 容器就会识别该类，从而加载运行该类，替代传统的 XML 开发，让程序开发更简洁。</p>
<p>注解和注释</p>
<p>注释完全不影响程序的运行，注解会影响程序的运行。</p>
<p>注释是给开发者看的，注解是给程序看的，编译器、框架、Web 容器。</p>
<p><strong>元注解</strong>：用来描述注解的注解，JDK 提供默认的注解，用这些默认注解帮助</p>
<p>开发者自定义需要的注解。</p>
<p>@Target 指定该注解使用的地方（类/方法）</p>
<ul>
<li><p>ElementType.TYPE   给类/接口使用</p>
</li>
<li><p>ElementType.METHOD 给方法使用</p>
</li>
<li><p>ElementType.FIELD 给属性使用</p>
</li>
<li><p>ElementType.PARAMETER 给方法参数使用</p>
</li>
</ul>
<p>@Retention 指定注解的保留域</p>
<ul>
<li><p>RetentionPolicy.SOURCE    编译器处理，处理之后就不再保留</p>
</li>
<li><p>RetentionPolicy.CLASS    class文件处理，类对应的class文件</p>
</li>
<li><p>RetentionPolicy.RUNTIME    JVM 读取，程序运行时使用</p>
</li>
</ul>
<a id="more"></a>

<p>自定义注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InitMethod &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitMethod</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitMethod</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解的解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取使用了注解的目标类</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.java.servlet.InitDemo"</span>);</span><br><span class="line">        <span class="comment">//检查目标类中哪些方法使用注解</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">if</span>(methods!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">               <span class="keyword">boolean</span> isInitMethod = method.isAnnotationPresent(InitMethod<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">               <span class="keyword">if</span>(isInitMethod)&#123;</span><br><span class="line">                   System.out.println(method.getName() + <span class="string">"使用了InitMethod注解"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>一个事物可以有多种表现形态，一个类本质是抽象的，实际使用的时候可以有多种不同的表现形态。</p>
<p>Java 程序中，定义一个抽象的方法，只有方法的声明，但是没有实现。在具体的生成环境中根据不同的需求呈现出不同的业务逻辑，很灵活，扩展性更好，实现了解耦合。</p>
<h1 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h1><p><strong>父类引用指向子类对象</strong>，就是多态的一种表现形式。</p>
<p>多态主要有两种表现形式：</p>
<p>1、方法定义时，形参为父类，调用方法时传入的参数是子类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">settlement</span><span class="params">(Member member)</span></span>&#123;</span><br><span class="line">    member.buyBook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OrdinaryMember ordinaryMember = <span class="keyword">new</span> OrdinaryMember();</span><br><span class="line">cashier.settlement(ordinaryMember);</span><br></pre></td></tr></table></figure>

<p>2、方法定义时，返回值为父类，调用方法时返回的是子类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Member <span class="title">getMember</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"ordinaryMember"</span>.equals(name))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrdinaryMember();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"superMember"</span>.equals(name))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SuperMember();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"参数有误"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(cashier.getMember(<span class="string">"ordinaryMember"</span>));</span><br><span class="line">System.out.println(cashier.getMember(<span class="string">"superMember"</span>));</span><br></pre></td></tr></table></figure>

<p>父子类之间的类型转换分为两种：向上转型、向下转型</p>
<p>向上转型就是将子类对象转为父类类型，自动完成类型转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Member member = <span class="keyword">new</span> OrdinaryMember();</span><br></pre></td></tr></table></figure>

<p>向下转型就是将父类对象转为子类类型，无法完成自动转型，需要手动进行强制转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OrdinaryMember ordinaryMember = (OrdinaryMember) <span class="keyword">new</span> Member();</span><br></pre></td></tr></table></figure>

<p>父类动物 子类猫</p>
<p>猫是动物 </p>
<p>动物是猫</p>
<h1 id="抽象方法和抽象类"><a href="#抽象方法和抽象类" class="headerlink" title="抽象方法和抽象类"></a>抽象方法和抽象类</h1><p>抽象方法：一个方法只有定义，没有具体实现。</p>
<p>抽象类：一个类中一旦出现抽象方法，该类就必须被定义抽象类。</p>
<p>为什么要有抽象方法？</p>
<p>多态的一种应用，多态场景下，需要定义一个父类，对父类进行编程，具体的实现交给子类完成，子类就需要对父类方法进行重写，也就是说父类方法无论怎么定义，最终都会被子类覆盖，那么父类的方法就不需要定义了，所以就需要将该方法定义为抽象的。</p>
<p>为什么一旦有了抽象方法，类就必须是抽象的？</p>
<p>抽象方法只是一种声明，没有具体实现，意味着方法所在的类不能被实例化，因为一旦实例化该类，意味着可以直接调用方法，但是方法是没有实现，所以不能调用。</p>
<p><strong>抽象方法所在的类不能被实例化</strong></p>
<p>将类定义成抽象类，抽象类的特点是不能被实例化。</p>
<p>抽象类/抽象方法如何使用</p>
<p>通过继承来实现多态，定义一个子类，继承抽象类，子类中实现抽象方法，写程序的时候操作子类即可。</p>
<p>如果子类也不想实现抽象方法，只需要将子类也定义成抽象类即可，相当于将实现抽象方法的任务再交给它的子类了。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>子类访问权限、方法重写和重载</title>
    <url>/2021/01/19/%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="子类访问权限"><a href="#子类访问权限" class="headerlink" title="子类访问权限"></a>子类访问权限</h1><p>子类可以通过 super 关键字访问父类中的资源，但并不是所有的父类资源都可以被子类访问。</p>
<p>访问权限修饰符</p>
<p>public、private、protected、缺省默认（不写）</p>
<table>
<thead>
<tr>
<th></th>
<th>同一个类</th>
<th>同一个包中</th>
<th>不同包</th>
<th>子类（同包）</th>
<th>子类（不同包）</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>可以访问</td>
<td>可以访问</td>
<td>可以访问</td>
<td>可以访问</td>
<td>可以访问</td>
</tr>
<tr>
<td>protected</td>
<td>可以访问</td>
<td>可以访问</td>
<td>不可以访问</td>
<td>可以访问，super可以访问</td>
<td>不可以访问，super可以访问</td>
</tr>
<tr>
<td>缺省默认</td>
<td>可以访问</td>
<td>可以访问</td>
<td>不可以访问</td>
<td>可以访问，super可以访问</td>
<td>不可以访问，super不可以访问</td>
</tr>
<tr>
<td>private</td>
<td>可以访问</td>
<td>不可以访问</td>
<td>不可以访问</td>
<td>不可以访问</td>
<td>不可以访问</td>
</tr>
</tbody></table>
<p>包（package）是 Java 管理文件的一种方式，一个工程可能会出现重名的类，通过包来解决冲突问题。</p>
<p>包的命名方式一般采用公司/组织的倒置域名</p>
<p>default 关键字是用来表示接口中的默认方法的，和访问权限修饰符的缺省默认值没有关系。</p>
<a id="more"></a>

<h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><p>子类在继承父类方法的基础上，对父类方法重新定义并覆盖的操作叫做方法重写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"输出人员信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.java.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个学生"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法不能被重写，构造方法不能被继承。</p>
<p>方法重写的规则：</p>
<p>1、父子类的方法名必须相同。</p>
<p>2、父子类的方法参数列表必须相同。</p>
<p>3、子类方法返回值与父类方法返回值相同，或者是其子类。</p>
<p>4、子类方法的访问权限不能小于父类，至少和父类一样，或者大于父类。</p>
<p>public &gt; protected &gt; 默认 &gt; private</p>
<p>父类 public，子类 public</p>
<p>父类 protected，子类 public、protected</p>
<p>父类默认，子类 public、protected、默认</p>
<p>父类 private，子类无法重写父类的方法，<strong>重写需要建立在继承的基础上</strong>，必须先有继承，才能有重写，父类的 private 修饰的方法是无法被子类继承的，所以无法重写。</p>
<h2 id="方法重写和方法重载"><a href="#方法重写和方法重载" class="headerlink" title="方法重写和方法重载"></a>方法重写和方法重载</h2><table>
<thead>
<tr>
<th></th>
<th>所在位置</th>
<th>方法名</th>
<th>参数列表</th>
<th>返回值</th>
<th>访问权限</th>
</tr>
</thead>
<tbody><tr>
<td>方法重写</td>
<td>子类重写父类方法</td>
<td>相同</td>
<td>相同</td>
<td>相同或是其子类</td>
<td>不能小于父类</td>
</tr>
<tr>
<td>方法重载</td>
<td>同一个类中</td>
<td>相同</td>
<td>不相同</td>
<td>没有要求</td>
<td>没有要求</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>继承、内部类</title>
    <url>/2021/01/19/%E7%BB%A7%E6%89%BF%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>描述类和类之间的一种关系，是 Java 实现代码重用/复用的重要机制。</p>
<p>被继承的类叫做父类 / 超类，继承父类的类叫做子类 / 派生类。</p>
<p>子类可以继承父类中的公有资源（成员变量和成员方法），父类的私有信息，子类无法继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="comment">//信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	<span class="comment">//继承父类的公有信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="子类访问父类"><a href="#子类访问父类" class="headerlink" title="子类访问父类"></a>子类访问父类</h2><p>只要两个类实现了继承关系，那么在创建子类对象的时候，一定会先创建父类对象。</p>
<p>无论子类对象是通过有参构造还是无参构造来创建，父类默认都是用无参构造创建。</p>
<p>每个类只能有一个直接父类，但是可以有多个间接父类。</p>
<p>可以通过手动修改的方式让父类调用自己的有参构造。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Student no args constructor execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Student args constructor execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>super 关键字表示在子类中访问父类的信息，跟 this 形成对比，this 关键字表示在类中访问本体的信息。</p>
<p>this()/this(…)   super()/super(…) 必须写在调用方法的第一行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(str + <span class="string">" object created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Stub parentStaticObject = <span class="keyword">new</span> Stub(<span class="string">"parent static object"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"parent static code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"parent code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stub parentObject = <span class="keyword">new</span> Stub(<span class="string">"parent object"</span>);</span><br><span class="line"></span><br><span class="line">    Stub stub;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"parent constructor execute"</span>);</span><br><span class="line">        stub = <span class="keyword">new</span> Stub(<span class="string">"parent constructor create object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Stub childStaticObject = <span class="keyword">new</span> Stub(<span class="string">"child static object"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"child static code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"child code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stub childObject = <span class="keyword">new</span> Stub(<span class="string">"child object"</span>);</span><br><span class="line"></span><br><span class="line">    Stub stub;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"child constructor execute"</span>);</span><br><span class="line">        stub = <span class="keyword">new</span> Stub(<span class="string">"child constructor create object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent static object object created</span><br><span class="line">parent static code execute</span><br><span class="line">child static object object created</span><br><span class="line">child static code execute</span><br><span class="line">parent code execute</span><br><span class="line">parent object object created</span><br><span class="line">parent constructor execute</span><br><span class="line">parent constructor create object object created</span><br><span class="line">child code execute</span><br><span class="line">child object object created</span><br><span class="line">child constructor execute</span><br><span class="line">child constructor create object object created</span><br></pre></td></tr></table></figure>



<p>new 一个类，加载这个类，（静态成员变量，静态代码块）</p>
<p>创建对象，（成员变量，代码块）-&gt; 构造器</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>是指一个类是另外一个类的内部成员，定义在某个类的内部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String outerName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OuterClass display"</span>);</span><br><span class="line">        System.out.println(outerName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String innerName;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">            innerName = <span class="string">"inner class"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"InnerClass display"</span>);</span><br><span class="line">            System.out.println(innerName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        outerClass.display();</span><br><span class="line">        InnerClass innerClass = outerClass.<span class="keyword">new</span> InnerClass();</span><br><span class="line">        innerClass.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>内部类对象的创建必须要依赖于外部类的实例化对象</strong></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>封装、static关键字</title>
    <url>/2021/01/19/%E5%B0%81%E8%A3%85%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="面向对象三大特征：封装、继承、多态"><a href="#面向对象三大特征：封装、继承、多态" class="headerlink" title="面向对象三大特征：封装、继承、多态"></a>面向对象三大特征：封装、继承、多态</h1><h2 id="什么是封装？"><a href="#什么是封装？" class="headerlink" title="什么是封装？"></a>什么是封装？</h2><p>类中的属性外部可以没有任何限制的随时访问和修改，造成数据的不安全。</p>
<p>为了避免这种情况，所以我们应该将类中的信息全部封装起来，让外部不能直接访问，而是有限制条件的进行访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让外部修改值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.err.println(<span class="string">"传入了非法的数据，已启用默认值0"</span>);</span><br><span class="line">            <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<p>1、将成员变量（属性）私有化（private）修饰。</p>
<p>2、提供公有的 setter/getter 方法。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使类和成员的可访问性最小化</p>
<p>组件</p>
<p>API Application Interface 应用程序接口</p>
<p>组件化搭配 将功能模块拆分成一个个组件，再把这些组件整合到一起，共同实现业务功能，组件怎么称呼 API</p>
<p>封装可以将 API 和具体实现进行隔离</p>
<p>接口，抽象类，类中的方法都是抽象没有具体实现，只提供概念，需要具体的实现类来完成抽象的实现。</p>
<p>组件之间只需要通过 API 进行通信即可，不同的组件完全不需要知道其他组件的具体实现。</p>
<p>解耦合</p>
<p>低耦合 高内聚</p>
<h1 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h1><p>static 表示静态或者全局，可以用来修饰成员变量或者成员方法或者代码块，</p>
<p>非 static 修饰的方法要调用，必须依赖于某个具体的实例化对象，而 static 修饰的方法不需要依赖于任何一个对象，属于类的信息，同时被该类所有的实例化对象所共享，所以是全局概念。</p>
<p>用 static 修饰的成员变量，多个对象共用，内存中只有一份，没有被 static 修饰的成员变量叫做实例变量，一个对象对应一个，内存中有多份。</p>
<p><img src="/2021/01/19/%E5%B0%81%E8%A3%85%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97/1.png" alt="1611036038080"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 test2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">            test2.id++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(test2.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>static 修饰成员方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个User对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>static 修饰代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"123"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态代码块的特点是只执行一次，当类被加载到 JVM 内存中的时候去执行。</p>
<p>静态代码块只执行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(<span class="string">"执行了静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个User对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user1 = <span class="keyword">new</span> User();</span><br><span class="line">        User user2 = <span class="keyword">new</span> User();</span><br><span class="line">        User user3 = <span class="keyword">new</span> User();</span><br><span class="line">        System.out.println(user1.num);</span><br><span class="line">        System.out.println(user2.num);</span><br><span class="line">        System.out.println(user3.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"static code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"main() execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/19/%E5%B0%81%E8%A3%85%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97/2.png" alt="1611036066885"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"static code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"main() execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/19/%E5%B0%81%E8%A3%85%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97/3.png" alt="1611036080142"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"static code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"main() execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/19/%E5%B0%81%E8%A3%85%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97/4.png" alt="1611036091484"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"code execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Test3 test3 = <span class="keyword">new</span> Test3();</span><br><span class="line">        System.out.println(<span class="string">"main() execute"</span>);</span><br><span class="line">        Test3 test2 = <span class="keyword">new</span> Test3();</span><br><span class="line">        Test3 test1 = <span class="keyword">new</span> Test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/19/%E5%B0%81%E8%A3%85%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97/5.png" alt="1611036103674"></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>构造函数、方法重载、成员变量和局部变量</title>
    <url>/2021/01/19/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>定义类的目的是为了创建对象，对象是 Java 的核心，面向对象编程语言。</p>
<p>如何通过类创建对象？</p>
<p>通过构造函数/构造方法/构造器创建对象。</p>
<p>构造函数其实是一种特殊的方法：</p>
<p>1、方法名必须是类名</p>
<p>2、不需要定义返回值类型</p>
<p>构造方法可以分为两类：无参构造和有参构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个类都拥有一个默认的无参构造函数，不需要开发者手动定义。</p>
<p>但是如果手动定义一个有参构造，则默认的无参构造会被覆盖掉，导致对象无法创建。</p>
<p>User@b4c966a</p>
<p>表示对象的信息 类@内存地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><p>用 this 来指代当前类的实例化对象</p>
<p>一个类可以生成 N 个对象</p>
<p>无参创建对象的时候，this = 799</p>
<p><img src="/2021/01/19/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/1.png" alt="1611035514896"></p>
<p>有参创建对象的时候，this = 866</p>
<p><img src="/2021/01/19/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/2.png" alt="1611035527432"></p>
<p>this 可以调用当前对象的属性和方法</p>
<p>this.id</p>
<p>this.show();</p>
<p>this();</p>
<h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><p>1、同一个类中</p>
<p>2、方法名相同</p>
<p>3、参数列表不同</p>
<p>4、与返回值和访问权限修饰符无关</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1+num2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,<span class="keyword">int</span> num3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1+num2+num3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">        test2.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        test2.add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h1><p>成员变量和局部变量指的是两种不同类型的变量，区别在哪？</p>
<p>变量所在的位置不同，作用域不同。</p>
<p>成员变量的作用域是整个类，成员变量是定义在方法外类中的。</p>
<p>局部变量的作用域只在它的方法中，局部变量是定义在某个方法中的。</p>
<p>成员变量会有默认值，可以不赋值</p>
<p>局部变量没有默认值，必须手动赋值</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>双亲委派模型</title>
    <url>/2021/01/19/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>ClassLoader</p>
<p>1、BootstrapClassLoader java包中的核心类库</p>
<p>2、ExtClassLoader javax包中的扩展类库</p>
<p>3、AppClassLoader 程序员自己写的类</p>
<p>4、自定义 ClassLoader</p>
<p>手写一个自定义 ClassLoader，反射</p>
<p>ClassLoader 的作用是将<strong>字节码文件</strong>加载到内存中</p>
<p>两个核心方法：findClass、defineClass</p>
<p>findClass：通过某种方法找到目标文件</p>
<p>defineClass：加载目标文件</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的类加载器</span></span><br><span class="line"><span class="comment"> * 功能：根据字节码文件的绝对路径来找到它，并完成加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存目标文件所在的目录</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，创建一个MyClassLoader对象的，在创建的同时将绝对路径存起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//定义我们加载字节码的逻辑</span></span><br><span class="line">        String classPath = <span class="keyword">this</span>.path+name+<span class="string">".class"</span>;</span><br><span class="line">        <span class="comment">//IO流读取</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(classPath);</span><br><span class="line">            outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((temp = inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                outputStream.write(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = outputStream.toByteArray();</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义类加载器，重写 findClass 方法，通过 IO 流读取本地编译好的字节码文件，生成字节数组，再将字节数组传给 ClassLoader 的 defineClass 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建MyClassLoader的对象</span></span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"D:\\java\\"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过findClass找到目标字节码文件，抽象成clazz对象</span></span><br><span class="line">            Class clazz = myClassLoader.findClass(<span class="string">"HelloWorld"</span>);</span><br><span class="line">            System.out.println(clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>类在 JVM 中加载的规则，任何一个类只需要在 JVM 中加载一次，不需要重复加载。</p>
<p>加载一个类的时候，首先从自定义的加载器开始查找，看它有没有加载过这个类，如果加载过，则直接返回，如果没有加载过，怎么办？就委派给 AppClassLoader 去加载。</p>
<p>开始查找 AppClassLoader 有没有加载过这个类，如果加载过，直接返回，否则委派给 ExtClassLoader 去加载，重复上述过程，直到委派给 BootstrapClassLoader，如果加载过，直接返回，如果此时还是没有加载，就会逆向加载，将整个过程反过来</p>
<p>BootstrapClassLoader –&gt; ExtClassLoader –&gt; AppClassLoader –&gt; 自定义 ClassLoader</p>
<p>如果还是没有加载到，就会抛出 ClassNotFoundException。</p>
<p><img src="/2021/01/19/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/1.png" alt="1611035147371"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz1 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">        System.out.println(clazz1);</span><br><span class="line">        Class clazz2 = Class.forName(<span class="string">"javax.sql.DataSource"</span>);</span><br><span class="line">        System.out.println(clazz2);</span><br><span class="line">        Class clazz3 = Class.forName(<span class="string">"com.southwind.test.User"</span>);</span><br><span class="line">        System.out.println(clazz3);</span><br><span class="line"></span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"D:\\java\\"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过findClass找到目标字节码文件，抽象成clazz对象</span></span><br><span class="line">            Class clazz4 = myClassLoader.findClass(<span class="string">"HelloWorld"</span>);</span><br><span class="line">            System.out.println(clazz4);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class clazz5 = Class.forName(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(clazz5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看源码 loadClass 加载类的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//上锁，避免多线程导致类重复加载</span></span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="comment">//c==null，表示没有加载过</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//判断它的父加载器是否为 null</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//委托父加载器进行加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果父加载器==null，说明到了顶层，Bootstarp加载器加载该类</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">//如果还是没有加载到，调用Bootstrap的findClass加载</span></span><br><span class="line">                <span class="comment">//依次向下发展</span></span><br><span class="line">                <span class="comment">//如果还是找不到则抛出ClassNotFoundException异常</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/2021/01/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>万物皆对象：将 Java 程序的所有参与角色都看成一个个对象，通过对象和对象之间的相互调用来完成系统的功能。</p>
<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><p>面向对象编程思想产生之前，使用的是面向过程的编程思想（面向功能划分的软件结构），自上至下，将一个大问题拆分成很多个小问题，再将小问题拆分成更小的问题，解决问题划分成一个个具体的步骤，分别执行，所有的步骤整合起来就是应用程序的功能，最小粒度细化到了方法的层面。</p>
<p>一个应该程序是由 N 个方法组成的，然后这些方法按一定的顺序执行。</p>
<p>你开车去北京：</p>
<p>1、打开车门</p>
<p>2、坐进车里</p>
<p>3、发动汽车</p>
<p>4、踩油门</p>
<p>……</p>
<p>500</p>
<p>….</p>
<p>1000、到达北京</p>
<p>面向过程的方式步骤繁琐、代码的可维护性很差，我们需要解决这些问题，如何解决？使用新的编程思想来完成，面向对象的编程思想。</p>
<p>面向对象只需要关注整件事情的参与者，即将每一个参与者都抽象成一个对象，再让这些对象完成相互关联即可。</p>
<p>你开车去北京：你、汽车、天津</p>
<p>让汽车载着你去北京，忽略掉过程中的每一个细节，关注点在于 3 个对象之间的关系，面向过程关注点在于每一个细微的步骤。</p>
<p>面向对象的优势在于灵活性和扩展性会更好。</p>
<a id="more"></a>

<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>1、属性：描述对象的静态特征</p>
<p>2、方法：描述对象的动态特征</p>
<p>对象就是用来描述客观存在的一个实体，该实体由一组方法和属性构成。</p>
<p>类是用来组织 Java 程序的，Java 程序是由很多个类组成的。</p>
<p>类是产生对象的模板，所有的对象都是通过类来创建的。</p>
<p>二者关系：</p>
<p>1、类是很多同类型对象的抽象化描述，这些对象具有相同的特征（属性和方法）。</p>
<p>2、对象是类的具体实例。</p>
<p>狗狗是类，隔壁家的旺财是对象。</p>
<p>一个类可以创建出很多个对象，一个对象一般来讲只能属于一个类，但是不够准确，因为类还有继承的概念（狗属于宠物的子类，宠物属于动物的子类），旺财是狗的对象，也可以是宠物的对象，也可以是动物的对象（继承、多态）。</p>
<h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>基本语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">	<span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">public</span> 数据类型 属性名;</span><br><span class="line">	<span class="comment">//定义方法</span></span><br><span class="line">    <span class="keyword">public</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String result = test2();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sout(<span class="string">"123"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="comment">//定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"展示用户信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Java-中的类是如何加载的？"><a href="#Java-中的类是如何加载的？" class="headerlink" title="Java 中的类是如何加载的？"></a>Java 中的类是如何加载的？</h2><p>类加载器 ClassLoader：将字节码文件（不是 Java 文件，而是编译之后的 class 文件）加载到内存（JVM Java虚拟机）中。</p>
<p>主要作用是将 JVM 以外的 Class 字节码文件装载到 JVM 中，进行初始化、执行操作。</p>
<p>Java 类的加载过程分为三步：加载（把文件给机器）、链接（机器读取文件数据）、初始化（根据数据创建对象及其他信息）。</p>
<p><img src="/2021/01/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.png" alt="1611034876559"></p>
<h2 id="ClassLoader-有-4-种类型"><a href="#ClassLoader-有-4-种类型" class="headerlink" title="ClassLoader 有 4 种类型"></a>ClassLoader 有 4 种类型</h2><p>1、<strong>Bootstrap</strong>ClassLoader</p>
<p>2、<strong>Ext</strong>ClassLoader</p>
<p>3、<strong>App</strong>ClassLoader</p>
<p>4、<strong>自定义</strong> ClassLoader</p>
<p>BootstrapClassLoader，C++ 编写，用来加载 Java 的<strong>核心类库</strong>，JDK 中大部分的类，java 开头的类。</p>
<p>ExtClassLoader，Java 编写，用来加载 Java 的<strong>扩展类库</strong>，javax 开头的类。</p>
<p>AppClassLoader，Java 编写，用来加载<strong>程序员自己编写的类</strong>。</p>
<p>自定义 ClassLoader，Java 编写，开发者可以<strong>根据具体的需求来编写类加载器</strong>，可以实现定制化加载。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2021/01/19/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组就是一种可以存放大量<strong>数据类型相同</strong>的变量的数据结构。</p>
<p>数组下标是 0 开始的，为什么？</p>
<p>为了极致的检索效率</p>
<p><img src="/2021/01/19/%E6%95%B0%E7%BB%84/1.png" alt="1611034260693"></p>
<p>1、数组中存储的数据必须都是同一种数据类型的。</p>
<p>2、数组在内存中开辟的空间是连续的，通过寻址公式快速计算出不同下标对应的内存地址。</p>
<a id="more"></a>

<h1 id="数组的基本要素"><a href="#数组的基本要素" class="headerlink" title="数组的基本要素"></a>数组的基本要素</h1><p>一个数组是由 4 个基本元素构成：</p>
<p>1、数组名称</p>
<p>2、数组元素</p>
<p>3、元素下标</p>
<p>4、数据类型</p>
<p><img src="/2021/01/19/%E6%95%B0%E7%BB%84/2.png" alt="1611034325423"></p>
<h1 id="如何使用数组"><a href="#如何使用数组" class="headerlink" title="如何使用数组"></a>如何使用数组</h1><p>1、声明数组：数据类型[] 数组名;数据类型 数组名[];</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array;</span><br></pre></td></tr></table></figure>

<p>2、分配内存空间：创建数组时必须要指定它的长度，数组长度不可变，固定的，根据这个长度和数据类型在内存（堆内存）中开辟一串连续的空间来存储数组元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br></pre></td></tr></table></figure>

<p>3、给数组赋值：通过下标找到对应的内存空间，把值存入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">array[<span class="number">1</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>4、使用数组：通过下标取出对应的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sout(array[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先声明，再赋值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] array;</span></span><br><span class="line"><span class="comment">//        array = new int[3];</span></span><br><span class="line"><span class="comment">//        array[0] = 1;</span></span><br><span class="line"><span class="comment">//        array[1] = 2;</span></span><br><span class="line"><span class="comment">//        array[2] = 3;</span></span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>边声明边赋值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用数组常见错误</p>
</blockquote>
<p>1、数组的数据类型不匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>2、边声明边赋值必须写在同一行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array;</span><br><span class="line">array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>3、数组下标越界异常</p>
<p><img src="/2021/01/19/%E6%95%B0%E7%BB%84/3.png" alt="1611034399727"></p>
<h1 id="数组的常用操作和方法"><a href="#数组的常用操作和方法" class="headerlink" title="数组的常用操作和方法"></a>数组的常用操作和方法</h1><p>1、求数组中元素的最大值</p>
<p>2、求数组中元素的最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">73</span>,<span class="number">80</span>,<span class="number">62</span>,<span class="number">93</span>,<span class="number">96</span>,<span class="number">87</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt; max)&#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、在数组的指定位置插入一个数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">73</span>,<span class="number">80</span>,<span class="number">62</span>,<span class="number">93</span>,<span class="number">96</span>,<span class="number">87</span>&#125;;</span><br><span class="line">        <span class="comment">//将83插入到下标为3的位置</span></span><br><span class="line">        <span class="keyword">int</span> score = <span class="number">83</span>;</span><br><span class="line">        <span class="comment">//1、创建长度为7的新数组</span></span><br><span class="line">        <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//2、将原数组中的值转移到新数组中，将下标3空出来</span></span><br><span class="line">        <span class="comment">//3以前</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            newArray[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3以后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; newArray.length; i++) &#123;</span><br><span class="line">            newArray[i] = array[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把83存入下标3中</span></span><br><span class="line">        newArray[<span class="number">3</span>] = <span class="number">83</span>;</span><br><span class="line">        System.out.println(Arrays.toString(newArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、数组排序 </p>
<p>冒泡排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">96</span>,<span class="number">93</span>,<span class="number">87</span>,<span class="number">80</span>,<span class="number">73</span>,<span class="number">62</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>-j; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &gt; array[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = array[i];</span><br><span class="line">            array[i] = array[i+<span class="number">1</span>];</span><br><span class="line">            array[i+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 提供了一个工具类，专门对数组进行各种操作，Arrays</p>
<p>1、安装虚拟机 Linux 不需要花钱</p>
<p>2、租一台服务器 阿里云 腾讯云 华为云 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraysTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">73</span>,<span class="number">80</span>,<span class="number">62</span>,<span class="number">93</span>,<span class="number">96</span>,<span class="number">87</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] array2 = &#123;<span class="number">73</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">93</span>,<span class="number">96</span>,<span class="number">87</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] array3 = &#123;<span class="number">66</span>,<span class="number">55</span>,<span class="number">44</span>,<span class="number">33</span>,<span class="number">22</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.equals(array, array2));</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        Arrays.fill(array, <span class="number">6</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        <span class="keyword">int</span>[] newArray = Arrays.copyOf(array3, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(newArray));</span><br><span class="line">        <span class="comment">//二分查找法的前提是目标数组必须是有序的，使用二分查找法之前应该先对数组进行排序</span></span><br><span class="line">        Arrays.sort(array2);</span><br><span class="line">        System.out.println(Arrays.toString(array2));</span><br><span class="line">        System.out.println(Arrays.binarySearch(array2, <span class="number">99</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p>一共有 6 个货柜，每个货柜中有 10 件商品</p>
<p>用数组的结构来保存所有商品的价格</p>
<p>二维数组其实就是一维数组，只不过一维数组中保存的值是另一个一维数组。</p>
<p><img src="/2021/01/19/%E6%95%B0%E7%BB%84/4.png" alt="1611034565490"></p>
<p>二维数组使用与一维数组类似</p>
<p>1、声明</p>
<p>2、开辟内存空间</p>
<p>3、赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、声明二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] array;</span><br><span class="line">        <span class="comment">//2、开辟内存空间</span></span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br><span class="line">        <span class="comment">//3、赋值</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        array[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] children = array[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; children.length; j++) &#123;</span><br><span class="line">                System.out.println(children[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"****************"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>超市卖鸡蛋货柜分上、中、下3层，每层分6个格挡，每个格挡中鸡蛋的个数是层数*格挡数，要求使用二维数组来装载所有的鸡蛋并求出总数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">6</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"------第"</span>+(i+<span class="number">1</span>)+<span class="string">"层货柜------"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = (i+<span class="number">1</span>) * (j+<span class="number">1</span>);</span><br><span class="line">                sum += num;</span><br><span class="line">                System.out.println(<span class="string">"第"</span>+(j+<span class="number">1</span>)+<span class="string">"个格挡的鸡蛋个数是："</span>+num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"鸡蛋的总数是"</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构复杂度计算</title>
    <url>/2021/01/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><ul>
<li>数据就是指一组数据的存储结构。</li>
<li>算法就是操作数据的一种方式。</li>
</ul>
<p>数据结构为算法进行服务，算法需要在特定的数据结构之上运行。</p>
<p>快：让程序运行速度更快，时间</p>
<p>省：让程序更加节省内存空间，空间</p>
<p>如何分析算法的执行效率</p>
<p>直接统计程序的运行时间和占用内存是可以的，叫做事后统计法，这种方式显然不客观，</p>
<p>太依赖于硬件配置和数据规模。</p>
<p>我们需要有一种统计方式，不需要考虑硬件配置和数据规模，估算算法执行效率的方式，这个方法就是时间复杂度分析法和空间复杂度分析法。</p>
<p>时间复杂度分析的是一个大概的趋势，并不是具体的数值。</p>
<a id="more"></a>

<h1 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">		sum += i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">    sum += i;</span><br></pre></td></tr></table></figure>

<p>每行代码执行时间为 time，我们认为只有读数据、运算、写数据的代码才占用时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time+time+n*time+n*time &#x3D; 2time+2n*time&#x3D;(2n+2)*time</span><br></pre></td></tr></table></figure>

<p>代码的执行时间和每行代码的执行次数成正比，记作 T(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">		j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;=n;j++)&#123;</span><br><span class="line">            sum += i*j;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;j&lt;=n;j++)&#123;</span><br><span class="line">        sum += i*j;</span><br></pre></td></tr></table></figure>

<p>每行代码执行时间为 time，我们认为只有读数据、运算、写数据的代码才占用时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3*time + 2n*time + 2n^2*time &#x3D; (2n^2+2n+3)*time</span><br></pre></td></tr></table></figure>

<p>T(n)：所有代码的执行时间和每行代码的执行次数成正比。</p>
<p>大 O 公式：T(n) = O(f(n))</p>
<p>T(n) 表示代码的执行时间</p>
<p>n 表示数据规模</p>
<p>f(n) 表示每行代码执行的次数总和的计算公式</p>
<p>O 表示代码的执行时间 T(n) 和 f(n) 成正比。</p>
<p>(2n+2)*time</p>
<p>T(n) = O((2n+2))</p>
<p>T(n) = O(2n^2+2n+3)</p>
<p>当 n 趋于无穷大的时候，低阶、系数、常量都可以省略，只需要记录最大量级即可。</p>
<p>T(n) = O(n)</p>
<p>T(n) = O(n^2)</p>
<h1 id="3-种时间复杂度统计方法"><a href="#3-种时间复杂度统计方法" class="headerlink" title="3 种时间复杂度统计方法"></a>3 种时间复杂度统计方法</h1><p>1、只关注循环执行次数最多的一行代码</p>
<p>2、加法法则：总复杂度等于量级最大的那段代码的复杂度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p &lt; <span class="number">100</span>;p++)&#123;</span><br><span class="line">        sum1 =+ p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;q&lt;n;q++)&#123;</span><br><span class="line">        sum2 += q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;=n;j++)&#123;</span><br><span class="line">            sum3 += i*j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum1+sum2+sum3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>100 + O(n) + O(n^2) </p>
<p>O(n^2)</p>
<p>T1(n) = O(f(n))</p>
<p>T2(n) = O(g(n))</p>
<p>T(n) = T1(n) + T2(n) = max(O(f(n)),O(g(n))) </p>
<p>3、乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T1(n) &#x3D; O(f(n))，T2(n) &#x3D; O(g(n))</span><br><span class="line">T(n) &#x3D; T1(n)*T2(n) &#x3D; O(f(n))*O(g(n)) &#x3D; O(f(n)*g(n))</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">		ret += f(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T(n) = O(n)*O(n) = O(n^2)</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>时间复杂度：表示算法的执行时间和数据规模之间的增长关系。</p>
<p>空间复杂度：表示算法的存储空间于数据规模之间的增长关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        a[i] = i*i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        sout(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间复杂度 O(n)</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>循环</title>
    <url>/2021/01/18/%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="while-循环和-do-while-循环的区别"><a href="#while-循环和-do-while-循环的区别" class="headerlink" title="while 循环和 do-while 循环的区别"></a>while 循环和 do-while 循环的区别</h1><p>do-while 循环会先执行一次循环体，再做判断（循环条件），决定是否进行下一次的循环，如果成立，则继续执行循环条，如果不成立，则跳出循环，所以至少会执行一次循环体。</p>
<p>while 先判断循环条件，再执行循环体，有可能一次都不执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"just do it"</span>);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;<span class="keyword">while</span> (num&lt;<span class="number">90</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">while</span> (num&lt;<span class="number">90</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"just do it"</span>);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="for-和-while、do-while-之间的区别"><a href="#for-和-while、do-while-之间的区别" class="headerlink" title="for 和 while、do-while 之间的区别"></a>for 和 while、do-while 之间的区别</h1><p>相同点：都遵循循环四要素。</p>
<p>不同点：</p>
<ul>
<li>while 和 do-while 适用于循环次数不确定的场景，for 适用于循环次数确定的场景。</li>
</ul>
<p>阻塞式方法</p>
<p>程序暂停，等待某一个操作，如果这个操作不执行，程序会一直暂停，直到该操作执行，才会继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//次数确定</span></span><br><span class="line">        <span class="comment">//Scanner 是 JDK 提供的一个对象，可以通过该对象获取用户输入的数据</span></span><br><span class="line"><span class="comment">//        System.out.print("请输入num的值：");</span></span><br><span class="line"><span class="comment">//        Scanner scanner = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">//        int num = scanner.nextInt();</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; num; i++) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(i);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//张三练习写代码 hello world，直到我满意为止</span></span><br><span class="line"><span class="comment">//        String result = "no";</span></span><br><span class="line"><span class="comment">//        Scanner scanner = new Scanner(System.in);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        do &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("张三练习写代码 hello world");</span></span><br><span class="line"><span class="comment">//            System.out.print("你是否满意？yes/no:");</span></span><br><span class="line"><span class="comment">//            result = scanner.next();</span></span><br><span class="line"><span class="comment">//        &#125;while(result.equals("no"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        while(result.equals("no"))&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("张三练习写代码 hello world");</span></span><br><span class="line"><span class="comment">//            System.out.print("你是否满意？yes/no:");</span></span><br><span class="line"><span class="comment">//            result = scanner.next();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println("张三练习完毕");</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>for 和 while 是先判断循环条件，再执行循环体；do-while 第一次是先执行，再判断循环条件。</li>
</ul>
<h1 id="双重循环"><a href="#双重循环" class="headerlink" title="双重循环"></a>双重循环</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">300</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span> ; i++) &#123;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/18/%E5%BE%AA%E7%8E%AF/1.png" alt="1610975904763"></p>
<p>像这种编程题就是找规律：</p>
<p>上半部分</p>
<p>第一行0：先打印 3 个空格，再打印 1 个数字</p>
<p>第二行1：先打印 2 个空格，再打印 2 个数字</p>
<p>第三行2：先打印 1 个空格，再打印 3 个数字</p>
<p>第四行3：先打印 0 个空格，再打印 4 个数字</p>
<p>行号从 0 开始，空格数 = 3 - 行号，数字个数 = 行号 + 1</p>
<p>下半部分</p>
<p>第一行0：先打印 1 个空格，再打印 3 个数字</p>
<p>第二行1：先打印 2 个空格，再打印 2 个数字</p>
<p>第三行2：先打印 3 个空格，再打印 1 个数字</p>
<p>行号从 0 开始，空格数 = 行号+1，数字个数 = 3 - 行号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上半部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//打印空格</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>-j; k++) &#123;</span><br><span class="line">                System.out.print(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt; <span class="number">2</span>*j+<span class="number">1</span>; i++) &#123;</span><br><span class="line">                System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下半部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//打印空格</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j+<span class="number">1</span>; k++) &#123;</span><br><span class="line">                System.out.print(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>-j; i &lt; <span class="number">5</span>-<span class="number">2</span>*j; i++) &#123;</span><br><span class="line">                System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="终止循环"><a href="#终止循环" class="headerlink" title="终止循环"></a>终止循环</h1><p>break</p>
<p>continue</p>
<p>break 跳出整个循环，continue 跳出本次循环，进入下一次循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1-100整数之和,当结果大于50的时候,结束循环</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">50</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型转换、运算符和流程控制</title>
    <url>/2021/01/18/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="1-数据类型转换"><a href="#1-数据类型转换" class="headerlink" title="1.数据类型转换"></a>1.数据类型转换</h1><h2 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        <span class="keyword">double</span> num2 = num1;</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序会自动识别数据类型并完成转换，这种操作对数据类型是有要求的，并不是所有的数据类型都能完成自动转换。</p>
<p>1、整型转浮点型都可以，跟字节大小没有关系。</p>
<p>int  –&gt;  float/double</p>
<p>long  –&gt;  float/double</p>
<p>2、浮点型转整型，都无法完成，因为有精度损失，小数点后数值有丢失，对数据的描述不精准。</p>
<p>3、精度一样（都是整型/都是浮点型）的情况下，只能由低字节转为高字节，反之则不行。</p>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>当自动转换不能实现的时候，我们可以通过强制手段进行转换，尽量不要强转，如果是基本数据类型，可能会有数据的精度损失，如果是引用类型，可能抛出类型转换异常。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> num1 = <span class="number">10.6f</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = (<span class="keyword">int</span>)num1;</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        Cat cat = (Cat) animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h1><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>=，将 = 右边的值赋给等号左边，= 右边可以是具体数值，也可以是一个变量，= 左边一定是变量。</p>
<p>int num1 = 10；int num2 = 11;交换 num1 和 num2 的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        temp = num1;</span><br><span class="line">        num1 = num2;</span><br><span class="line">        num2 = temp;</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本算术运算符"><a href="#基本算术运算符" class="headerlink" title="基本算术运算符"></a>基本算术运算符</h2><p>+、-、*、/、++、–</p>
<p>num++，先执行，再+1</p>
<p>++num，先+1，再执行</p>
<h2 id="复合算术运算符"><a href="#复合算术运算符" class="headerlink" title="复合算术运算符"></a>复合算术运算符</h2><p>在基本算术运算符的基础上进行进一步的简化操作</p>
<p>+=、-=、*=、/=、%=</p>
<p>变量A += 变量B：先求出变量A+变量B的值，再将结果赋值给变量A</p>
<p>变量A = 变量A+变量B</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>是用来计算一个表达式是否成立，boolean true/false</p>
<p>==、!=、&gt;、&lt;、&gt;=、&lt;=</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D; 只能用作数值类型的比较</span><br><span class="line">&#x3D;&#x3D;、!&#x3D; 所有类型都可以用</span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>只能操作 boolen 类型的数据，判断 boolean 数据之间的逻辑关系，与、或、非</p>
<p>&amp;、|、！、&amp;&amp;（短路与）、||（短路或）</p>
<p>&amp;&amp; 和 &amp; 从结果上看没有区别，但是 &amp;&amp; 的效率更高。</p>
<p>&amp;/&amp;&amp; 两个操作数都为 true，结果为 true，否则为 false</p>
<p>|/|| 两个操作数只要有一个为 true，结果为 true，否则为 false</p>
<p>! 取反操作</p>
<p>&amp;&amp; 如果左边表达式为 false，则不执行右边的表达式，直接返回结果 false。</p>
<p>|| 如果左边表达式为 true，则不执行右边的表达式，直接返回结果 true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">11</span>;</span><br><span class="line">        System.out.println((num1++ == num2) &amp;&amp; (++num1 == num2));</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>三目运算符、三元表达式，执行赋值操作，根据不同的条件给同一个变量赋不同的值。</p>
<p>变量A = 条件？值1：值2</p>
<p>int num = 10==9?1:2</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>对操作数以二进制为单位进行运算，首先将操作数转为二进制，再进行运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp; 按位与:每一位数字一一对应，如果都为1，则该位记作1，否则为0</span><br><span class="line"></span><br><span class="line">| 按位或:每一位数字一一对应，只要有一个为1，则改为记作1，否则为0</span><br><span class="line"></span><br><span class="line">^ 按位异或:每一位数字一一对应，相同记作0，不同记作1</span><br><span class="line"></span><br><span class="line">&lt;&lt; 左移:A&lt;&lt;B,A 乘以 2 的B次方</span><br><span class="line"></span><br><span class="line">&gt;&gt; 右移:A&gt;&gt;B,A 除以 2 的B次方</span><br></pre></td></tr></table></figure>



<h1 id="3-流程控制"><a href="#3-流程控制" class="headerlink" title="3.流程控制"></a>3.流程控制</h1><p>if-else 可以嵌套使用</p>
<ul>
<li>if 后面必须跟(条件)</li>
<li>else 后面不能根据(条件)</li>
<li>else 后面可以直接跟{}，也可以跟另外一个 if(条件)</li>
</ul>
<p>switch-case</p>
<p>功能上跟 if-else 是一致的，都是用来做流程控制的，区别在于 if-else 可以做等值判断、大于小于判断，switch-case 只能做等值判断。</p>
<p>同样做等值判断的情况下，switch-case 结构会比 if-else 更加清晰，有利于代码的可读性。</p>
<p>case 后面需要加 break</p>
<p>循环</p>
<p>for、while、do-while、foreach</p>
<p>循环四要素：</p>
<p>1、初始化循环变量</p>
<p>2、循环条件</p>
<p>3、循环体</p>
<p>4、更新循环变量</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>变量、数据类型</title>
    <url>/2021/01/18/%E5%8F%98%E9%87%8F%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h1><h2 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a>什么是变量？</h2><p>变量是计算机语言中的一个概念，可以表示一个具体的数值，同时这个值是可以改变的。</p>
<h2 id="为什么要使用变量？"><a href="#为什么要使用变量？" class="headerlink" title="为什么要使用变量？"></a>为什么要使用变量？</h2><p>100 元买了一款理财产品，年利率 3%，计算你年底的收益。</p>
<p>100</p>
<p>3%</p>
<p>乘法运算</p>
<p>1、需要在电脑中存储 100 和 3% 这两个数据。</p>
<p>2、将两个数据进行乘法运算。</p>
<p>计算机如何存储数据？</p>
<p>计算机将数据存储在内存中的，内存会为不同的数据开辟不同的空间来存储。</p>
<p><strong>每一块内存都有一个独一无二的地址</strong>，我们通过内存地址找到对应的内存，进而取出内存中存储的数据。</p>
<p>内存地址是一个十六进制的数据，0x6fff5cde3d6c</p>
<p><strong>内存地址不便于记忆，如何解决？通过变量解决</strong></p>
<p>因为内存地址不好记，我们就自定义一个好记的名字来代替内存地址，<strong>指向内存区域。</strong></p>
<a id="more"></a>

<h2 id="如何使用变量"><a href="#如何使用变量" class="headerlink" title="如何使用变量"></a>如何使用变量</h2><p>1、声明变量的数据类型和变量名（可以包含数字、字母、下划线、$，不能包含空格、运算符，不能用纯关键字来命名，不能以数字开头、大小写可以混用，驼峰式命名法：第一个单词全部小写，从第二个单词开始，首字母大写，后面全小写，userId、firstName、studentNum、studentSecondNum）</p>
<p>2、给内存空间赋值，这个值就是变量的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//100</span></span><br><span class="line">        <span class="comment">//1、开辟内存空间，int，变量名 num1</span></span><br><span class="line">        <span class="keyword">int</span> num1;</span><br><span class="line">        <span class="comment">//2、赋值</span></span><br><span class="line">        num1 = <span class="number">100</span>;</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-Java-中的数据类型"><a href="#2-Java-中的数据类型" class="headerlink" title="2.Java 中的数据类型"></a>2.Java 中的数据类型</h1><h2 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h2><p>数值类型、非数值类型</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1个字节（byte）8 bit</td>
</tr>
<tr>
<td>int</td>
<td>4个byte 32bit</td>
</tr>
<tr>
<td>short</td>
<td>2个byte 16bit</td>
</tr>
<tr>
<td>long</td>
<td>8个byte 64bit</td>
</tr>
<tr>
<td>float</td>
<td>4个byte 32bit</td>
</tr>
<tr>
<td>double</td>
<td>8个byte 64bit</td>
</tr>
<tr>
<td>char</td>
<td>2个byte 16bit</td>
</tr>
<tr>
<td>boolean</td>
<td>1 bit，1/8 byte</td>
</tr>
</tbody></table>
<p>int、double、boolean、String（引用类型）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ 既可以表示拼接也可以表示运算</span><br><span class="line">如果 + 左右两边至少有一边是字符串，就是拼接，将不是字符串的数据转成字符串，然后将两个字符串进行拼接</span><br><span class="line">否则就进行算术加法运算</span><br><span class="line">如果 + 左右两边是字符，而不是字符串，则不是拼接，将字符转为对应的 ASCII 码（数值），再进行加法运算</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">        String name = <span class="string">"张三"</span>;</span><br><span class="line">        System.out.println(<span class="string">"用户信息"</span>);</span><br><span class="line">        System.out.println(<span class="string">"编号："</span> + id);</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + name);</span><br><span class="line">        System.out.println(<span class="string">'A'</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>注释、关键词</title>
    <url>/2021/01/18/%E6%B3%A8%E9%87%8A%E3%80%81%E5%85%B3%E9%94%AE%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h1><p>帮助开发者更好地读懂代码，用<strong>通俗易懂</strong>的语言对代码进行解释说明，方便自己和他人阅读。</p>
<p>注释可以是编程思路，也可以是功能描述或者程序的作用，总之就是对代码的进一步阐述。</p>
<p>注释是专门给程序员看的，计算机直接跳过。</p>
<p>Java 中有几种注释？</p>
<p>1、单行注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注释内容</span><br></pre></td></tr></table></figure>

<p>2、多行注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*注释内容</span><br><span class="line">注释内容</span><br><span class="line">注释内容*&#x2F;</span><br></pre></td></tr></table></figure>

<p>3、文档注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*注释内容</span><br><span class="line">*注释内容</span><br><span class="line">*注释内容</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p>IDEA/Eclipse 可以自动生成文档注释，根据 JDK 的 javadoc 工具来自动生成，直接显示到代码中。</p>
<p>javadoc 注释</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@author</td>
<td>标识作者</td>
</tr>
<tr>
<td>@param</td>
<td>标识方法的参数</td>
</tr>
<tr>
<td>@renturn</td>
<td>标识方法的返回值</td>
</tr>
<tr>
<td>@version</td>
<td>标识版本</td>
</tr>
<tr>
<td>@since</td>
<td>标识从哪个版本开始引入</td>
</tr>
<tr>
<td>@see</td>
<td>标识参考的内容（相关的类有哪些）</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2.关键字"></a>2.关键字</h1><p>Java 语言预先定义好的，具有特殊意义的标识符（单词），是程序的核心组成。</p>
<p>Java 程序：关键字 + JDK类库 + 逻辑代码</p>
<p>关键字构建程序的主体框架</p>
<p>JDK 类库提供某些功能的调用</p>
<p>逻辑代码实现程序的业务逻辑的</p>
<p>IDEA 中橙色字体显示的都是关键字 public、static、int、void…</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>case</td>
<td>与switch组合使用，进行流程控制</td>
</tr>
<tr>
<td>catch</td>
<td>捕获异常</td>
</tr>
<tr>
<td>char</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>class</td>
<td>声明一个类</td>
</tr>
<tr>
<td>continue</td>
<td>跳出循环</td>
</tr>
<tr>
<td>default</td>
<td>与switch组合使用，表示默认值</td>
</tr>
<tr>
<td>do</td>
<td>与while组合使用，表示循环</td>
</tr>
<tr>
<td>double</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>else</td>
<td>与if组合使用，进行流程控制</td>
</tr>
<tr>
<td>enum</td>
<td>枚举类型，Java 中的一种特殊的类</td>
</tr>
<tr>
<td>extends</td>
<td>实现类的继承</td>
</tr>
<tr>
<td>final</td>
<td>修饰常量</td>
</tr>
<tr>
<td>finally</td>
<td>与try、catch搭配使用，处理异常</td>
</tr>
<tr>
<td>float</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>for</td>
<td>循环</td>
</tr>
<tr>
<td>if</td>
<td>流程控制</td>
</tr>
<tr>
<td>implements</td>
<td>实现接口</td>
</tr>
<tr>
<td>import</td>
<td>引入某个类</td>
</tr>
<tr>
<td>int</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>interface</td>
<td>接口</td>
</tr>
<tr>
<td>instanceof</td>
<td>判断对象的类型</td>
</tr>
<tr>
<td>long</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>native</td>
<td>修饰本地方法</td>
</tr>
<tr>
<td>new</td>
<td>创建实例对象</td>
</tr>
<tr>
<td>package</td>
<td>表示包，用来组织 Java 类的</td>
</tr>
<tr>
<td>private</td>
<td>访问权限修饰符，表示私有</td>
</tr>
<tr>
<td>protected</td>
<td>访问权限修饰符，表示保护</td>
</tr>
<tr>
<td>public</td>
<td>访问权限修饰符，表示公开</td>
</tr>
<tr>
<td>return</td>
<td>表示方法的返回值</td>
</tr>
<tr>
<td>short</td>
<td>基本数据类型，短整型</td>
</tr>
<tr>
<td>static</td>
<td>静态修饰符</td>
</tr>
<tr>
<td>super</td>
<td>表示父类的成员</td>
</tr>
<tr>
<td>switch</td>
<td>流程控制，和case组合使用</td>
</tr>
<tr>
<td>synchronized</td>
<td>线程同步</td>
</tr>
<tr>
<td>this</td>
<td>表示调用当前实例对象的成员</td>
</tr>
<tr>
<td>throw</td>
<td>抛出异常，与 try、catch、finally 组合使用</td>
</tr>
<tr>
<td>throws</td>
<td>标识方法中可能抛出的异常</td>
</tr>
<tr>
<td>try</td>
<td>异常处理，与 catch、throw、finally 组合使用</td>
</tr>
<tr>
<td>void</td>
<td>表示当前方法没有返回值</td>
</tr>
<tr>
<td>volatile</td>
<td>确保主内存对所有线程可见</td>
</tr>
<tr>
<td>while</td>
<td>循环结构</td>
</tr>
</tbody></table>
<p>byte 和 bit 的区别？</p>
<p>1 byte（字节）  = 8 bit（一位二进制数 0/1）</p>
<p>100 Kb/s</p>
<p>1KB = 1024 byte</p>
<p>1MB = 1024 KB</p>
<p>1GB = 1024 MB</p>
<p>1TB = 1024 GB</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>JVM初步认识</title>
    <url>/2021/01/18/JVM%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<h1 id="1-JVM-指令"><a href="#1-JVM-指令" class="headerlink" title="1.JVM 指令"></a>1.JVM 指令</h1><p>class 文件中的程序的执行逻辑，java 文件中编写程序的逻辑，</p>
<p>JVM 对 class 文件的具体执行方式</p>
<p>1、写 Java 代码</p>
<p>2、编译成 class 字节码文件（16 进制，程序员根本看不懂）</p>
<p>3、对 class 字节码进行<strong>反汇编</strong>，成为程序员能看懂的 JVM 指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javap -c Test.java</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">"Test.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0                           <span class="comment">// 栈帧</span></span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>                            <span class="comment">// 结束</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">10</span>                  <span class="comment">//压栈</span></span><br><span class="line">       <span class="number">2</span>: istore_1                          <span class="comment">//把栈顶元素取出来赋给局部变量表第1个元素</span></span><br><span class="line">       <span class="number">3</span>: bipush        <span class="number">20</span>                  <span class="comment">//压栈</span></span><br><span class="line">       <span class="number">5</span>: istore_2                          <span class="comment">//把栈顶元素取出来赋给局部变量表第2个元素</span></span><br><span class="line">       <span class="number">6</span>: iload_1                           <span class="comment">//取出局部变量表第1个元素</span></span><br><span class="line">       <span class="number">7</span>: iload_2                           <span class="comment">//取出局部变量表第2个元素</span></span><br><span class="line">       <span class="number">8</span>: iadd                              <span class="comment">//进行相加操作，压栈</span></span><br><span class="line">       <span class="number">9</span>: istore_3                          <span class="comment">//把栈顶元素取出来赋给局部变量表第3个元素</span></span><br><span class="line">      10: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;  获取out静态实例</span><br><span class="line">      <span class="number">13</span>: iload_3                           <span class="comment">//取出局部变量表第3个元素</span></span><br><span class="line">      14: invokevirtual #13                 // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">17</span>: <span class="keyword">return</span>                            <span class="comment">// 结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-JVM-内存模型"><a href="#2-JVM-内存模型" class="headerlink" title="2.JVM 内存模型"></a>2.JVM 内存模型</h1><p>JVM 可以分为 5 个部分</p>
<p>1、类加载器 Class Loader</p>
<p>2、<strong>运行时数据区 Runtime Data Area</strong></p>
<pre><code>- 方法区
- 虚拟机栈
- 本地方法栈
- 堆
- 程序计数器</code></pre><p>3、执行引擎 Execution Engine</p>
<p>4、本地库接口 Native Interface</p>
<p>5、本地方法库 Native Libraries</p>
<p><img src="/2021/01/18/JVM%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/1.png" alt="1603379698128"></p>
<p>运行时数据区：</p>
<p>1、方法区</p>
<p><strong>存储 JVM 加载的类信息，常量、静态变量。</strong></p>
<p>方法区是一种规范，永久代是方法区的一种实现。</p>
<p>面试题：JDK 7 之前的版本字符串常量池存放在永久代中的，JDK 7 将字符串常量池移动到了堆中，JDK 8 直接删除了永久代，改用<strong>元空间</strong>替代永久代。</p>
<p>2、本地方法栈</p>
<p>用来执行本地方法的</p>
<p>什么是 Java 的本地 native 方法？</p>
<p><strong>Java 是基于应用层的高级编程语言，无法访问操作系统底层信息。</strong></p>
<p><strong>就需要使用其他可以访问底层的编程语言来完成功能 C++，再通过 Java 来调用就可以实现需求。</strong></p>
<p>本地方法的使用原理：</p>
<p>1、在 Java 程序中声明 native 修饰的方法，只有方法定义，没有方法实现，将 Java 文件编译成字节码文件。</p>
<p>2、用 <strong>javah</strong> 编译字节码文件，生成一个后缀为 <strong>.h</strong> 的文件。</p>
<p>3、写一个 .cpp 文件实现 .h 文件中的方法。</p>
<p>4、将 .cpp 文件编译成<strong>动态链接库文件 .dll</strong>。</p>
<p>5、使用 System.loadLibrary() 加载动态链接库，从而实现本地的调用。</p>
<p>利用了<strong>反射机制</strong>，运行时找到 .dll 文件并解析，根据动态链接库中的文件名创建对象和方法，从而实现通过对象调用方法的过程。</p>
<p>常见的本地方法：</p>
<p>getClass、hashCode、clone 都是 Object 类中的方法。</p>
<p>3、程序计数器</p>
<p>占用内存空间较小，是<strong>当前线程所执行的字节码行号指示器</strong>（记录当前线程执行到哪了），多个线程之间的程序计数器是相互独立的，互不影响，为了保证每个线程恢复后都可以找到具体的执行位置。</p>
<p>（例：并发执行时，一个程序员一会写这台电脑代码，一会写另一台电脑代码，间断执行，停下写一台电脑代码时，靠程序计数器记下这个执行位置，等到又要写这台电脑代码时则可从该位置继续写代码）</p>
<p>4、Java 堆</p>
<p>Java 堆用来<strong>存储实例化对象</strong>的，Java 中所有的对象一定都是存储在堆中的，Java 堆<strong>被所有的线程共享</strong>，<strong>在虚拟机启动时创建的，用来存储对象的实例</strong>，是 Java 内存结构中的占比最大的一块区域，也是 GC 垃圾回收机制主要管理的区域，又可以分为年轻代、老年代。</p>
<blockquote>
<p>年轻代</p>
</blockquote>
<p>又分为 Eden（伊甸园），Survivor（存活）：Survivor From、Survivor To</p>
<p>Eden：对象刚被创建的时候，存放在 Eden 区，如果 Eden 区放不下，则放入 Survivor 中，甚至于放入到老年代中。</p>
<p>Survivor：Survivor 又可以分为 Survivor From  和 Survivor To，GC 回收时使用，将 Eden 中存活对象放入 Survivor From 中，下一次回收时，将 Survivor From 中存活的对象转移到 Survivor To 中，清除剩下的对象，下一次回收时，将 Survivor To 中存活的对象转移到 Survivor From 中，清除剩下的对象，下一次回收时，继续重复上述步骤…</p>
<p><img src="/2021/01/18/JVM%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/2.png" alt="1603639162176"></p>
<blockquote>
<p>老年代</p>
</blockquote>
<p>存放生命周期较长的对象，经过多次 GC 之后还没有被回收的，或者引用次数很多、或者引用链比较长的对象，都是存放在老年代中。</p>
<blockquote>
<p>元空间（元数据空间）MetaSpace</p>
</blockquote>
<p>JDK 8 之后开始将类的数据存放在堆内存中，这块区域叫做元空间，JDK 7 以前，元空间时放在永久代中的，JDK 8 之后永久代被删除了，元空间就独立出来了。</p>
<p>元空间和永久代是方法区的实现，方法区只是一种规范，永久代使用 JVM 内存，空间有限，元空间使用的是本地内存，使得程序的内存不再受限于 JVM 内存，本地内存有多少可以用，理论上元空间就有多大，解决了内存空间不足的问题。</p>
<p>5、虚拟机栈</p>
<p>Java 方法执行的内存模型，Java 栈中存放最多的是栈帧，每个栈帧对应一个被调用的方法，栈帧中包括：局部变量表、操作数栈、运算符栈、动态链接、方法的返回地址（方法出口）。</p>
<p>每一个方法的执行，JVM 都会创建一个栈帧，并且将该栈帧压入 Java 栈，方法执行完毕，该栈帧出栈。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;成员变量&#x2F;类变量</span><br><span class="line">int m &#x3D; 10;</span><br><span class="line"></span><br><span class="line">public void test(int a)&#123;</span><br><span class="line">	&#x2F;&#x2F;局部变量</span><br><span class="line">	int i &#x3D; 10;</span><br><span class="line">	int j &#x3D; 20;</span><br><span class="line">	int k &#x3D; i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void test2()&#123;</span><br><span class="line">	int k &#x3D; 100;</span><br><span class="line">	k &#x3D; k+1;</span><br><span class="line">	test();</span><br><span class="line">	m &#x3D; 11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/18/JVM%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/3.png" alt="1603639178292"></p>
<p>局部变量表：存储方法执行过程中的所有变量，包括方法中声明的局部变量和形参。</p>
<p>操作数栈：方法中的计算过程都是借助于操作数栈来完成的，将参与计算的数据压入到操作数栈中。</p>
<p>运算符栈：方法运算过程中用到的运算符，全部压入到运算符栈中。</p>
<p>方法返回地址：一个方法调用结束之后要返回到调用它的地方，所以栈帧中要保存能够返回到方法调用处的地址。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java介绍</title>
    <url>/2021/01/18/Java%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="1-Java版本"><a href="#1-Java版本" class="headerlink" title="1.Java版本"></a>1.Java版本</h1><p>Java每隔半年会发布一个新版本，每第四个版本为稳定版本</p>
<p>稳定版 8、12、16</p>
<p>所以我们大部分使用Java8，十分稳定的版本</p>
<p>为什么要配环境变量？</p>
<p>让操作系统能够识别命令，java 可以</p>
<ul>
<li>1、在指定的路径下(C:\Program Files (x86)\Common Files\Oracle\Java\javapath)找可执行文件 java.exe</li>
<li>2、通过系统的环境变量来找到可执行文件</li>
</ul>
<p>第 1 种方式的优先级要高于第 2 种</p>
<p>Java 开发分为 3 个步骤：</p>
<ul>
<li>1、编写 Java 程序，在后缀为 .java 的文件中写代码，这个文件叫做 Java 源文件</li>
<li>2、通过 JVM 编译器将源文件编译为字节码文件，后缀 .class。记住这个是<strong>16 进制</strong>的</li>
<li>3、JVM 对字节码文件进行解释，翻译成操作系统能够识别的机器码（<strong>2 进 制</strong>），进而运行程序。</li>
</ul>
<p>Java 最大的特点就是它的跨平台特性，一次编写，多次运行（运行在不同 的操作系统中）</p>
<p>Windows、Mac、Linux </p>
<a id="more"></a>

<h1 id="2-Java体系"><a href="#2-Java体系" class="headerlink" title="2.Java体系"></a>2.Java体系</h1><p>Java SE、Java EE、Java ME</p>
<p><img src="/2021/01/18/Java%E4%BB%8B%E7%BB%8D/1.png" alt="1610973844232"></p>
<p>Java SE 定义了 Java 的<strong>核心类库</strong>，包含了各种常用的组件，是 Java 开发的 基础。</p>
<p>Java ME 是基于 Java SE 专用于<strong>移动端设备开发</strong>的一套组件，如手机、机顶 盒、车载导航。</p>
<p>Java EE Java Enterprise Edition 是基于 Java SE 扩展出的一套<strong>企业级开发组件</strong>，Java WEB 又是其中最主流、需求量最大的一套组件，包括 Servlet、JSP，是目前 Java 开发的主流方向。</p>
<h1 id="3-JDK"><a href="#3-JDK" class="headerlink" title="3.JDK"></a>3.JDK</h1><p>JRE   JDK</p>
<p>JRE (Java Runtime Environment Java) <strong>运行环境</strong>，包括 JVM 和 Java 基础类 库，一台电脑要运行 Java 程序，就必须安装 JRE，部署项目的服务器中需 要安装 JRE。</p>
<p>JDK Java Development Kit Java <strong>开发工具包</strong>，包括了 JRE 和编译 Java 源文 件的编译器，如果要在一台电脑上开发 Java 程序，就必须安装 JDK。</p>
<ul>
<li>1、编译程序的命令是 javac Test.java</li>
<li>2、运行程序的命令是 java Test</li>
<li>3、Java 对大小写敏感，编写时需要注意</li>
<li>4、文件名一定和类名一致</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud Alibaba-Seata</title>
    <url>/2020/12/21/SpringCloud-Alibaba-Seata/</url>
    <content><![CDATA[<h3 id="Seata处理分布式事务"><a href="#Seata处理分布式事务" class="headerlink" title="Seata处理分布式事务"></a>Seata处理分布式事务</h3><h4 id="一、问题的提出："><a href="#一、问题的提出：" class="headerlink" title="一、问题的提出："></a>一、问题的提出：</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Seata/1.png" alt="01"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Seata/6.png" alt="1602508607972"></p>
<a id="more"></a> 

<h4 id="二、Seata术语："><a href="#二、Seata术语：" class="headerlink" title="二、Seata术语："></a>二、Seata术语：</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Seata/2.png" alt="02"></p>
<h4 id="三、处理过程："><a href="#三、处理过程：" class="headerlink" title="三、处理过程："></a>三、处理过程：</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Seata/3.png" alt="3"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Seata/4.png" alt="4"></p>
<h4 id="四、业务说明"><a href="#四、业务说明" class="headerlink" title="四、业务说明"></a>四、业务说明</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Seata/5.png" alt="5"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud Alibaba-Sentinel</title>
    <url>/2020/12/21/SpringCloud-Alibaba-Sentinel/</url>
    <content><![CDATA[<h3 id="Sentinel实现熔断与限流"><a href="#Sentinel实现熔断与限流" class="headerlink" title="Sentinel实现熔断与限流"></a>Sentinel实现熔断与限流</h3><p>面对云原生微服务的流量控制、熔断降级组件</p>
<p>分布式系统的流量防卫兵，取代了Hystrix</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/1.png" alt="1"></p>
<h4 id="一、运行"><a href="#一、运行" class="headerlink" title="一、运行"></a>一、运行</h4><p>java -jar sentinel-dashboard-1.7.2.jar</p>
<p>访问<a href="http://localhost:8080即可出现可视化界面">http://localhost:8080即可出现可视化界面</a></p>
<p>用户名密码都是sentinel</p>
<a id="more"></a> 

<h4 id="二、初次使用"><a href="#二、初次使用" class="headerlink" title="二、初次使用"></a>二、初次使用</h4><p>主要配好YML文件即可使用</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/2.png" alt="2"></p>
<h4 id="三、Sentinel流控"><a href="#三、Sentinel流控" class="headerlink" title="三、Sentinel流控"></a>三、Sentinel流控</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/3.png" alt="3"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/4.png" alt="4"></p>
<p>预热</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/5.png" alt="5"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/6.png" alt="6"></p>
<p>排队等待</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/7.png" alt="7"></p>
<h4 id="四、Sentinel降级"><a href="#四、Sentinel降级" class="headerlink" title="四、Sentinel降级"></a>四、Sentinel降级</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/8.png" alt="8"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/9.png" alt="9"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/10.png" alt="10"></p>
<p>1.RT（平均响应时间）</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/11.png" alt="11"></p>
<p>2.异常比例</p>
<p>异常超过一定比例就跳闸</p>
<p>3.异常数</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/12.png" alt="12"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/13.png" alt="13"></p>
<h4 id="五、Sentinel热点Key限流"><a href="#五、Sentinel热点Key限流" class="headerlink" title="五、Sentinel热点Key限流"></a>五、Sentinel热点Key限流</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/14.png" alt="14"></p>
<p>@SentunelResource对Sentinel控制台里的热点规则负责，只要服务违背了配置规则，则会调用下面的兜底方法</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/15.png" alt="15"></p>
<p>当索引为0的参数（即p1）单机阈值（一秒点击率）超过了1，则调用兜底方法，而参数p2随便快速点击多少次也没事</p>
<p>特殊情况：</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/16.png" alt="16"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/17.png" alt="17"></p>
<h4 id="六、Sentinel系统规则"><a href="#六、Sentinel系统规则" class="headerlink" title="六、Sentinel系统规则"></a>六、Sentinel系统规则</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/18.png" alt="18"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/19.png" alt="19"></p>
<p>系统全局的保护规则</p>
<h4 id="七、-SentinelResource配置"><a href="#七、-SentinelResource配置" class="headerlink" title="七、@SentinelResource配置"></a>七、@SentinelResource配置</h4><p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/20.png" alt="1602498555342"></p>
<p>对customerBlockHandler进行限流，一旦超出限制，则交由blockHandlerClass里的blockHandler进行兜底</p>
<p>blockHandlerClass里就可以写好几个blockHandler来进行兜底</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/21.png" alt="1602498686863"></p>
<p>即</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/22.png" alt="1602498766708"></p>
<h4 id="八、Sentinel服务熔断"><a href="#八、Sentinel服务熔断" class="headerlink" title="八、Sentinel服务熔断"></a>八、Sentinel服务熔断</h4><p>没有配置：</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/23.png" alt="1602500010113"></p>
<p>只配置fallback，fallback只负责业务java异常：</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/24.png" alt="1602500084574"></p>
<p>只配置blockHandler，只负责sentinal控制台配置违规：</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/25.png" alt="1602500224788"></p>
<p>fallback和blockHandler都配置：</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/26.png" alt="1602500512750"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Sentinel/27.png" alt="1602500639919"></p>
<p>blockHandler大于fallback</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud Alibaba-Nacos</title>
    <url>/2020/12/21/SpringCloud-Alibaba-Nacos/</url>
    <content><![CDATA[<h3 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h3><p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/1.png" alt="01"></p>
<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>一句话，等价于Eureka+Config+Bus</p>
<p>Nacos自带负载均衡，且支持AP和CP‘<a id="more"></a> </p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/2.png" alt="02"></p>
<h4 id="一、服务提供者"><a href="#一、服务提供者" class="headerlink" title="一、服务提供者"></a>一、服务提供者</h4><p>1.nacos/bin/startup.cmd启动nacos</p>
<p>2.写POM</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3.写YML</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置Nacos地址</span></span><br><span class="line">        <span class="comment"># 换成nginx的1111端口，做集群</span></span><br><span class="line"><span class="comment">#        server-addr: 192.168.111.144:1111</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure>

<p>4.启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span>   <span class="comment">//不再需要@EnableEurekaClint等注解</span></span><br></pre></td></tr></table></figure>

<h4 id="二、服务消费者"><a href="#二、服务消费者" class="headerlink" title="二、服务消费者"></a>二、服务消费者</h4><p>1.写POM</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;!--SpringCloud</span> <span class="string">ailibaba</span> <span class="string">nacos</span> <span class="string">--&gt;</span></span><br><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">	<span class="string">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line">	<span class="string">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.写YML</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br></pre></td></tr></table></figure>

<p>3.启动类上写注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure>

<h4 id="三、Nacos服务配置中心"><a href="#三、Nacos服务配置中心" class="headerlink" title="三、Nacos服务配置中心"></a>三、Nacos服务配置中心</h4><p>1.写POM</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos-config--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--nacos-discovery--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.写application.yml和bootstrap.yml</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/3.png" alt="03"></p>
<p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br><span class="line">    <span class="comment">#active: test # 表示测试环境</span></span><br><span class="line">    <span class="comment">#active: info</span></span><br></pre></td></tr></table></figure>

<p>bootstrap.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line"><span class="comment">#        group: DEV_GROUP</span></span><br><span class="line"><span class="comment">#        namespace: 7d8f0f5a-6a53-4785-9686-dd460158e5d4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment"># nacos-config-client-dev.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nacos-config-client-test.yaml   ----&gt; config.info</span></span><br></pre></td></tr></table></figure>

<p>3.在nacos页面添加配置</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/4.png" alt="04"></p>
<p>Data ID需要固定设置</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/5.png" alt="05"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/6.png" alt="06"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/7.png" alt="07"></p>
<p>三大配置：Data ID、Group、NameSpace</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/8.png" alt="08"></p>
<p>4.Data ID：根据spring.profiles.active里的配置进行加载nacos上的配置</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/9.png" alt="09"></p>
<p>5.Group:  默认加载默认组，加载特定组只需要在config下添加一条group即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEV_GROUP</span></span><br></pre></td></tr></table></figure>

<p>即若当前active: info，则会加载DEV_GROUP组下的nacos-config-client-info.yaml</p>
<p>6.NameSpace</p>
<p>默认命名空间即在public下</p>
<p>每个命名空间都有特定的ID</p>
<p>访问命名空间则需要再添加一条yml，并添加要读取配置的命名空间ID</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">TEST_GROUP</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">20ffe5ef-79bb-4048-aaa9-5920c61f5761</span></span><br></pre></td></tr></table></figure>

<p>该配置则去寻找命名空间ID为20ffe5ef-79bb-4048-aaa9-5920c61f5761的空间下，TEST_GROUP的nacos-config-client-dev.yaml（application.yml里是active:dev）</p>
<h4 id="四、Nacos集群和持久化配置（重要）"><a href="#四、Nacos集群和持久化配置（重要）" class="headerlink" title="四、Nacos集群和持久化配置（重要）"></a>四、Nacos集群和持久化配置（重要）</h4><p>1.Nacos集群架构</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/10.png" alt="10"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/11.png" alt="11"></p>
<p>2.Nacos内嵌数据库derby存储配置，所以要进行切换数据库derby到我们本地数据库MySQL</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/12.png" alt="12"></p>
<p>3.</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/13.png" alt="13"></p>
<p>4.服务端访问nginx的端口，nginx里配置好映射，映射到三台nacos上</p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/14.png" alt="14"></p>
<p><img src="/2020/12/21/SpringCloud-Alibaba-Nacos/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud Sleuth分布式请求链路跟踪</title>
    <url>/2020/12/21/SpringCloud-Sleuth%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%B7%E6%B1%82%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/</url>
    <content><![CDATA[<h3 id="SpringCloud-Sleuth分布式请求链路跟踪（链路监控）"><a href="#SpringCloud-Sleuth分布式请求链路跟踪（链路监控）" class="headerlink" title="SpringCloud Sleuth分布式请求链路跟踪（链路监控）"></a>SpringCloud Sleuth分布式请求链路跟踪（链路监控）</h3><p>1.问题</p>
<p><img src="/2020/12/21/SpringCloud-Sleuth%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%B7%E6%B1%82%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/1.png" alt="1600257590874"></p>
<p>2.安装zipkin</p>
<p><img src="/2020/12/21/SpringCloud-Sleuth%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%B7%E6%B1%82%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/2.png" alt="1600265041699"></p>
<p>3.服务端payment8001和客户端order80都导入POM</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--包含了sleuth+zipkin--&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a> 

<p>4.写YML</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">    <span class="attr">sleuth:</span></span><br><span class="line">      <span class="attr">sampler:</span></span><br><span class="line">      <span class="comment">#采样率值介于 0 到 1 之间，1 则表示全部采集</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>5.进行服务请求，则可进入localhost:9411/zipkin查看链路追踪</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud Stream消息驱动</title>
    <url>/2020/12/21/SpringCloud-Stream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h3 id="SpringCloud-Stream消息驱动"><a href="#SpringCloud-Stream消息驱动" class="headerlink" title="SpringCloud Stream消息驱动"></a>SpringCloud Stream消息驱动</h3><p>一句话：屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型</p>
<p>核心：通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离</p>
<p><img src="/2020/12/21/SpringCloud-Stream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/1.png" alt="1600176801553"></p>
<p><img src="/2020/12/21/SpringCloud-Stream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/2.png" alt="1600175467504"></p>
<a id="more"></a> 

<h4 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h4><p>1.写POM文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.建立YML文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">      <span class="attr">stream:</span></span><br><span class="line">        <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">          <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">            <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">              <span class="attr">spring:</span></span><br><span class="line">                <span class="attr">rabbitmq:</span></span><br><span class="line">                  <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.199</span><span class="number">.171</span></span><br><span class="line">                  <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                  <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                  <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">        <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理   主要配置这个Binding</span></span><br><span class="line">          <span class="attr">output:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">            <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">            <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">            <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 客户端进行Eureka注册的配置</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">send-8801.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 访问的路径变为IP地址</span></span><br></pre></td></tr></table></figure>

<p>3.在ServiceImpl书写逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(Source<span class="class">.<span class="keyword">class</span>) //定义消息的推送管道</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MessageProviderImpl</span> <span class="keyword">implements</span> <span class="title">IMessageProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output;  <span class="comment">//消息发送管道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span> </span>&#123;<span class="comment">//往消息中间件发送流水号</span></span><br><span class="line">        String serial = UUID.randomUUID().toString();</span><br><span class="line">        output.send(MessageBuilder.withPayload(serial).build());<span class="comment">//创建一个消息体并发送</span></span><br><span class="line">        System.out.println(<span class="string">"*******serial:"</span>+serial);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h4><p>Controller逻辑书写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableBinding</span>(Sink<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ReceiveMessageListenerController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Message&lt;String&gt; message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"消费者2号,-----&gt;接受到的消息: "</span>+message.getPayload()+<span class="string">"\t  port: "</span>+serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="避免重复消费问题"><a href="#避免重复消费问题" class="headerlink" title="避免重复消费问题"></a>避免重复消费问题</h4><p>服务提供者发布消息，会存在被多个消费者消费的问题。因为默认分组不同，会被重复消费，同一个组才只能其中一个消费</p>
<p><img src="/2020/12/21/SpringCloud-Stream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/3.png" alt="1600178378666"></p>
<p>解决方法：yml里添加一行group: xzsA</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">          <span class="attr">input:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">            <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">            <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为对象json，如果是文本则设置“text/plain”</span></span><br><span class="line">            <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line">            <span class="attr">group:</span> <span class="string">xzsA</span></span><br></pre></td></tr></table></figure>

<p>同时该group属性也对消息持久性十分重要，没有加的消费者端如果没启动，收不到消息</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>GateWay网关</title>
    <url>/2020/12/21/GateWay%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<h3 id="GateWay网关"><a href="#GateWay网关" class="headerlink" title="GateWay网关"></a>GateWay网关</h3><p>核心逻辑：路由转发+执行过滤器链</p>
<p>三大核心概念：路由、断言、过滤</p>
<p>1.引入POM依赖</p>
<p>GateWay不需要引入web、actuator这两个依赖，本身自己带有</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--gateway--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!--eureka-client--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a> 

<p>2.建立YML文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">            <span class="comment">#- After=2020-02-21T15:51:37.485+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="comment">#- Cookie=username,zzyy</span></span><br><span class="line">            <span class="comment">#- Header=X-Request-Id, \d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式</span></span><br></pre></td></tr></table></figure>

<p>运行过程：寻找路由里uri提供的服务地址，然后前往predicates断言下的服务地址路径，相匹配的则需要通过访问9527网关端口才可访问服务。同时可添加许多断言规则，具体搜官网</p>
<p><img src="/2020/12/21/GateWay%E7%BD%91%E5%85%B3/2.png" alt="01"></p>
<p><img src="/2020/12/21/GateWay%E7%BD%91%E5%85%B3/1.png" alt="01"></p>
<p>同时还可通过编码方式进行配置路由映射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GateWayConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder routeLocatorBuilder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();</span><br><span class="line"></span><br><span class="line">        routes.route(<span class="string">"path_route_xzs"</span>,</span><br><span class="line">                r -&gt; r.path(<span class="string">"/guonei"</span>)</span><br><span class="line">                        .uri(<span class="string">"http://news.baidu.com/guonei"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上为配置了一个叫path_route_xzs的路由，当访问localhost:9527/guonei，则跳转到<a href="http://news.baidu.com/guonei" target="_blank" rel="noopener">http://news.baidu.com/guonei</a></p>
<p>3.路由过滤</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogGateWayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>,<span class="title">Ordered</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        log.info(<span class="string">"***********come in MyLogGateWayFilter:  "</span>+<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">"uname"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(uname == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            log.info(<span class="string">"*******用户名为null，非法用户，o(╥﹏╥)o"</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即实现两个接口GlobalFilter,Ordered，直接进行过滤规则编写。以上为访问时需带上一个uname值才可访问</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>Hystrix服务降级、熔断、限流</title>
    <url>/2020/12/21/Hystrix%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E3%80%81%E7%86%94%E6%96%AD%E3%80%81%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><h4 id="一、主要三大概念"><a href="#一、主要三大概念" class="headerlink" title="一、主要三大概念"></a>一、主要三大概念</h4><p><img src="/2020/12/21/Hystrix%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E3%80%81%E7%86%94%E6%96%AD%E3%80%81%E9%99%90%E6%B5%81/1.png" alt="01"></p>
<h4 id="二、服务降级"><a href="#二、服务降级" class="headerlink" title="二、服务降级"></a>二、服务降级</h4><p>1.导入一些依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--hystrix--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line"> 	  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;		</span><br><span class="line">   &lt;!--openfeign--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line"> 	  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;!--eureka client--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line"> 	  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.消费端yml文件多添加一项</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>3.添加注解</p>
<p>消费端添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br></pre></td></tr></table></figure>

<p>服务端添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br></pre></td></tr></table></figure>

<p>4.消费端通过openFeign远程调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PROVIDER-HYSTRIX-PAYMENT"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentHystrixService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/payment/hystrix/ok/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/payment/hystrix/timeout/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.服务端通过注解和兜底方法进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentInfo_TimeOutHandler"</span>,commandProperties = &#123;</span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name=<span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value=<span class="string">"5000"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//int age = 10/0;</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">3000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"线程池:  "</span>+Thread.currentThread().getName()+<span class="string">" id:  "</span>+id+<span class="string">"\t"</span>+<span class="string">"O(∩_∩)O哈哈~"</span>+<span class="string">"  耗时(秒): "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOutHandler</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"线程池:  "</span>+Thread.currentThread().getName()+<span class="string">"  8001系统繁忙或者运行报错，请稍后再试,id:  "</span>+id+<span class="string">"\t"</span>+<span class="string">"o(╥﹏╥)o"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>@HystrixCommand(fallbackMethod = “paymentInfo_TimeOutHandler”,设置了paymentInfo_TimeOutHandler这个兜底方法，一旦服务发生异常或超时，则跳入到该兜底方法</p>
<p>，commandProperties = {<br>            @HystrixProperty(name=”execution.isolation.thread.timeoutInMilliseconds”,value=”5000”)<br>        }  设置了允许超时的秒数</p>
<p>6.消费端通过注解和兜底方法进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/hystrix/timeout/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentTimeOutFallbackMethod"</span>,commandProperties = &#123;</span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name=<span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value=<span class="string">"1500"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        String result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeOutFallbackMethod</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>7.但都得写个兜底方法，导致代码膨胀。因此还可使用全局服务降级fallback</p>
<p>先定义全局兜底方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">payment_Global_FallbackMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再在类上加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DefaultProperties</span>(defaultFallback = <span class="string">"payment_Global_FallbackMethod"</span>)</span><br></pre></td></tr></table></figure>

<p>同时方法上只是@HystrixCommand注解，而不需要指名兜底方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="comment">//@HystrixCommand(fallbackMethod = "paymentTimeOutFallbackMethod",commandProperties = &#123;</span></span><br><span class="line">           <span class="comment">//@HystrixProperty(name="execution.isolation.thread.timeoutInMilliseconds",value="1500")</span></span><br><span class="line"><span class="comment">//   &#125;)</span></span><br></pre></td></tr></table></figure>

<p>8.设置更全面的通用服务降级类，实现需要进行服务降级的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentHystrixService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-----PaymentFallbackService fall back-paymentInfo_OK ,o(╥﹏╥)o"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-----PaymentFallbackService fall back-paymentInfo_TimeOut ,o(╥﹏╥)o"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PROVIDER-HYSTRIX-PAYMENT"</span> ,fallback = PaymentFallbackService<span class="class">.<span class="keyword">class</span>)<span class="title">public</span> <span class="title">interface</span> <span class="title">PaymentHystrixService</span></span></span><br></pre></td></tr></table></figure>

<p>注解添加fallback属性指向了PaymentFallbackService这个服务降级类</p>
<h4 id="三、服务熔断"><a href="#三、服务熔断" class="headerlink" title="三、服务熔断"></a>三、服务熔断</h4><p>当一些服务调用失败达到一个阙值时，会对服务进行熔断。当检测到该服务正常时，能够恢复调用链路。</p>
<p>熔断机制注解是@HystrixCommand</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentCircuitBreaker_fallback"</span>,commandProperties = &#123;</span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.enabled"</span>,value = <span class="string">"true"</span>),<span class="comment">// 是否开启断路器</span></span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.requestVolumeThreshold"</span>,value = <span class="string">"10"</span>),<span class="comment">// 请求次数</span></span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.sleepWindowInMilliseconds"</span>,value = <span class="string">"10000"</span>), <span class="comment">// 时间窗口期</span></span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.errorThresholdPercentage"</span>,value = <span class="string">"60"</span>),<span class="comment">// 失败率达到多少后跳闸</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>表示在十秒钟之内发送十次请求，如果失败率达到60%以上就跳闸</p>
<p><img src="/2020/12/21/Hystrix%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E3%80%81%E7%86%94%E6%96%AD%E3%80%81%E9%99%90%E6%B5%81/2.png" alt="01"></p>
<p>熔断时候直接调用fallbackMethod</p>
<h4 id="四、服务限流"><a href="#四、服务限流" class="headerlink" title="四、服务限流"></a>四、服务限流</h4><h4 id="五、Hystrix-Dashboard服务监控"><a href="#五、Hystrix-Dashboard服务监控" class="headerlink" title="五、Hystrix Dashboard服务监控"></a>五、Hystrix Dashboard服务监控</h4><p>1.添加依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> 其中需要监控的服务都要加上这个actuator依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.主启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br></pre></td></tr></table></figure>

<p>3.在可视化页面上填写监控地址<a href="http://localhost:8001/hystrix.stream即可进行监控" target="_blank" rel="noopener">http://localhost:8001/hystrix.stream即可进行监控</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>OpenFeign服务接口调用</title>
    <url>/2020/12/21/OpenFeign%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h3 id="OpenFeign服务接口调用"><a href="#OpenFeign服务接口调用" class="headerlink" title="OpenFeign服务接口调用"></a>OpenFeign服务接口调用</h3><p>1.引入POM文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--openfeign--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;!--eureka client--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">   	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">  	    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a> 

<p>2.建立YML文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure>

<p>3.加注释</p>
<p>主启动类上加注释@EnableFeignClients </p>
<p>业务逻辑类上加注释@FeignClient(value = “CLOUD-PAYMENT-SERVICE（调用的服务名）”) @Component</p>
<p>然后直接copy自己要调用的服务方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentFeignService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/21/OpenFeign%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/1.png" alt="01"></p>
<p>4.超时控制</p>
<p>默认OpenFeign只等待一秒钟，可通过yml文件进行设置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置feign客户端超时时间(OpenFeign默认支持ribbon)</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="comment">#指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="comment">#指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>5.日志增强</p>
<p>先添加配置类，直接为FULL最全日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再在yml文件里开启</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment"># feign日志以什么级别监控哪个接口</span></span><br><span class="line">    <span class="attr">com.xzs.springcloud.service.PaymentFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>Ribbon服务调用</title>
    <url>/2020/12/21/Ribbon%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Ribbon服务调用"><a href="#Ribbon服务调用" class="headerlink" title="Ribbon服务调用"></a>Ribbon服务调用</h3><p>一句话，主要是通过RestTemplate+负载均衡实现</p>
<p>更换负载均衡算法：在com.xzs下添加一个myrule的包，同时创建一个rule类修改负载均衡算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();<span class="comment">//定义为随机算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时需要在启动类上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>,configuration= MySelfRule<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>Eureka服务注册、集群实现</title>
    <url>/2020/12/21/Eureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E3%80%81%E9%9B%86%E7%BE%A4%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="Eureka服务注册、集群实现"><a href="#Eureka服务注册、集群实现" class="headerlink" title="Eureka服务注册、集群实现"></a>Eureka服务注册、集群实现</h3><h4 id="一、创建Eureka服务端"><a href="#一、创建Eureka服务端" class="headerlink" title="一、创建Eureka服务端"></a>一、创建Eureka服务端</h4><p>1.引入eureka服务端依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--eureka-server--&gt;</span><br><span class="line">    &lt;dependency&gt;    </span><br><span class="line">       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    </span><br><span class="line">       &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a> 

<p>2.编写yml文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span>     <span class="comment">#false表示不向注册中心注册自己。</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>     <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">    <span class="comment">#集群指向其它eureka</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka/</span></span><br><span class="line">    <span class="comment">#单机就是7001自己</span></span><br><span class="line"><span class="comment">#     defaultZone: http://eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure>

<p>3.添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br></pre></td></tr></table></figure>

<h4 id="二、创建Eureka客户端"><a href="#二、创建Eureka客户端" class="headerlink" title="二、创建Eureka客户端"></a>二、创建Eureka客户端</h4><p>1.引入eureka客户端依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--eureka-client--&gt;</span><br><span class="line">    &lt;dependency&gt;    </span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    </span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.编写yml文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span>            <span class="comment"># 当前数据源操作类型</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span>              <span class="comment"># mysql驱动包</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xzs666</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer默认为true。</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#单机版</span></span><br><span class="line"><span class="comment">#      defaultZone: http://localhost:7001/eureka</span></span><br><span class="line">      <span class="comment"># 集群版</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.xzs.springcloud.entities</span>    <span class="comment"># 所有Entity别名类所在包</span></span><br></pre></td></tr></table></figure>

<p>3.添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br></pre></td></tr></table></figure>

<h4 id="三、通过RestTemplate调用服务"><a href="#三、通过RestTemplate调用服务" class="headerlink" title="三、通过RestTemplate调用服务"></a>三、通过RestTemplate调用服务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span>  进行负载均衡的注解</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>Springboot整合RabbitMQ</title>
    <url>/2020/12/21/Springboot%E6%95%B4%E5%90%88RabbitMQ/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p> 他是一种异步通信方式，消息生产者在生产消息后，把消息保存到消息队列中，直到消息消费者来取走他。消息的生产者和消费者不需要同时和消息队列交互 </p>
<h1 id="2-启动"><a href="#2-启动" class="headerlink" title="2.启动"></a>2.启动</h1><p>使用docker快速启动rabbitmq</p>
<p>docker run -d  -P rabbitmq:3-management </p>
<p>docker run -d –name xzs-rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3-management </p>
<p>15672是管理端接口  5672是真正通信接口    -P随机映射到个接口  </p>
<p>5672映射到32771为通信接口 </p>
<p>15672映射到32769为管理端接口 </p>
<a id="more"></a> 

<h1 id="3-Springboot整合RabbitMQ"><a href="#3-Springboot整合RabbitMQ" class="headerlink" title="3.Springboot整合RabbitMQ"></a>3.Springboot整合RabbitMQ</h1><p>1.导入Web和RabbitMQ依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>2.配置RabbitMQ信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">192.168.199.171</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">32771</span></span><br></pre></td></tr></table></figure>

<h2 id="一、Direct"><a href="#一、Direct" class="headerlink" title="一、Direct"></a>一、Direct</h2><p>直接交换模式</p>
<p>配置DirectConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitDirectConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String DIRECTNAME = <span class="string">"xzs-direct"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">queue</span><span class="params">()</span></span>&#123;<span class="comment">//定义消息队列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"hello.xzs"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DirectExchange <span class="title">directExchange</span><span class="params">()</span></span>&#123;<span class="comment">//定义消息转换器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(DIRECTNAME,<span class="keyword">true</span>,<span class="keyword">true</span>);<span class="comment">//第二个参数：重启后是否有效，第三个参数：长期没有使用是否有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">binding</span><span class="params">()</span></span>&#123;<span class="comment">//把上面Queue和Exchange绑定到一起</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue()).to(directExchange()).with(<span class="string">"direct"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Exchange</p>
<p>再配置一个消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"hello.xzs"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"handler1 ----&gt;"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后使用RabbitTemplate进行发送消息即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringbootRabbitmqApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"hello.xzs"</span>,<span class="string">"hahahaha!xzs"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功接收到消息！</p>
<p><img src="/2020/12/21/Springboot%E6%95%B4%E5%90%88RabbitMQ/1.png" alt="01"></p>
<h2 id="二、Fanout"><a href="#二、Fanout" class="headerlink" title="二、Fanout"></a>二、Fanout</h2><p>所有到达Exchange的消息都转发到所有绑定到该Exchange的Queue</p>
<p>谁跟这个Exchange绑定了谁就能拿到消息</p>
<p>RabbitFanoutConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitFanoutConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String FANOUTNAME = <span class="string">"xzs-fanout"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">queue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.one"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">queue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.two"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(FANOUTNAME,<span class="keyword">true</span>,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">binding1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue1()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">binding2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue2()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FanoutReceiver消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"fanout.one"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"handler1 -------&gt;"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"fanout.two"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"handler2 -------&gt;"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用RabbitTemplate进行发送消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(RabbitFanoutConfig.FANOUTNAME,<span class="keyword">null</span>,<span class="string">"hello fanout！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和Exchange绑定的两个队列都拿到了消息。此时无需绑定routingKey</p>
<p><img src="/2020/12/21/Springboot%E6%95%B4%E5%90%88RabbitMQ/2.png" alt="02"></p>
<h2 id="三、Topic"><a href="#三、Topic" class="headerlink" title="三、Topic"></a>三、Topic</h2><p>Queue通过routingKey绑定到TopicExchange上，当消息到达TopicExchange时，TopicExchange会根据消息的routingKey把消息路由到一个或多个Queue上</p>
<p>RabbitTopicConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitTopicConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String TOPICNAME = <span class="string">"xzs-topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">xiaomi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"xiaomi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">huawei</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"huawei"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">phone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"phone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">TopicExchange <span class="title">topicExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(TOPICNAME,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">xiaomiBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(xiaomi()).to(topicExchange()).with(<span class="string">"xiaomi.#"</span>);<span class="comment">//以小米开头的消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">huaweiBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(huawei()).to(topicExchange()).with(<span class="string">"huawei.#"</span>);<span class="comment">//以小米开头的消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">phoneBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(phone()).to(topicExchange()).with(<span class="string">"#.phone.#"</span>);<span class="comment">//以小米开头的消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TopicReceiver消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"xiaomi"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TopicReceiver  handler1 -------&gt;"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"huawei"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TopicReceiver  handler2 -------&gt;"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"phone"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler3</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TopicReceiver  handler3 -------&gt;"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用RabbitTemplate进行发送消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Testvoid</span> test2() &#123;    rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME,<span class="string">"xiaomi.news"</span>,<span class="string">"小米新闻"</span>);    rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME,<span class="string">"vivo.phone"</span>,<span class="string">"vivo手机"</span>);    rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME,<span class="string">"huawei.phone"</span>,<span class="string">"华为手机"</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>根据发送消息的routingKey进行消息路由转发</p>
<p>小米新闻就路由给了xiaomi队列</p>
<p>vivo手机就路由给了phone队列</p>
<p>华为手机就路由给了huawei队列和phone队列</p>
<p><img src="/2020/12/21/Springboot%E6%95%B4%E5%90%88RabbitMQ/3.png" alt="03"></p>
<p><img src="/2020/12/21/Springboot%E6%95%B4%E5%90%88RabbitMQ/4.png" alt="04"></p>
<h2 id="四、Header"><a href="#四、Header" class="headerlink" title="四、Header"></a>四、Header</h2><p> 消息的Header中只要有一个Header匹配上map的key-value，就把这个消息路由到对应的Queue上去 </p>
<p>RabbitHeaderConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitHeaderConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADERNAME = <span class="string">"xzs-header"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">queueName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"name-queue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">queueAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"age-queue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">HeadersExchange <span class="title">headersExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeadersExchange(HEADERNAME, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"name"</span>, <span class="string">"xzs"</span>);</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueName()).to(headersExchange()).whereAny(map).match();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueAge()).to(headersExchange()).where(<span class="string">"age"</span>).exists();<span class="comment">//只要你有age这个字段我就路由到age-queue上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeaderReceiver：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"name-queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler1</span><span class="params">(<span class="keyword">byte</span>[] msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HeaderReceiver:handler1 --------&gt;"</span> + <span class="keyword">new</span> String(msg, <span class="number">0</span>, msg.length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"age-queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler2</span><span class="params">(<span class="keyword">byte</span>[] msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HeaderReceiver:handler2 --------&gt;"</span> + <span class="keyword">new</span> String(msg, <span class="number">0</span>, msg.length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用RabbitTemplate进行发送消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Message nameMsg = MessageBuilder.withBody(<span class="string">"hello Header !"</span>.getBytes()).setHeader(<span class="string">"name"</span>,<span class="string">"xzs"</span>).build();</span><br><span class="line">    Message ageMsg = MessageBuilder.withBody(<span class="string">"hello Header99 !"</span>.getBytes()).setHeader(<span class="string">"age"</span>,<span class="string">"99"</span>).build();</span><br><span class="line">    rabbitTemplate.send(RabbitHeaderConfig.HEADERNAME, <span class="keyword">null</span>, ageMsg);</span><br><span class="line">    rabbitTemplate.send(RabbitHeaderConfig.HEADERNAME, <span class="keyword">null</span>, nameMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各自路由到各自的消息队列中去</p>
<p><img src="/2020/12/21/Springboot%E6%95%B4%E5%90%88RabbitMQ/5.png" alt="05"></p>
]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
  </entry>
  <entry>
    <title>SpringSecurity动态权限配置</title>
    <url>/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="动态权限配置"><a href="#动态权限配置" class="headerlink" title="动态权限配置"></a>动态权限配置</h1><p>之前我们各个用户赋予各个权限，实际中显然不行，我们需要通过后台管理动态去配置用户权限，我们可以修改用户访问权限，也可以修改用户能访问哪些资源</p>
<p>所以我们把权限这套东西放在数据库里，然后通过数据库里数据的关系来描述用户拥有的权限</p>
<p>创建各类表：</p>
<p>menu资源表<img src="/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/1.png" alt="1604396717980"></p>
<p>role角色表<img src="/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/2.png" alt="1604396749741"></p>
<p>user用户表<img src="/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/3.png" alt="1604396775805"></p>
<p>和两个关联表</p>
<a id="more"></a> 

<p>我们就可以通过用户查到用户所拥有的角色，才通过角色查询到所能访问的资源（相当于把9.基于数据库的认证里的访问权限拦截设置也放数据库里了）</p>
<p>原本我们这个路径是自己写死的</p>
<p><img src="/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/4.png" alt="1604398080044"></p>
<p>现在我们就需要查询数据库来得到了</p>
<p>如何动态地从数据库加载呢？我们就需要定义几个东西</p>
<p>定义一个MyFilter实现FilterInvocationSecurityMetadataSource</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">FilterInvocationSecurityMetadataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来匹配路径</span></span><br><span class="line">    AntPathMatcher pathMatcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MenuService menuService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据你的请求地址分析出来需要哪些角色，匹配上就返回需要的角色，没匹配上返回个默认值</span></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//Collection返回你需要的角色</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAttributes</span><span class="params">(Object o)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">//获取请求地址</span></span><br><span class="line">        String requestUrl = ((FilterInvocation) o).getRequestUrl();</span><br><span class="line">        <span class="comment">//菜单里面的pattern就定义了路径规则</span></span><br><span class="line">        List&lt;Menu&gt; allMenus = menuService.getAllMenus();</span><br><span class="line">        <span class="keyword">for</span>(Menu menu : allMenus)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pathMatcher.match(menu.getPattern(),requestUrl))&#123;<span class="comment">//如果你请求的路径和pattern里路径匹配上了</span></span><br><span class="line">                List&lt;Role&gt; roles = menu.getRoles();   <span class="comment">//拿出各个角色放入数组</span></span><br><span class="line">                String[] roleStr = <span class="keyword">new</span> String[roles.size()];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i &lt; roles.size(); i++)&#123;</span><br><span class="line">                    roleStr[i] = roles.get(i).getName();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> SecurityConfig.createList(roleStr);<span class="comment">//然后进到MyAccessDecisionManager进行角色的比较</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果路径都匹配不上，给他返回一个默认资源</span></span><br><span class="line">        <span class="keyword">return</span> SecurityConfig.createList(<span class="string">"ROLE_login"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAllConfigAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sql查询</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAllMenus"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">       select m.*,r.`id` as rid,r.`name` as rname,r.`nameZh` as rnameZh from menu m left join menu_role mr on m.`id`=mr.`mid` left join role r on mr.`rid`=r.`id`</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.xzs.springsecurity3.bean.Menu"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"pattern"</span> <span class="attr">column</span>=<span class="string">"pattern"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"roles"</span> <span class="attr">ofType</span>=<span class="string">"com.xzs.springsecurity3.bean.Role"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"rid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"rname"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"rnameZh"</span> <span class="attr">property</span>=<span class="string">"nameZh"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/5.png" alt="1604398678526"></p>
<p>此时我们已经知道了请求路径需要哪些角色，然后我又有哪些角色，进行比较，比较成功该请求就往下走，如果你需要的角色我没有，那这就是一个非法请求</p>
<p>再定义一个MyAccessDecisionManager实现AccessDecisionManager接口，进行角色比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccessDecisionManager</span> <span class="keyword">implements</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication<span class="comment">/*保存了当前登录用户的信息，知道了我有哪些角色*/</span>, Object o<span class="comment">/*用来获取当前请求对象*/</span>, Collection&lt;ConfigAttribute&gt; collection)</span><span class="comment">/*需要哪些角色的集合*/</span> <span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ConfigAttribute attribute : collection) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"ROLE_login"</span>.equals(attribute.getAttribute()))&#123;</span><br><span class="line">                <span class="keyword">if</span> (authentication <span class="keyword">instanceof</span> AnonymousAuthenticationToken) &#123;<span class="comment">//如果你是个匿名用户，就是未登录</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(<span class="string">"非法请求!"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br><span class="line">            <span class="keyword">for</span> (GrantedAuthority authority : authorities) &#123;<span class="comment">//如果需要的角色集合里有一个我有的，则成功</span></span><br><span class="line">                <span class="keyword">if</span> (authority.getAuthority().equals(attribute.getAttribute())) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AccessDeniedException(<span class="string">"非法请求!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute configAttribute)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后再在SecurityConfig里进行注入和配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   MyFilter myFilter;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   MyAccessDecisionManager myAccessDecisionManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       http.authorizeRequests()</span><br><span class="line">               .withObjectPostProcessor(<span class="keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="function">O <span class="title">postProcess</span><span class="params">(O o)</span> </span>&#123;</span><br><span class="line">                       o.setAccessDecisionManager(myAccessDecisionManager);</span><br><span class="line">                       o.setSecurityMetadataSource(myFilter);</span><br><span class="line">                       <span class="keyword">return</span> o;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">               .and()</span><br><span class="line">               .formLogin()</span><br><span class="line">               .permitAll()</span><br><span class="line">               .and()</span><br><span class="line">               .csrf().disable();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>此时进行接口访问，使用user对象登录，只拥有访问/user的权限</p>
<p><img src="/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/6.png" alt="1604403843728"></p>
<p>访问其他接口即报错</p>
<p><img src="/2020/12/21/SpringSecurity%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/7.png" alt="1604403863318"></p>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
  </entry>
  <entry>
    <title>SpringSecurity基于数据库的认证</title>
    <url>/2020/12/21/SpringSecurity%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h1 id="1-基于数据库的认证"><a href="#1-基于数据库的认证" class="headerlink" title="1.基于数据库的认证"></a>1.基于数据库的认证</h1><p> 之前我们都是自己配置用户名、密码和权限，现在我们要从数据库中读取这些数据</p>
<p>过程：</p>
<p>如果我们需要自己从数据库加载用户，在定义用户时要实现UserDetail , 再实现接口里的方法 </p>
<p> UserDetail相当于一个规范，我们每个人定义的User属性名可能不一样，所以通过重写方法返回我们自己定义的用户名、密码等，UserDetail则可知道 </p>
<p>首先Bean里定义的User类需要继承UserDetail</p>
<a id="more"></a> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Boolean enabled;</span><br><span class="line">    <span class="keyword">private</span> Boolean locked;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//账户是否没有过期</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">////账户是否没有被锁定</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !locked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//密码是否没有过期</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户是否可用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enabled;   <span class="comment">//返回我们自己定义的字段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回用户的所有角色</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Role role : roles) &#123;<span class="comment">//SpringSecurity有一个规则，角色要以ROLE_开头，数据库如果不是这样我们就得手动加上</span></span><br><span class="line">            authorities.add(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">"ROLE_"</span>+role.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">getRoles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoles</span><span class="params">(List&lt;Role&gt; roles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roles = roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(Boolean enabled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocked</span><span class="params">(Boolean locked)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.locked = locked;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次UserService也要实现UserDetailsService，再写mapper去数据库查询数据即可</p>
<p>UserService记得要注入SecurityConfig里的auth</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据用户名去查询用户</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        User user = userMapper.loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">"用户不存在!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        user.setRoles(userMapper.getUserRolesById(user.getId()));</span><br><span class="line">        <span class="comment">//登陆成功后，把user返回，至于他填的用户名和密码对不对由SpringSecurity自己去比较</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后书写SecurityConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将userService注入auth</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/dba/**"</span>).hasRole(<span class="string">"dba"</span>)</span><br><span class="line">                .antMatchers(<span class="string">"/admin/**"</span>).hasRole(<span class="string">"admin"</span>)</span><br><span class="line">                .antMatchers(<span class="string">"/user/**"</span>).hasRole(<span class="string">"user"</span>)</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问各个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/dba/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dba</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello dba!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/admin/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello admin!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello user!"</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/21/SpringSecurity%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%A4%E8%AF%81/1.png" alt="1604395766607"></p>
<p>root具有dba和admin权限，admin有admin权限，user有user权限</p>
<p>从数据库中读取用户账户、密码，然后使用root登录</p>
<p> ![img](file:///C:\Users\ASUS\Documents\Tencent Files\1017477355\Image\C2C\OQA[4QB3E$M59T1<code>J@</code>{SZ4.png) </p>
<p>从而root只能访问/dba/hello、/admin/hello接口</p>
<p><img src="/2020/12/21/SpringSecurity%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%A4%E8%AF%81/2.png" alt="1604395976580"></p>
<p><img src="/2020/12/21/SpringSecurity%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%A4%E8%AF%81/3.png" alt="1604395988543"></p>
<p><img src="/2020/12/21/SpringSecurity%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%A4%E8%AF%81/4.png" alt="1604396003816"></p>
<h1 id="2-角色继承"><a href="#2-角色继承" class="headerlink" title="2.角色继承"></a>2.角色继承</h1><p>加上此Bean，dba就有了dab、admin、user权限，admin也有admin、user，user有user</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function">RoleHierarchy <span class="title">roleHierarchy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       RoleHierarchyImpl roleHierarchy = <span class="keyword">new</span> RoleHierarchyImpl();</span><br><span class="line">       String hierarchy = <span class="string">"ROLE_dba &gt; ROLE_admin \n ROLE_admin &gt; ROLE_user"</span>;</span><br><span class="line">       roleHierarchy.setHierarchy(hierarchy);</span><br><span class="line">       <span class="keyword">return</span> roleHierarchy;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>再次用root登录去访问/user接口</p>
<p><img src="/2020/12/21/SpringSecurity%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%A4%E8%AF%81/5.png" alt="1604396311487"></p>
<p>成功访问得到！</p>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
  </entry>
  <entry>
    <title>SpringSecurity配置</title>
    <url>/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="1-HttpSecurity拦截配置"><a href="#1-HttpSecurity拦截配置" class="headerlink" title="1.HttpSecurity拦截配置"></a>1.HttpSecurity拦截配置</h1><p>我们需要配置不同的拦截规则对不同的url进行拦截</p>
<p>1.重写方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       http.authorizeRequests()  <span class="comment">//开启配置</span></span><br><span class="line">               .antMatchers(<span class="string">"/admin/**"</span>).hasRole(<span class="string">"admin"</span>)<span class="comment">//ant风格的匹配符，路径符合这个规则要有哪些角色权限</span></span><br><span class="line">               .antMatchers(<span class="string">"/user/**"</span>).hasAnyRole(<span class="string">"admin"</span>,<span class="string">"user"</span>)<span class="comment">//拥有多个角色中的一个就能访问</span></span><br><span class="line">           <span class="comment">//  .antMatchers("/user/**").access("hasAnyRole('admin','user')")  和上面一样</span></span><br><span class="line">               .anyRequest().authenticated() <span class="comment">//剩下的其他请求都是authenticated，登录之后就能访问</span></span><br><span class="line">               .and()</span><br><span class="line">               .formLogin()  <span class="comment">//登录表单  主要是易于postman发送请求</span></span><br><span class="line">               .loginProcessingUrl(<span class="string">"/doLogin"</span>) <span class="comment">//处理登录的URL postman访问这个接口即可登录</span></span><br><span class="line">               .permitAll()  <span class="comment">//跟登录相关的这些接口就能访问</span></span><br><span class="line">               .and()</span><br><span class="line">               .csrf().disable();  <span class="comment">//spring security自带csrf攻击 关闭csrf攻击就能用postman</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>访问/admin的请求都需要有admin权限</p>
<p>访问/user的请求都需要有user权限</p>
<a id="more"></a> 

<h1 id="2-登陆表单配置"><a href="#2-登陆表单配置" class="headerlink" title="2.登陆表单配置"></a>2.登陆表单配置</h1><p>访问一个接口，spring security会默认给你跳到/login登录页面去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/admin/**"</span>).hasRole(<span class="string">"admin"</span>)</span><br><span class="line"><span class="comment">//                .antMatchers("/user/**").hasAnyRole("admin","user")</span></span><br><span class="line">                .antMatchers(<span class="string">"/user/**"</span>).access(<span class="string">"hasAnyRole('admin','user')"</span>)</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginProcessingUrl(<span class="string">"/doLogin"</span>)</span><br><span class="line">                .loginPage(<span class="string">"/login"</span>)  <span class="comment">//配置自己的登录页面</span></span><br><span class="line">                .usernameParameter(<span class="string">"uname"</span>)  <span class="comment">//postman访问的参数名</span></span><br><span class="line">                .passwordParameter(<span class="string">"pwd"</span>)</span><br><span class="line">            	.successHandler(<span class="keyword">new</span> AuthenticationSuccessHandler() &#123; <span class="comment">//登录成功后的处理</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);<span class="comment">//返回json</span></span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                        map.put(<span class="string">"status"</span>,<span class="number">200</span>);</span><br><span class="line">                        map.put(<span class="string">"msg"</span>,authentication.getPrincipal());<span class="comment">//getPrincipal()保存了刚刚登录成功的用户对象</span></span><br><span class="line">                        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(map));<span class="comment">//把map搞成一个json字符串写出去</span></span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            	.failureHandler(<span class="keyword">new</span> AuthenticationFailureHandler()&#123; <span class="comment">//登录失败的处理</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;<span class="comment">//这时候就没有登录成功的对象authentication了，而是一个异常，通过异常我们就能知道因为什么而登录失败</span></span><br><span class="line">                        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                        map.put(<span class="string">"status"</span>,<span class="number">401</span>);</span><br><span class="line">                        <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> LockedException)&#123;</span><br><span class="line">                            map.put(<span class="string">"msg"</span>,<span class="string">"账户被锁定，登录失败"</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> BadCredentialsException)&#123;</span><br><span class="line">                            map.put(<span class="string">"msg"</span>,<span class="string">"用户名或密码输入错误，登录失败"</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> DisabledException)&#123;</span><br><span class="line">                            map.put(<span class="string">"msg"</span>,<span class="string">"账户被禁用，登录失败"</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> AccountExpiredException)&#123;</span><br><span class="line">                            map.put(<span class="string">"msg"</span>,<span class="string">"账户过期，登录失败"</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> CredentialsExpiredException)&#123;</span><br><span class="line">                            map.put(<span class="string">"msg"</span>,<span class="string">"密码过期，登录失败"</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            map.put(<span class="string">"msg"</span>,<span class="string">"登录失败"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(map));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/1.png" alt="1604327277062"></p>
<p>访问后跳转到/login页面，需要进行登录</p>
<p>这时候使用Postman访问/doLogin接口进行登录</p>
<p><img src="/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/2.png" alt="1604326438237"></p>
<p>此时登录成功，再进行访问/admin/hello接口，访问成功</p>
<p><img src="/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/3.png" alt="1604327236568"></p>
<h1 id="3-注销登陆配置"><a href="#3-注销登陆配置" class="headerlink" title="3.注销登陆配置"></a>3.注销登陆配置</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .logout()</span><br><span class="line">            .logoutUrl(<span class="string">"/logout"</span>)</span><br><span class="line">            .logoutSuccessHandler(<span class="keyword">new</span> LogoutSuccessHandler() &#123;<span class="comment">//注销成功的回调</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLogoutSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">"status"</span>,<span class="number">200</span>);</span><br><span class="line">                    map.put(<span class="string">"msg"</span>,<span class="string">"注销登录成功！"</span>);</span><br><span class="line">                    out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/4.png" alt="1604327611247"></p>
<p>此时为登录状态，访问/logout进行登录注销</p>
<p><img src="/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/5.png" alt="1604327662920"></p>
<p>再次访问/admin/hello，则需要再次登录</p>
<p><img src="/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/6.png" alt="1604327699659"></p>
<h1 id="4-多个HttpSecurity配置"><a href="#4-多个HttpSecurity配置" class="headerlink" title="4.多个HttpSecurity配置"></a>4.多个HttpSecurity配置</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多个HttpSecurity不再需要 extends WebSecurityConfigurerAdapter 只需注入configure方法</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiHttpSecurityConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">"xzs"</span>).password(<span class="string">"111"</span>).roles(<span class="string">"admin"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">"xxzs"</span>).password(<span class="string">"222"</span>).roles(<span class="string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个静态内部类</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="comment">//有多个HttpSecurity，就涉及到优先级问题</span></span><br><span class="line">    <span class="meta">@Order</span>(<span class="number">1</span>) <span class="comment">//数字越小优先级越大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 这种"/admin/**"格式的路径都要有admin权限</span></span><br><span class="line">            http.antMatcher(<span class="string">"/admin/**"</span>).authorizeRequests().anyRequest().hasAnyRole(<span class="string">"admin"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先跟上面匹配，匹配不上才找到这里</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin()</span><br><span class="line">                    .loginProcessingUrl(<span class="string">"/doLogin"</span>)</span><br><span class="line">                    .permitAll()</span><br><span class="line">                    .and()</span><br><span class="line">                    .csrf().disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-密码加密"><a href="#5-密码加密" class="headerlink" title="5.密码加密"></a>5.密码加密</h1><p><img src="/2020/12/21/SpringSecurity%E9%85%8D%E7%BD%AE/7.png" alt="1604330708908"></p>
<p>使用BCryptPasswordEncoder进行加密，生成一些加密密码，将这些加密密码进行替换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">"xzs"</span>).password(<span class="string">"$2a$10$GPZYsEzEes4vFndEhofmneACUmfFvD/KvgblGVL.I9YdzGmMdS6PC"</span>).roles(<span class="string">"admin"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">"xxzs"</span>).password(<span class="string">"$2a$10$Kr.ZQiC/ZGoQ.5Behtuh2u.SJNladI8Mf5XG6Q4O/2ilhuOWUNkTu"</span>).roles(<span class="string">"user"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这时登录仍是用123，但密码已经被加密加盐了</p>
<h1 id="6-方法安全"><a href="#6-方法安全" class="headerlink" title="6.方法安全"></a>6.方法安全</h1><p>在方法上添加注解确保方法的安全</p>
<p>先在配置类上加@EnableGlobalMethodSecurity注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>,securedEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiHttpSecurityConfig</span></span>&#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Service方法上添加注解</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodService</span> </span>&#123;</span><br><span class="line">	<span class="comment">//@PreAuthorize方法调用之后进行校验</span></span><br><span class="line">    <span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('admin')"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello admin!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Secured</span>(<span class="string">"ROLE_user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello user!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreAuthorize</span>(<span class="string">"hasAnyRole('admin','user')"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
  </entry>
  <entry>
    <title>SpringSecurity初体验</title>
    <url>/2020/12/21/SpringSecurity%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="1-初体验"><a href="#1-初体验" class="headerlink" title="1.初体验"></a>1.初体验</h1><p>1.引入spring-security依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.项目啥都不用做，引入了上面的依赖即保护了整个项目的接口</p>
<p>书写Controller接口，进行访问</p>
<p><img src="/2020/12/21/SpringSecurity%E5%88%9D%E4%BD%93%E9%AA%8C/1.png" alt="1604052679784"></p>
<a id="more"></a> 

<p>发现需要进行登陆，而这时项目启动时会随机生成一个字符串，就是登陆密码，登录名是user</p>
<p><img src="/2020/12/21/SpringSecurity%E5%88%9D%E4%BD%93%E9%AA%8C/2.png" alt="1604052719069"></p>
<p>登陆成功后即可访问到接口</p>
<p><img src="/2020/12/21/SpringSecurity%E5%88%9D%E4%BD%93%E9%AA%8C/3.png" alt="1604052770236"></p>
<h1 id="2-手工配置用户名密码"><a href="#2-手工配置用户名密码" class="headerlink" title="2.手工配置用户名密码"></a>2.手工配置用户名密码</h1><p>1.第一种配置方式</p>
<p><img src="/2020/12/21/SpringSecurity%E5%88%9D%E4%BD%93%E9%AA%8C/4.png" alt="1604053020964"></p>
<p>2.第二种配置方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//SpringSecurity登录需要进行密码加密</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NoOpPasswordEncoder.getInstance(); <span class="comment">//已过时</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//重写该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication() <span class="comment">//基于内存的认证</span></span><br><span class="line">                .withUser(<span class="string">"xzs"</span>).password(<span class="string">"123"</span>).roles(<span class="string">"admin"</span>) <span class="comment">//设置用户、密码、权限</span></span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">"xxxzs"</span>).password(<span class="string">"456"</span>).roles(<span class="string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
  </entry>
  <entry>
    <title>Vuex知识点</title>
    <url>/2020/12/20/Vuex%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="Vuex：状态管理管家"><a href="#Vuex：状态管理管家" class="headerlink" title="Vuex：状态管理管家"></a>Vuex：状态管理管家</h3><p> state：        存放属性  已经在state里定义的属性才有放进响应式系统 通过Vue.set() Vue.delete()是响应式的<br>         getters    ：属性需要经过变化使用该属性 类似计算属性                                                                                                                                              定义的方法可有三个参数（state，getters，rootState）<br>        mutations：存放同步方法                                                                                                                                                                        通过mutations更新state里的属性值：this.$store.commit(‘mutations里定义的方法名’)<br>                              要多传个参数过去直接this.$store.commit(‘方法名’,参数)<br>        action：       类似于mutations，用来替代mutations进行异步操作, this.$store.dispatch(‘action里定义的方法名’)<br>                              context上下文对象  可调用commit那些 但只能在本块区域<br>        modules：  可将state分割成模块，每个模块都有state、mutations、actions、getters，并且最终模块被                                 放到了state里</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>回调的理解</title>
    <url>/2020/05/12/%E5%9B%9E%E8%B0%83%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="在axios中的回调"><a href="#在axios中的回调" class="headerlink" title="在axios中的回调"></a>在axios中的回调</h3><p>回调就是把函数当作参数传进来，然后你可以调用这个函数，调用的同时你不就可以传些东西出去了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config, success, failure</span>) </span>&#123; <span class="comment">//1.三个参数 后面两个是回调函数</span></span><br><span class="line">  <span class="comment">// 创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'http://123.207.32.32:8000'</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">  instance(config)    <span class="comment">//config为请求参数</span></span><br><span class="line">    .then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(results);</span></span><br><span class="line">      success(results);      <span class="comment">//2.使用传进来的那个函数  并且将results放入这个函数就可以回调传出去</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(error);</span></span><br><span class="line">      failure(error)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">'/home/multidata'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);    <span class="comment">//3. 这里就可以拿到results放入res执行函数，完成回调</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(err);</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue零碎知识点</title>
    <url>/2020/05/12/Vue%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="Vue零碎知识点杂笔"><a href="#Vue零碎知识点杂笔" class="headerlink" title="Vue零碎知识点杂笔"></a>Vue零碎知识点杂笔</h3><p>webpack3的使用    webpack ./src/main.js  ./dist/bundle.js<br>        webpack4的使用    webpack ./src/main.js -o ./dist/bundle.js –mode development</p>
<p>但现在直接用Vue-cli4脚手架快速生成Vue项目</p>
<p>npm run build  ：会去package.json寻找script脚本属性里的build的指令执行  就可以执行项目本地的webpack指令</p>
<p>使用vue-cli2<br>           vue init webpack vueclitest（项目名）<br>        使用vue-cli3 4<br>           vue create vueclitest（项目名）</p>
<a id="more"></a>

<p>进入vue项目管理器：vue ui（可在终端直接使用）</p>
<p>添加vue.config.js这个文件可自定义配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">把一个函数作为参数传到另一个函数时使用箭头函数是最多的</span><br><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;  ===  setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)                        &#125;)	</span><br><span class="line">render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)  ===  render: <span class="function">(<span class="params">h</span>) =&gt;</span> &#123;</span><br><span class="line">                             <span class="keyword">return</span>  h(App)					                </span><br><span class="line">                          &#125;</span><br><span class="line">						  h是形参，调用的时候传入实参createElement来创建App组件</span><br></pre></td></tr></table></figure>

<p>$route指的是当前活跃的路由 负责路由映射<br>        $router  是代码跳转路由  等于App.vue注册的router组件  this.$router.push(‘/user/‘ + this.userId)</p>
<p>所有的组件都继承自Vue类的原型<br>        Vue.prototyoe.xxx  里面放了很多东西  例如$router</p>
<p>对路径起别名对import有效  在html元素中的src要加~</p>
<p>props父传子  $emit子传父</p>
<p>使用网络数据请求记得安装axios</p>
<p>default导出之后引入才可以不加大括号  不然就要import {xxx}  并且default导出的是唯一的  所以可以import 新名字 from…</p>
<p>ul&gt;li{分类列表$}*100  再按Tab快速生成一百行</p>
<p>在我们需要监听一个组件的原生事件时，必须给对应的事件加上.native修饰符才能进行监听</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;back-top @click.native=<span class="string">"backClick"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>this.$refs.aaa  即可拿到scroll这个组件 之后就可调用这个组件里的属性、方法 this.$refs.aaa.scrollTo(0,0)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;scroll ref=<span class="string">"aaa"</span>&gt; &lt;<span class="regexp">/scroll&gt;</span></span><br></pre></td></tr></table></figure>

<p>$bus 事件总线  用于联系两个不相关的组件传递一些事件,一开始的$bus是没有值的 记得去main.js去给他赋值</p>
<p>mixin.js  高级用法：混入   mixin.js里写的一些created() mounted()会和组件里相同的created() mounted()里的代码合并起来<br>       在Vue实例里添加属性mixins: [mixin.js导出的方法对象] 即可使用</p>
<p>$el是真正的dom元素，与document.getElementsby…一样</p>
<p>import {mapActions} from ‘vuex’<br>在methods里写 …mapActions([‘你要映射的方法名’]) 就可以直接this.方法名调用了</p>
<p>移动设备上的浏览器默认会在用户点击屏幕大约延迟300毫秒后才会触发点击事件<br>为了立即响应用户的点击事件，使用npm install fastclick –save</p>
<p>图片懒加载 npm install vue-lazyload –save</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img :src=<span class="string">"showImage"</span> &gt;换成 &lt;img v-lazy=<span class="string">"showImage"</span>&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2020/05/12/Vue/</url>
    <content><![CDATA[<h3 id="Vue整体概括"><a href="#Vue整体概括" class="headerlink" title="Vue整体概括"></a>Vue整体概括</h3><p>main.js主文件  进行App.vue这个根文件  进行渲染，同时可设置路由router</p>
<p>App.vue主界面入口  导入一些自己写的组件 同时可用router-view进行路由渲染 从而不在这里面放入太多的组件</p>
<p>index.js 路由文件  导入VueRouter 并Vue.use(VueRouter)使用  同时写上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"> 	routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>并在上面定义一个routes路由数组 在数组里配置各个路由映射</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    component: Home</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得导入组件，可以直接导入，也可以懒加载导入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = () =&gt; <span class="keyword">import</span>(<span class="string">'../views/home/Home'</span>)</span><br></pre></td></tr></table></figure>

<p>之后项目划分：</p>
<p>​    assets-&gt;css、img  放样式和图片<br>​            common-&gt;mixin.js、utils.js、const.js 放公用函数、常量文件<br>​            components-&gt;common、content  放可复用的组件，同时分为公用和业务所需<br>​            network-&gt;request.js、home.js、detail.js 放网络请求的文件 同时对axios进行一层封装为request<br>​                                          之后home.js等文件只需导入request，并传入url、params作为网络请求的config<br>​            router-&gt;index.js  配置路由 大体只配置主要的部分/home /category /cart /profile /detail/:iid<br>​            store-&gt;index.js、actions.js、mutations.js、getters.js  配置Vuex的五大组件 进行状态管理<br>​            views-&gt;home、category、cart、profile、detail  配置主要部分的视图 业务组件都在这里编写</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud五大神兽</title>
    <url>/2020/05/12/SpringCloud%E4%BA%94%E5%A4%A7%E7%A5%9E%E5%85%BD/</url>
    <content><![CDATA[<h4 id="Eureka注册中心："><a href="#Eureka注册中心：" class="headerlink" title="Eureka注册中心："></a>Eureka注册中心：</h4><p> 注册中心：itcast-eureka(1.引入启动器  2.配置spring.application.name=itcast-eureka  3.在引导类上加注解@EnableEurekaServer)<br>        客户端： itcast-service-provider   itcast-service-consumer<br>         ( 1.引入启动器  </p>
<p>   2.配置spring.application.name  eureka.client.service-url.defaultZone=<a href="http://localhost:10086/eureka" target="_blank" rel="noopener">http://localhost:10086/eureka</a> (下载APP)<br>              3. @EnableDiscoveryClient(启用eureka客户端))</p>
<p>服务名称修改：instance.instance-id=”xxx”  主机IP信息显示:  instance.prefer-ip-address: true  显示服务信息info: <a id="more"></a></p>
<h4 id="Ribbon负载均衡："><a href="#Ribbon负载均衡：" class="headerlink" title="Ribbon负载均衡："></a>Ribbon负载均衡：</h4><p>1.不需要添加启动器 Eureka里面自带了</p>
<p>2.不需要覆盖默认配置就能使用了</p>
<p>3.在RestTemplate上启用 @LoadBalanced 开启负载均衡</p>
<p>4.使用：通过服务名service-provider修改getForObject(“xxx”)里的参数</p>
<p>​               this.restTemplate.getForObject(“<a href="http://service-provider/user&quot;+id,User.class" target="_blank" rel="noopener">http://service-provider/user&quot;+id,User.class</a>);</p>
<h4 id="Hystrix容错组件："><a href="#Hystrix容错组件：" class="headerlink" title="Hystrix容错组件："></a>Hystrix容错组件：</h4><p>降级：检查每次请求，是否请求超时；或者连接池已满<br>                   1.pom.xml加启动器<br>                   2.不需要覆盖默认配置 因为默认设置超时时间为一秒钟 开发过程中够用，但如果需要改就去copy笔记放入service-consumer的application.yml中配置<br>                   3.开启@EnableCircuitBreaker熔断器注解<br>                   4.写一个熔断方法fallbackMethod()，返回类似”服务器正忙，请稍后再试！”  同时在原方法上加个注解@HystrixCommand(fallbackMethod=”fallbackMethod”) 使该方法调用失败时则会调用熔断方法 返回值和参数列表都一致<br>                   5.或给类统一设定一个熔断方法：@DefaultProperties(defaultFallback=”fallbackMethod”)，防止方法太多一直写上面那个注解，如果方法有自己设置@HystrixCommand熔断方法，则使用他自己设置的熔断方法  且全局熔断方法的返回值和被熔断方法一致，但参数列表为空<br>       熔断：不在发送请求  三种状态<br>                   1.close：闭合状态，所有请求正常访问<br>                   2.open：打开状态，所有请求都无法访问。如果在一定时间内容，失败的比例不小于50%或者次数不少于20次<br>                   3.half open： 半开状态，打开状态默认5s休眠期，在休眠期所有请求无法正常访问。过了休眠期就会进入半开状态，放部分请求通过                          @SpringCloudApplication=@SpringbootApplication+@EnableDiscoveryClient+@EnableCircuitBreaker</p>
<h4 id="Feign远程调用组件："><a href="#Feign远程调用组件：" class="headerlink" title="Feign远程调用组件："></a>Feign远程调用组件：</h4><p>1.service-consume的pox.xml加openFeign启动器<br>        2.在引导类上加注解@EnableFeignClients  就不需要用restTemplate了<br>        3.使用Feign就是创建一个接口 接口上加@FeignClient(value=”service-provider”//服务提供者名字)<br>        4.不能使用@RequestMapping写主路径  只能在接口方法上面的@GetMapping()里把路径全写出来（现在好像修复了？）<br>        5.feign.hystrix.enabled: true 开启Hystrix熔断  默认不开启要开启一下<br>        6.写一个类UserClientFallback实现接口  实现方法就是熔断方法  ，并且在接口原先注解 @FeignClient(value=”service-provider” fallback=UserClientFallback.class//实现类.class)<br>然后在熔断类上加@Component  添加入组件</p>
<h4 id="Zuul网关："><a href="#Zuul网关：" class="headerlink" title="Zuul网关："></a>Zuul网关：</h4><p>1.建立独立的模块  引入Cloud Routing-&gt;Zuul 依赖<br>        2.配置port和spring.application.name<br>        3.导入类上加注解@EnableZuulProxy<br>        4.配置路由(分发服务)： zuul：(第三种配置)<br>                                                 routes：<br>                                                 service-provider：/service-provider/**   #这个服务前缀路径路由到这个服务id  #路由名称，随便写，习惯写上服务名<br>                                                 service-consumer(路由名称)：/consumer/**<br>                                                 #path：/service-provider/**<br>                                                 #url： http：//localhost：8082  #service-provider的路径<br>                                                 #serviceId：service-provider<br>                                                 prefix：/api    #zuul网关的前缀  判断有没有通过网关访问服务<br>                                                  eureka：<br>                                                       client：<br>                                                          service-url：<br>                                                             defaultZone：http：//localhost：10086/eureka<br>        5.过滤器  继承ZuulFilter 重写四个方法<br>                                                                  filterType: pre route post error<br>                                                                  filterOrder: 返回值越小优先级越高<br>                                                                  shouldFilter: 是否执行run方法。true执行<br>                                                                  run: 具体的拦截逻辑</p>
<h4 id="SpringCloud-Config分布式配置中心："><a href="#SpringCloud-Config分布式配置中心：" class="headerlink" title="SpringCloud Config分布式配置中心："></a>SpringCloud Config分布式配置中心：</h4><p>每个微服务都有个application.yml，要是成百上千个，这么多yml难以管理，所以SpringCloud推出了该配置中心来管理这些yml<br>       运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息<br>       当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置，将配置信息以REST接口的形式暴露<br>          服务端配置（与GitHub连通）：<br>                1.GitHub建一个仓库 拿到config项目的SSH协议的git地址<br>                2.本地磁盘上新建个git仓库  并右键Git Bash Here输入git clone config项目的SSH协议的git地址<br>                3.在仓库的config项目文件夹里面新建application.yml文件，记住保存编码为UTF-8<br>                4.通过git指令(add commit push)将yml文件上传到GitHub仓库<br>                5.在config模块中导入pom依赖<br>                6.覆盖yml配置文件：cloud.config.server.git.url: GitHub上面的仓库名字  保持一致<br>                7.引导类上加@EnableConfigServer注解<br>          客户端配置：<br>                1.保存好客户端要用的yml文件，并传输到GitHub上<br>                2.创建客户端模块，添加pom依赖<br>                3.添加bootstrap.yml文件（优先级高）   127.0.0.1-&gt;config-3344.com 域名映射<br>               spring:<br>                  cloud:<br>                     config:<br>                       name: microservicecloud-config-client #需要从github上读取的资源名称，注意没有yml后缀名<br>                       profile: dev   #本次访问的配置项<br>                       label: master<br>                       uri: <a href="http://config-3344.com:3344" target="_blank" rel="noopener">http://config-3344.com:3344</a>  #本微服务启动后先去找3344号服务端，通过SpringCloudConfig获取GitHub的服务地址<br>               4.添加application.yml，放个名字就好<br>                   spring:<br>                        application:<br>                             name: microservicecloud-config-client<br>               5.添加带有@RestController注解的类  进行获取配置文件信息<br>               6.启动引导类</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>代码进阶之路</title>
    <url>/2020/05/12/%E4%BB%A3%E7%A0%81%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="对于自我职业规划的问题"><a href="#对于自我职业规划的问题" class="headerlink" title="对于自我职业规划的问题"></a>对于自我职业规划的问题</h3><p>许多人对于自己的一条完整的职业规划之路没有一个清晰的认知，但若你想从一个普通学生变成IT界、大厂里的大牛，往往需要经历什么才从能青铜走向王者呢？</p>
<h4 id="1-青铜——万恶之源"><a href="#1-青铜——万恶之源" class="headerlink" title="1.青铜——万恶之源"></a>1.青铜——万恶之源</h4><p>首先是《计算机基础》这本书，在计算机基础中我们会学到计算机的历史、计算机的特点、进制转换、内存管理、线性数据结构、网络请求协议等等。<br>计算机基础真心很重要，无比重要，究极重要，为啥我这么说呢，里面涉及的计算机知识还有很多网络协议的知识，大家以后一定会用到，我可以负责的告诉你，面试也一定会问，什么Http、Https、Tcp/Ip、三次握手、四次挥手面试不要太常问。<a id="more"></a><br>        Tip：这里有个小插曲就是我身边那个架构师团队Leader这周面试阿里p8岗位的时候，我以为问的都是什么源码，中间件的究极操作，我想大家跟我想的一样，但是大家错了，反而问的很多计算机的基础知识。我聊天大概问了一下面试内容，有什么求二叉树的镜像，内核态和用户态的理解，计算机的缓存页等。 大家是不是惊了，这他*不是我校招的题目么？怎么P8级别的大佬还问这个？其实很好理解，大家想一下到了一定的工作年限技术的广度深度都有一定的造诣了，你写代码就这样了没办法优化了，机器配置也是最好的了，那还能优化啥？<br>        底层！我们都知道所有语言到最后要运行都是变成机器语言的，最后归根究底都是要去跟机器交互的，那计算机的底层是不是最后还是要关注的东西了？<br>        学完计算机基础你基本上对计算机的整个知识体系都一知半解了，对于编程或许还是很懵懂，但是你现在已经要踏入编程的门了。 </p>
<h4 id="2-白银——编程第一课"><a href="#2-白银——编程第一课" class="headerlink" title="2.白银——编程第一课"></a>2.白银——编程第一课</h4><p>计算机基础学了，后面就要编程的入门课程了。想必看我这篇文章有99%的小伙伴都是以下面这段代码开始的自己的程序人生的吧：我还记得大一上开始学习的C语言，《C语言程序设计》课本，在第27页就是第一章，HelloWord，现在回忆起来还历历在目，老师在黑板上写下这两个庄严的单词，同桌的他和我露出无限的求知欲……<br>        我想所有的语言都是语法基础开始的，而且编程语言的基础语法也都是大同小异的。If、For、While等关键字，List、Set、Map等集合，Int、float、Double等基础类型，大家第一次学的时候我想也不会知道，这些关键字将会陪伴我们走完各自的程序生涯吧？<br>        接下去就难一点比如JDBC、IO、文件流啊什么的，依稀的记得当时还是代码里面写SQL然后查询，也不知道记错没有。<br>        学到这里，你可能觉得你JavaSE无敌，出去可以找工作了，反正当时的帅丙，觉得自己可以闯出一片天了，不知天高地厚，四处炫技。但是幼稚的我根本不知道，未知的前方还有什么等着我，我也不知道自己其实才刚入门，但是如果要往WEB方向发展，这些倒是基本足够了。但是你到现在为止学的东西都是服务端的东西呀，怎么让你的服务端东西展示给别人看呢？<br>        这个时候我们就应该去做个丑不拉几的页面，进行简单的交互了，你这个时候要学HTML 、Servlet、MySQL、 JavaScript、Tomcat、CSS等。目标呢就是写出第一个动态网站，也许只是个登陆功能，只能展示下个人资料，但这是很重要的一步，你要弄清楚的是，一个用户的点击产生的请求，是从哪里发起，哪里接收，哪里处理，哪里返回，你得理解浏览器和服务器的关系和分工，Cookie和Session，Request和Response。<br>        Tip：我记得我刚出来面试就有面试题是这样的，一个Http请求从网页发起到服务端产生数据返回中间经历了些什么，或者Spring做了什么？大家可以思考一下<br>         还有有一个自己的项目真心很重要，我就是在大学期间做了项目，至今在校园内网上稳定运行着，出来实习面试的时候基本上也是一路披荆斩棘，吊打了同行面试的仔，反正大学有个项目贼加分，是读者的大学生记住了么？</p>
<h4 id="3-黄金——初出茅庐"><a href="#3-黄金——初出茅庐" class="headerlink" title="3.黄金——初出茅庐"></a>3.黄金——初出茅庐</h4><p>上面的只是WEB开发的学习初级阶段，这都是些JAVA诞生以来最原始的最官方的WEB开发技术，当然现在真正的项目很少直接采用这些技术了，现在都是前后端分离了，Vue、Node.js、React等前端的语言更新迭代速度非常快，我学了一点刚用舒服，前端的朋友告诉我又迭代了……我他喵的不学了！<br>        为了不断提高技术的易用性、开发效率和可维护性、可扩展性，无数开源项目都是在这些原始技术的基础上封装、改进。<br>        所以这个阶段不要盲目乐观地跑去找工作或者对实习挑三拣四，你会被打击到的，又或者找个小公司浑浑噩噩几年过去感觉跟新的技术栈脱节。<br>        有人跟你说小公司学的东西多，他害你的，刚开始能去多大的去多大的，越大越好，你想你去了大的你想去小的分分钟的事情，但是你小的要去大的就相对难了。<br>        好，初始阶段完成，开始进入WEB开发的正题，首先是传说中的框架，SSM（Spring SpringMVC Mybatis）成为熟练的增删改查程序员是必须的，在这个阶段你还要理解为什么要用这仨而不是那些Jsp、Servlet、Jdbc，你要体会到写MVC、三层架构的好处。<br>        这个阶段不要轻易质疑框架的价值，也许刚开始你会觉得麻烦，觉得他们有时候是多此一举，我最开始这么写的时候发现，真的恶心，什么dao，service，Controller等等，分这么多干嘛。等过一两年后回过头来你会觉得少了这些框架你已经很难干活了，没有分层清晰的系统，你反而开口大骂项目的架构师的。不过要提醒大家的是，这个阶段还要避免的心态是，能熟练地增删改查了，就自认为写程序不过如此，然后往简历上填个精通，这也是新手面试被批得体无完肤的原因之一。<br>        浅尝即止，是新手的大忌，为啥这么写，这么写有啥好处，有啥坏处，多问几个为什么，你多年后会感谢敖丙的。<br>        如果你学得好，这会应该能熟练地写个博客啊，小论坛啊之类的WEB项目了，也就是达到了就业的基本要求。<br>        Tip：而且说一下作为一个应届生，你除了基础知识，如果你有自己的技术博客，还有像样的项目能展示给面试官看，是真的很加分，搭建个简单的项目，项目流程你也知道了，技术栈也熟悉了，还可以手机访问网页给面试官现场演示，很加分的。<br>        像我身边的朋友Java3y，JavaGuide，我没有三颗心脏等，就是在这个阶段就已经开始写了自己的博客，并且各自都做出了成绩，这些以后都是你面试的议价能力的一部分，也是你的加分项，和你自身的财富。我问了一下他们，都是靠博客就已经得到不少大公司的面试邀约了，反正有项目，有不错的履历，有不错的博客，都会给你加分，如果你什么都没有，现在动手去多学点，少打两局LOL等你到我这个年纪就会发现，索然无味。</p>
<h4 id="4-铂金——遵义会议"><a href="#4-铂金——遵义会议" class="headerlink" title="4.铂金——遵义会议"></a>4.铂金——遵义会议</h4><p>这会是程序员生涯的一个转折点，把握好了人生起飞，把握不好全盘皆输，所以我用具有重要转折点历史意义的遵义会议，作为这阶段的标题，我觉得，妙啊！<br>        慢慢的你会发现数据库性能实在不行，出于不甘现状，或者赶时髦，你该去了解NoSQL了，Memcached、Redis、Mongodb等非关系型数据库眼花缭乱，没关系，试着用用，能很好地缓解MySQL、Oracle之类关系数据库的压力。<br>        出于公司某些业务需要，你可能会钻研一个特定技术领域，比如全文搜索技术ElasticSearch（以下简称Es），那你了解了Es，你又要想到数据库的数据怎么同步进Es呢？<br>        你可能会接触到Logstash，Canal等中间件，然后发现可视化也是个问题，那Kibana就应运而生，用的时候发现欧洲人的分词习惯跟我们不一样，那Ik中文分词器又得了解啦。使用之后你还会发现他底层的Lucene有很多坑要怎避免，时间多你还可以了解Solr等等。<br>        总之知识就是一个体系，我经常跟群里的仔说，形成知识体系，你面试说了Es那相关的技术栈你一样要了解的，我题目取了叫《吊打面试官》就是噱头，你去面试如果面试官技术深度真的很深，我想被吊打的100%是你。<br>        你甚至会开始对系统中一些比较特殊的存在感兴趣，比如权限系统，单点登陆之类的，又或者某些特定业务领域的算法研究，这些是你的加分项。<br>        你还发现服务拆分后Http通信有诸多弊端，就开始接触优秀的Rpc框架还有消息队列中间件了，如Dubbo、RocketMQ等。<br>        再再后来你发现呀，数据量大得一批，表顶不住了，几亿数据查出来要好几秒，那分库分表就出来，什么水平拆分，垂直拆分，还学习了TDDL、Sharding-JDBC、DRDS等这样的分库分表中间件。但是你用了发现全局的唯一id生成又是一个问题，或许中间件有自带的，但是你还是要了解原理，什么雪花算法，uuid等等也得学。<br>        再再再后来呀，你发现分库分表也顶不住了，业务体量爆炸式增长了，你可能就需要了解动态分库分表的解决思路和解决方案了，特别是FaceBook开源的一些方案。<br>        再再再再后来呀，你发现动态分库分表也不行啊，很多离线的数据也很多啊，每天几个T，公司都要被败光了，那你就要了解大数据场景的离线分析啊，数据缓存啊，数据清洗，数据可视化等等啊什么的。那就需要学什么ODPS啊，Hadoop、Hive、Hbase等等中间件或者工具了。<br>        再再再再再后来你开始发现你的代码很乱，久了以后自己都看不懂，重复的，难以重用的代码堆积如山，不想维护，BUG百出。于是你要开始重视设计模式，合理地改造下自己的代码习惯，不再被僵化的SSH、MVC三层架构束缚住。<br>        再再再再再再…..<br>        到这里不知道你有没有体会到我每篇文章开头那句话的意思？就是工作之后发现自己越来越无知了，你再品一下下面这句话。<br>        你知道的越多，你不知道的越多<br>        Google和各种资料是你进步的动力，极少再遇到必须请教别人才能解决的问题，如果你这个阶段还老是问别人，你的技术生涯也就快到头了。<br>        这个阶段，如果你技术卓越和跟敖丙一样能吹，你的收入将是白领水平，至少接近了，或者大幅领先同龄人了。<br>        我觉得多数程序员在工作多年之后都能达到这个水平，有的人只需要一两年，有的人却要用上五六年，在这个阶段落伍的人，有的是出于天赋和思维所限，有的是出于对技术缺乏热情，有的是出于工作内容的制约。<br>等到年近中年，再也拼不过年轻人，被淘汰出局，只能在自嘲为屌丝和码农的无奈中黯然转行。<br>        这是个很重要的分水龄，你能不能继续进步，能不能在30岁以后继续从事技术工作，能不能在公司里独当一面，我觉得就看你能不能超越这个阶段了。<br>        很多烂公司里工作数年的项目经理，连这个层次都还没达到…<br>        为了30岁的自己听到裁员完全不虚，为了家里的老母亲不再为了省电费不舍得开灯，为了让自己……<br>        我想这个阶段你应该要做好准备，这也是我大篇幅介绍这个阶段的原因。</p>
<h4 id="5-钻石——扬帆起航"><a href="#5-钻石——扬帆起航" class="headerlink" title="5.钻石——扬帆起航"></a>5.钻石——扬帆起航</h4><p>你要读读优秀开源项目的源码，你要搞懂一些当年不懂的基础知识，你开始理解《thinking in java》的精髓，你能写一些底层的代码，有时还会觉得自己封装的比某些开源工具更好用更简单。<br>        当年看不懂的《深入分析JVM虚拟机》现在你已经可以对里面的知识点如数家珍，张口就来，并且能够将大量知识点带入到项目中优化，并且能够看到实质性的变化（暗示KPI）。<br>        WEB的难点和重点永远都在于性能、负载能力上，而现在网络的发达造成了数据量和操作密度的大大上升，硬件却没有相应的进步。<br>        你得试着更好地运用更多的服务器来协同工作，从WEB端到服务端到数据库，全都需要集群，需要分布式，需要合理的控制数据的流向，掌握好网站上下，一大堆机器的平衡，找出性能的瓶颈，找出稳定性和安全性的瓶颈，硬件出现故障，第三方技术出现错误，将被当成家常便饭融入到你的系统和代码里仔细考虑。你会开始觉得方案无比地重要，一将无能累死千军将不断应验，一个不好的设计，一个不好的方案，会让一群优秀的程序员工作成果大打折扣。<br>        你要关注架构知识，不能再满足于SSH三层架构到底。领域驱动设计，面向事件开发，敏捷开发等等一系列的思想在关键时刻能决定你项目的生死，这个阶段不再有标准范例让你照抄，你只知道思想和原理，实践却需要自己不断尝试和改进。<br>        多关注各种杂七杂八的开源技术，有些你可能前面已经接触过了，和通信有关的，和集成开发环境有关的，和架构有关的，各个领域你都应该能信口说上几个主流技术，虽然你可能只是听说过，了解。但关键时刻你得知道如何去选择技术，并快速掌握它。<br>        你还会去考虑尝试下别的语言，这里不是说转向什么C++ C#之类的，那和JAVA程序员不相干，我说的是一些运行于JVM之上的语言，比如scala和groovy，初识他们时你会觉得Java真的老了。<br>        但当你回到一个综合性的大型项目中，又会觉得Java积累下来的整个体系技术是如此完善，就像一个工业化标准一样，你可能发现光是Spring家族的东西你都受用终身，无法完全通读。你能把这个阶段实践好，胜任项目经理，乃至中小公司的技术总监，大厂的小团队Leader都是可以的</p>
<h4 id="6-大师——登峰造极"><a href="#6-大师——登峰造极" class="headerlink" title="6.大师——登峰造极"></a>6.大师——登峰造极</h4><p>其实写到上面这个阶段的时候我觉得，这是很多人满足的地方了，都是小公司技术总监了，那我图啥？<br>但是未知的人生还在那等着你呢，我问了身边顶级的大神，为啥要走出舒适区？去像字节跳动、阿里等这些压力大很多的地方呢？<br>        他们给的回答都不太一样，但是一样的就是挑战自我吧，谁也不知道哪里是自己的终点，那为啥不多做点尝试，新的环境，新的技术栈，新业务场景挑战新的自我。<br>        这个阶段你的一举一动可能都关系一个项目的生死存亡，一个错误或者正确的决策就可能改变整个项目的命运，水能载舟亦能覆舟，我想用在这里也恰到好处。<br>        我身边这样级别的大佬凤毛麟角，但不是没有，他们在公司都是核心人物，大型项目或者项目紧要关头都是他们带领团队冲冲冲，除了问题也是能最快给出解决思路和方案的。<br>        Tip：我现在的老大就是这样的人，双十一大家还手忙脚乱去追数据的时候，他上来一套操作，写了几个脚本就搞定了，卧槽我们当时周围一群人，从头到尾的知识盲区，结束了还没反应过来，只能拍手叫666。<br>        这就是强者的世界，我所向往的世界，当然我知道这样的世界，只有一步一个脚印才能涉足。</p>
<h4 id="7-王者——泰山之巅"><a href="#7-王者——泰山之巅" class="headerlink" title="7.王者——泰山之巅"></a>7.王者——泰山之巅</h4><p>最后王者其实我不会写任何内容，能到这个领域的人本身就是屈指可数了，敖丙身边有，但是我觉得大家自己体会吧，一般就是人脉，交际，能力都到了一定的高度了，这个阶段的事情我也体会不到。<br>        能想到的就只有先祖的诗句：指点江山，挥斥方遒。算是给大家留下无限遐想的空间吧，未来或许你就是你所在领域的王者也说不定的呢对吧。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>不知不觉写了这么多了，以上是我个人眼里的一般向JAVA 程序员的发展线路，限于篇辐也不全面，实际个人成长路线可能因为工作内容的不同差异会很大，有的人偏向了底层研究，有的人偏向了业务需求设计，有的带有浓重的行业色彩，而且技术之外，还有很多知识也很重要，做JAVA没有轻松的方向，但一个对技术抱有兴趣的人，走到这一步时，仍然会对开发抱有热情，想要写出好的项目。<br>        纯为了生计而工作的程序猿是走不到这一步的，这一行来都来了，大家一天都是24小时，为啥有差距，我想你我都明白的，知道为啥那就干出点名堂吧。</p>
<p>Just do it ！</p>
]]></content>
      <categories>
        <category>代码进阶分享</category>
      </categories>
  </entry>
  <entry>
    <title>跨域问题</title>
    <url>/2020/05/07/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="跨域问题的解决"><a href="#跨域问题的解决" class="headerlink" title="跨域问题的解决"></a>跨域问题的解决</h3><p>所谓同源是指,域名,协议,端口均相同,只要有一个不同,就是跨域 </p>
<p>而对于跨域问题的解决很简单，直接在后端创建一个config文件夹</p>
<p>并在里面放上CrosConfig.java文件，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzs.springboottest.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrosConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"GET"</span>, <span class="string">"HEAD"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>, <span class="string">"OPTIONS"</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>套用代码</category>
      </categories>
  </entry>
</search>
